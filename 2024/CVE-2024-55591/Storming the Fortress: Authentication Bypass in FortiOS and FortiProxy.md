# 0. Identifying the vulnerability

On January 14, 2025, Fortinet published a security advisory for CVE-2024-55591.

CVE-2024-55591 is an **Authentication Bypass Using an Alternate Path or Channel** vulnerability (CWE-288) affecting FortiOS and FortiProxy. This vulnerability allows a remote attacker to gain **super-admin privileges** by sending specially crafted requests to the **Node.js WebSocket module**. According to Fortinet's security advisory successful exploitation requires knowledge of an admin accountâ€™s username.

##### Affected Versions:

- **FortiOS:**
    - Versions **7.0.0 to 7.0.16** (fix: upgrade to 7.0.17 or later)
- **FortiProxy:**
    - Versions **7.2.0 to 7.2.12** (fix: upgrade to 7.2.13 or later)
    - Versions **7.0.0 to 7.0.19** (fix: upgrade to 7.0.20 or later)

# 1. Patch difference analysis

*In this article, we will not delve into the methods for unpacking and decrypting FortiOS firmware, as these techniques are well-documented and freely available online.*

Based on previous researches, we know that **Node.js logic** is contained in the `/node-scripts/` directory of the firmware. After unpacking the firmware, we compared the `index.js` files from FortiOS versions **7.0.16** (vulnerable) and **7.0.17** (patched) to identify the changes made to address the vulnerability.

---
### Key Findings:

#### **1. Removal of `local_access_token` validation in `_getAdminSession`**

In the patched version (7.0.17), all references to the parameter `local_access_token` (stored in the `localToken` variable) were **removed** from the `_getAdminSession` function. This parameter was previously used to authenticate users by allowing them to pass the `local_access_token` in their requests.

This change effectively eliminates the ability to exploit the `local_access_token` parameter for authentication bypass, as it is no longer recognized or validated by the function.

![image](https://github.com/user-attachments/assets/9ea027e7-5d87-4728-9f41-3c946caf4efd)
![image](https://github.com/user-attachments/assets/c40d92d7-a88a-46a7-8e7f-edf228569f0a)
#### 2. **Change in WebSocket Handling in `CliConnection`**

In the vulnerable version (7.0.16), the line:
```javascript
ws.on("message", (msg) => cli.write(msg));
```
was directly present in the main execution flow of the `CliConnection` class. However, in the patched version (7.0.17), this line was **moved into the `setup()` function**.

This change reorganizes the WebSocket message handling logic, making it part of a dedicated function. The refactoring indicates a structural change in how WebSocket messages are processed in the CLI, likely aiming to improve control and maintainability.

---
### Summary of findings

These two key changes allow us to draw conclusions about the nature of the vulnerability and its potential exploitation methods:

1. **API Authentication Bypass:**  
    The removal of the `local_access_token` parameter from the `_getAdminSession` function suggests that the authentication bypass is likely related to the improper validation or handling of this parameter. Attackers could exploit this flaw to gain unauthorized access via API requests.
    
2. **Remote Code Execution (RCE):**  
    The relocation of the WebSocket handling logic (`ws.on("message", (msg) => cli.write(msg)`) into the `setup()` function indicates that the vulnerability may involve the ability to send arbitrary commands to the CLI over WebSocket. This opens the door for remote code execution if the input is not properly validated.
    

These findings highlight how the vulnerability could allow attackers to bypass authentication mechanisms and execute arbitrary commands, posing a severe security risk to affected systems.

# 2. Understating authentication mechanism

The FortiGate Web GUI offers users the ability to interact with the CLI directly from the browser. By examining the HTTP requests, we discovered that initiating the Web CLI involves sending a connection request to the following URL:
```
https://fortigate.example/ws/cli/open/
```
Below is a detailed breakdown of the WebSocket connection process and the authentication mechanism involved.

---
##### 1. **WebSocket Connection Initialization**

When a WebSocket connection is established, the server handles the request as follows:
```javascript
this._server.on('connection', (ws, request) => {
    const dispatcher = new WebsocketDispatcher(ws, request);
    dispatcher.dispatch();
});
```
- The WebSocket server creates an instance of `WebsocketDispatcher` for each connection.
- The `dispatch()` method is called to process the connection further.
---
##### 2. **`dispatch()` Method**

The `dispatch()` method handles session validation and determines how to process the WebSocket request:
```javascript
async dispatch() {
    const { session, isCsfAdmin } = await this._getSession();
    if (!session) {
        this.ws.send('Unauthorized');
        this.ws.close();
        return null;
    }

    if (this.path.startsWith('/ws/cli/')) {
        return new CliConnection(this.ws, { headers }, this.searchParams, this.groupContext);
    }
}
```
- The `_getSession()` method retrieves the session and checks if the user has sufficient privileges.
- If the session is invalid, the connection is terminated. Otherwise, a `CliConnection` instance is created to handle CLI interactions.
---
##### 3. **Session Validation with `_getSession()`**

The `_getSession()` method is central to the authentication process:
```javascript
async _getSession() {
    const isConnectionFromCsf = this.request.headers['user-agent'] === CSF_USER_AGENT &&
        this.localIpAddress === '127.0.0.1';
    let isCsfAdmin = false;
    let session;

    if (!isConnectionFromCsf) {
        session = await webAuth.getValidatedSession(this.request, { authFor: 'websocket' });
        if (session && session.fmg_admin && (session.sso_login_type === 'none')) {
            isCsfAdmin = true;
        }
    } else {
        // Local CSF connection logic
        session = { /* Predefined session object */ };
        isCsfAdmin = true;
    }

    return { session, isCsfAdmin };
}
```
- The method checks if the request originates from a local CSF connection by matching the `CSF_USER_AGENT` and local IP `127.0.0.1`. If true, a predefined session object is created.
- For non-local requests, it calls `webAuth.getValidatedSession()` to validate the session based on tokens or cookies.
---
##### 4. **Token-Based Validation with `webAuth.getValidatedSession()`**

This method manages token extraction and session lookup:
```javascript
async getValidatedSession(request, options = {}) {
    const authToken = await this._extractToken(request);
    let session = null;

    if (authToken) {
        const sessionEntry = webSession.get(authToken);
        if (sessionEntry) {
            session = sessionEntry.session;
        }
    }

    if (!session) {
        session = await this._getAdminSession(request, options);
    }

    if (authToken && !(await this._csrfValidation(request))) {
        session = null;
    }

    return session;
}
```
- The `_extractToken()` method retrieves the token or API key from the request.
- If a valid session is not found in the cache (`webSession.get()`), it falls back to `_getAdminSession()` for further validation.
---
##### 5. **Fallback to `_getAdminSession()`**

If no session is found in the cache, the `_getAdminSession()` method attempts to validate the `local_access_token` passed in the URL query parameter:
```javascript
async _getAdminSession(request, options = {}) {
    const query = querystring.parse(request.url.replace(/.*\?/, ''));
    const localToken = query.local_access_token;
    const authParams = ["monitor", "web-ui", "node-auth"];

    if (localToken) {
        authParams[authParams.length - 1] += `?local_access_token=${localToken}`;
        authParamsFound = true;
    }

    if (!authParamsFound) {
        return null;
    }

    return await new ApiFetch(...authParams);
}
```
- The `local_access_token` is extracted from the query string.
- If a token is provided, it is appended to the `node-auth` parameter of the predefined `authParams` array.
- The method then calls `ApiFetch`, passing the `authParams` array (`["monitor", "web-ui", "node-auth?local_access_token=TOKEN"]`) as arguments for further processing.
---
##### 6. **REST API Request via `ApiFetch`**

The `ApiFetch` class sends a REST API request with the parameters provided by `_getAdminSession()`:
1. The `authParams` array constructs the API endpoint:
```
https://fortigate.example/api/v2/monitor/web-ui/node-auth?local_access_token=TOKEN
```
2. The `ApiFetch` constructor defines default HTTP headers:
```javascript
const defaultHeaders = {
    'user-agent': SYMBOLS.NODE_USER_AGENT, // Predefined Node.js User-Agent
    'accept-encoding': 'gzip, deflate'
};
```
3. The `fetch` function sends a request to the constructed URL with the default headers. The server processes this request and returns the session information, assuming the `local_access_token` is present in the request.
---
### Section Conclusions

The Node.js authentication process only verifies the **presence** of the `local_access_token` parameter in the WebSocket request. It does not validate the token's authenticity or ensure that it corresponds to a legitimate session. This token is then passed directly to the REST API for further processing.

Critically, the request sent to the REST API contains **no additional headers** to authenticate the client. Essential information, such as `client-ip` or `x-forwarded-for`, is completely absent, making it impossible for the server to verify the true origin of the request. 

---

# 3. Bypassing authentication

### 1. Bypassing REST API Authentication

Based on the research conducted during the analysis of **CVE-2022-40684** (FortiOS, FortiProxy, and FortiSwitchManager Authentication Bypass), we hypothesized that **CVE-2024-55591** leverages the same REST API authentication mechanisms as CVE-2022-40684.

To analyze this, we used a **FortiGate KVM 7.0.16 virtual machine** and observed all debug information generated when sending a request to `/ws/cli/?local_access_token=TOKEN`. Using a random string as the `TOKEN`, we identified the following chain of events triggered by this request:

1. **Opening WebSocket Connection to the endpoint:**
```
/ws/cli/?local_access_token=TOKEN
```
2. **GET Request to REST API:**
```
GET /api/v2/monitor/web-ui/node-auth
```
As detailed in the previous section, due to the **lack of headers such as `client-ip` or `x-forwarded-for`**, the API assumes that the request originates from `127.0.0.1` and the `User-Agent` **Node.js**.

3. **Successful REST API Authentication:**
The REST API processes the request through the `api_access_check_for_trusted_access` function. However, the actual request handling is performed by a separate function which we named `is_trusted_ip_and_user_agent`. This function simply compares the IP address from the request and the User-Agent with the "trusted" values. This minimal validation grants successful authentication if the request appears to originate from `127.0.0.1` with the expected `Node.js` User-Agent, similar to the scenario observed in CVE-2022-40684.

![image](https://github.com/user-attachments/assets/9c56cae8-de0e-4cb6-b1de-73e26e4634af)
![image](https://github.com/user-attachments/assets/1f93871f-c2cf-458d-9bc6-4ef2603c7812)

4. **Following successful authentication, the system opens a connection to the CLI.**
5. **A login context is sent over the established connection, finalizing the authentication process.**
6. **The connection is then closed from the CLI side.**

![image](https://github.com/user-attachments/assets/0a6fc08a-c892-4133-8e9e-b21855ca6713)

At this point, we observed that by passing a random `local_access_token` value, we successfully bypassed the REST API authentication. However, shortly after "Sending login context" was executed, the CLI connection was abruptly terminated. This indicates that while the initial authentication bypass was achieved, the subsequent connection handling failed, suggesting additional layers of defense or incompatibilities in the exploitation process. 

---
### 2. Bypassing CLI Authentication

Based on the findings from the previous section on bypassing REST API authentication, we proceeded to investigate the CLI authentication mechanism. Our analysis revealed that the CLI authentication process involves sending a `loginContext` string, which is constructed from request headers. To understand the exact format of the data sent to the CLI after successfully bypassing REST API authentication, we monitored the traffic on port 8023 of the FortiGate VM.

The captured traffic revealed that the authentication data sent to the CLI appears in the following format:

```
"Local_Process_Access" "Local_Process_Access" "root" "" "" "none" [10.0.2.4]:53680 [10.0.2.5]:443
```

![image](https://github.com/user-attachments/assets/28817a0a-326e-403a-88c5-82ac2cbf14e6)

Upon receiving this string, the CLI terminates the connection, indicating that the user associated with these credentials lacks the necessary permissions for CLI access.

To further analyze this, we revisited the code in `index.js`. Notably, the line:

```javascript
ws.on("message", (msg) => cli.write(msg));
```

was modified in a patch. Prior to this patch, this line allowed any message received from the WebSocket connection to be written directly to the CLI before the legitimate `loginContext` was sent. This created a **race condition**, where an attacker could potentially inject their own authentication data before the system's legitimate `loginContext` was processed.

To exploit this race condition, we needed to craft a valid authentication string that the CLI would accept. By monitoring the traffic on port 8023 during a legitimate CLI connection attempt, we identified the format of a valid authentication string:

```
"admin" "admin" "root" "super_admin" "root" "none" [10.0.2.4]:49924 [10.0.2.5]:443
```

![image](https://github.com/user-attachments/assets/4e88b925-c322-4a5a-b7ce-21f2eb38ee23)

The critical insight here is that the race condition in the WebSocket message handling allows an attacker to send a crafted authentication string to the CLI before the system sends its own `loginContext`. If the attacker's string is received first, the CLI will authenticate the attacker with the permissions specified in the crafted string, effectively bypassing the authentication mechanism.

In summary, the CLI authentication bypass exploits a race condition in the WebSocket message handling, enabling an attacker to inject a valid authentication string before the system's legitimate `loginContext` is processed.

---
### Authentication bypass summary

The primary issue lies in the inadequate validation of the `local_access_token` parameter, which is only checked for its presence rather than its authenticity. This oversight allows attackers to bypass REST API authentication by providing any arbitrary token, as the system assumes the request originates from a trusted source due to the absence of headers like `client-ip` or `x-forwarded-for`.

Furthermore, the WebSocket message handling in the CLI authentication process contains a race condition. This vulnerability enables attackers to inject a crafted authentication string before the system processes its legitimate `loginContext`. By exploiting this race condition, attackers can bypass CLI authentication entirely, granting themselves admin privileges.
