import socket
import argparse
import threading
import time
import ipaddress
from concurrent.futures import ThreadPoolExecutor
from impacket.dcerpc.v5 import transport, nrpc

class ExploitChecker:
    def __init__(self, target_ip):
        self.target_ip = target_ip
        self.results = {
            "ldap_connect": False,
            "rpc_connect": False,
            "netlogon_service": False,
            "ldap_callback": False
        }

    def check_rpc_port(self, port=49664):
        try:
            rpctransport = transport.DCERPCTransportFactory(f'ncacn_ip_tcp:{self.target_ip}[{port}]')
            dce = rpctransport.get_dce_rpc()
            dce.connect()
            try:
                dce.bind(nrpc.MSRPC_UUID_NRPC)
                self.results["netlogon_service"] = True
            except:
                pass
            dce.disconnect()
            self.results["rpc_connect"] = True
            return True
        except:
            return False

    def check_ldap_port(self, port=389):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((self.target_ip, port))
            sock.close()
            self.results["ldap_connect"] = (result == 0)
            return self.results["ldap_connect"]
        except:
            return False

    def ldap_callback_listener(self):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.bind(('0.0.0.0', 389))
            sock.settimeout(5)
            while not self.results["ldap_callback"]:
                try:
                    data, addr = sock.recvfrom(1024)
                    if addr[0] == self.target_ip:
                        self.results["ldap_callback"] = True
                        break
                except socket.timeout:
                    break
            sock.close()
        except Exception as e:
            print(f"LDAP Listener Error: {str(e)}")

    def run_checks(self):
        print(f"\n[*] Checking {self.target_ip}")
        
        listener_thread = threading.Thread(target=self.ldap_callback_listener)
        listener_thread.daemon = True
        listener_thread.start()

        with ThreadPoolExecutor(max_workers=3) as executor:
            executor.submit(self.check_rpc_port)
            executor.submit(self.check_ldap_port)
        
        time.sleep(6)
        
        can_exploit = all(self.results.values())
        status = "Potentially Vulnerable" if can_exploit else "Not Vulnerable"
        
        print(f"[{self.target_ip}]")
        print(f"├── RPC (49664): {'✓' if self.results['rpc_connect'] else '✗'}")
        print(f"├── LDAP (389): {'✓' if self.results['ldap_connect'] else '✗'}")
        print(f"├── Netlogon: {'✓' if self.results['netlogon_service'] else '✗'}")
        print(f"├── Callbacks: {'✓' if self.results['ldap_callback'] else '✗'}")
        print(f"└── Status: {status}\n")
        
        return can_exploit

def check_targets(targets):
    vulnerable_hosts = []
    for ip in targets:
        checker = ExploitChecker(str(ip))
        if checker.run_checks():
            vulnerable_hosts.append(str(ip))
    return vulnerable_hosts

def parse_ip_input(ip_input):
    try:
        return list(ipaddress.ip_network(ip_input, strict=False).hosts())
    except ValueError:
        try:
            return [ipaddress.ip_address(ip_input)]
        except ValueError:
            with open(ip_input, 'r') as f:
                return [ipaddress.ip_address(line.strip()) for line in f if line.strip()]

def main():
    parser = argparse.ArgumentParser(description="Multi-target LDAP Nightmare Pre-Exploit Checker")
    parser.add_argument("target", help="Target IP, subnet (CIDR), or file with IP list")
    parser.add_argument("-o", "--output", help="Output file for vulnerable hosts")
    args = parser.parse_args()

    try:
        targets = parse_ip_input(args.target)
        print(f"[*] Loaded {len(targets)} targets")
        
        vulnerable_hosts = check_targets(targets)
        
        print("\n[+] Scan Complete")
        print(f"[+] Found {len(vulnerable_hosts)} potentially vulnerable hosts")
        
        if args.output and vulnerable_hosts:
            with open(args.output, 'w') as f:
                for host in vulnerable_hosts:
                    f.write(f"{host}\n")
            print(f"[+] Results saved to {args.output}")

    except Exception as e:
        print(f"[-] Error: {str(e)}")

if __name__ == "__main__":
    main()
