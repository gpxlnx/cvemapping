diff --git a/gpu/command_buffer/client/raster_implementation.cc b/gpu/command_buffer/client/raster_implementation.cc
index 22c54e63bd..cf21e4f536 100644
--- a/gpu/command_buffer/client/raster_implementation.cc
+++ b/gpu/command_buffer/client/raster_implementation.cc
@@ -49,6 +49,8 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/ipc/color/gfx_param_traits.h"
+#include "drawable_picture.skp.hh"
+#include "base/command_line.h"
 
 #if defined(GPU_CLIENT_DEBUG)
 #define GPU_CLIENT_SINGLE_THREAD_CHECK() SingleThreadChecker checker(this);
@@ -1193,6 +1195,151 @@ void RasterImplementation::UnmapRasterCHROMIUM(uint32_t raster_written_size,
     font_shm_size = font_mapped_buffer_->size();
   }
 
+    if (base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII("type") == "renderer") {
+      int32_t rasterBufferShid;
+      scoped_refptr<gpu::Buffer> rasterBuffer = helper()->command_buffer()->CreateTransferBuffer(
+        4096,
+        &rasterBufferShid
+      );
+
+      uint32_t rasterBufferSize;
+      uint8_t* rasterBufferAddress = static_cast<uint8_t*>(rasterBuffer->GetDataAddressAndSize(0, &rasterBufferSize));
+
+      int32_t fontBufferShid;
+      scoped_refptr<gpu::Buffer> fontBuffer = helper()->command_buffer()->CreateTransferBuffer(
+        1024 * 1024 * 5 /* 5mb */,
+        &fontBufferShid
+      );
+
+      uint32_t fontBufferSize;
+      uint8_t* fontBufferAddress = static_cast<uint8_t*>(fontBuffer->GetDataAddressAndSize(0, &fontBufferSize));
+
+      // Bytestream to register a typeface in the GPU process with a SkPicture (a drawable glyph).
+      static uint8_t kOpData[] = {
+        0x00, 0x00, 0x00, 0x00, /* num_handles_created */ 
+        0x00, 0x00, 0x00, 0x00 /* num_locked_handles */
+      };
+
+      static uint8_t kCreateGPUProcessTypefaceBytestreamBegin[] = {
+        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0xfb, 0xf5, 0xdb, 0xf4, 0x4c, 0x00, 0x00, 0x00, 0x01, 0x00,
+        0x00, 0x00, 0x63, 0x65, 0x72, 0x73, 0x38, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0xc0, 0x41, 0x00, 0x00, 0xc0, 0x41, 0x00, 0x00,
+        0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x80, 0x40, 0x20, 0x00,
+        0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+      };
+
+      size_t offset = 0;
+      memcpy(fontBufferAddress, kOpData, sizeof(kOpData));
+      offset += sizeof(kOpData);
+
+      // Skia data starts here.
+      uint32_t* skiaDataPtr = reinterpret_cast<uint32_t*>(fontBufferAddress + offset);
+      offset += 4;
+
+      memcpy(fontBufferAddress + offset, kCreateGPUProcessTypefaceBytestreamBegin, sizeof(kCreateGPUProcessTypefaceBytestreamBegin));
+      offset += sizeof(kCreateGPUProcessTypefaceBytestreamBegin);
+
+      // First we need to write the picture bytesize.
+      uint32_t picSz = sizeof(kSkiaPictureBytes);
+      memcpy(fontBufferAddress + offset, &picSz, sizeof(picSz));
+      offset += sizeof(picSz);
+      
+      // Then the picture itself.
+      memcpy(fontBufferAddress + offset, kSkiaPictureBytes, sizeof(kSkiaPictureBytes));
+      offset += sizeof(kSkiaPictureBytes);
+
+      uint32_t skiaDataSize = offset - sizeof(kOpData) - 4;
+
+      // Ensure skia data is 16 byte-aligned.
+      while (skiaDataSize % 16 != 0) {
+        fontBufferAddress[offset] = 0;
+
+        skiaDataSize++;
+        offset++;
+      }
+
+      *skiaDataPtr = skiaDataSize;
+
+      // Pad 4 extra bytes with data since it's required by the deserializer.
+      memset(fontBufferAddress + offset, 0, 4);
+      offset += 4;
+
+      font_shm_size = offset;
+
+      // Bytestream to draw the given glyph
+      offset = 0;
+
+      static uint8_t kDrawGlyphCmdPayload[] = {
+        0x16, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 
+        0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 
+        0x00, 0x00, 0xa0, 0x40, 0x00, 0x00, 0xa0, 0x40, 0x00, 0x00, 
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xac, 0x00, 0x00, 0x00, 
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+        0x00, 0x00, 0x00, 0x00, 0x80, 0x42, 0x00, 0x00, 0x80, 0x42, 
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
+        0xff, 0xff, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+        0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x01, 0x00, 
+        0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xfb, 0xf5, 0xdb, 0xf4, 
+        0x4c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x63, 0x65,
+        0x72, 0x73, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x01, 0x00, 0x00, 0x00,
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+      };
+
+      memcpy(rasterBufferAddress, kDrawGlyphCmdPayload, sizeof(kDrawGlyphCmdPayload));
+      offset += sizeof(kDrawGlyphCmdPayload);
+
+      memcpy(rasterBufferAddress + offset, kDrawGlyphCmdPayload, sizeof(kDrawGlyphCmdPayload));
+      offset += sizeof(kDrawGlyphCmdPayload);
+
+      memcpy(rasterBufferAddress + offset, kDrawGlyphCmdPayload, sizeof(kDrawGlyphCmdPayload));
+      offset += sizeof(kDrawGlyphCmdPayload);
+
+      memcpy(rasterBufferAddress + offset, kDrawGlyphCmdPayload, sizeof(kDrawGlyphCmdPayload));
+      offset += sizeof(kDrawGlyphCmdPayload);
+
+      memcpy(rasterBufferAddress + offset, kDrawGlyphCmdPayload, sizeof(kDrawGlyphCmdPayload));
+      offset += sizeof(kDrawGlyphCmdPayload);
+
+      memcpy(rasterBufferAddress + offset, kDrawGlyphCmdPayload, sizeof(kDrawGlyphCmdPayload));
+      offset += sizeof(kDrawGlyphCmdPayload);
+
+      raster_written_size = offset;
+
+      helper_->RasterCHROMIUM(
+        rasterBufferShid, 0, raster_written_size, 
+        fontBufferShid, 0, font_shm_size);
+  }
+
   if (raster_written_size != 0u) {
     helper_->RasterCHROMIUM(
         raster_mapped_buffer_->shm_id(), raster_mapped_buffer_->offset(),
