import socket
import struct
import sysy

def build_dns_query(domain, qtype=1):
    """
    Constructs a valid DNS query packet compatible with BIND.
    
    :param domain: The domain to query (e.g., example.com)
    :param qtype: DNS query type (1 = A, 2 = NS, 5 = CNAME, 28 = AAAA)
    :return: The complete DNS query in binary format.
    """
    # Transaction ID (random)
    transaction_id = struct.pack(">H", 0x1234)

    # Flags: Standard query (0x0100)
    flags = struct.pack(">H", 0x0100)

    # Questions, Answer RRs, Authority RRs, Additional RRs (set to 1, 0, 0, 0)
    qdcount = struct.pack(">H", 1)  # Number of questions
    ancount = struct.pack(">H", 0)  # No answers
    nscount = struct.pack(">H", 0)  # No authority records
    arcount = struct.pack(">H", 1)  # EDNS0 record

    # Convert domain to DNS format (split by dots)
    query_body = b"".join(
        struct.pack("B", len(part)) + part.encode("utf-8") for part in domain.split(".")
    ) + b"\x00"

    # Query type (A record = 1) and Query class (IN = 1)
    qtype = struct.pack(">H", qtype)  # Type A (1) or AAAA (28)
    qclass = struct.pack(">H", 1)  # Class IN (Internet)

    # EDNS0 Support (Adds support for larger DNS messages)
    edns_name = b"\x00"
    edns_type = struct.pack(">H", 41)  # OPT Record Type
    edns_payload_size = struct.pack(">H", 4096)  # Max payload size
    edns_extended_rcode = struct.pack("B", 0)  # No extended RCODE
    edns_version = struct.pack("B", 0)  # EDNS Version 0
    edns_z_flags = struct.pack(">H", 0)  # Z Flags
    edns_data_length = struct.pack(">H", 0)  # No additional data

    # Combine all parts into a full query
    dns_query = (
        transaction_id
        + flags
        + qdcount
        + ancount
        + nscount
        + arcount
        + query_body
        + qtype
        + qclass
        + edns_name
        + edns_type
        + edns_payload_size
        + edns_extended_rcode
        + edns_version
        + edns_z_flags
        + edns_data_length
    )

    # Prepend message length (required for TCP DNS queries)
    dns_query = struct.pack(">H", len(dns_query)) + dns_query
    return dns_query


def send_dns_query_tcp(server, domain, qtype=1):
    """
    Sends a DNS query over TCP to a BIND-compatible server.

    :param server: The DNS server to query (e.g., 8.8.8.8)
    :param domain: The domain name to look up (e.g., example.com)
    :param qtype: The query type (default: 1 for A record)
    :return: The raw DNS response.
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(5)  # Set timeout for connection
            print(f"[+] Connecting to {server} on port 53 (TCP)...")
            sock.connect((server, 53))

            # Build the DNS query
            dns_query = build_dns_query(domain, qtype)
            print(f"[+] Sending DNS query for {domain} (Type: {qtype})")
            sock.sendall(dns_query)

            # Read the first 2 bytes (length of response)
            response_length = sock.recv(2)
            if len(response_length) < 2:
                print("[!] Failed to receive response length.")
                return None

            response_size = struct.unpack(">H", response_length)[0]
            print(f"[+] Expecting {response_size} bytes...")

            # Receive the actual DNS response
            response = sock.recv(response_size)
            if not response:
                print("[!] No response received.")
                return None

            print("[+] DNS response received!")
            return response

    except socket.timeout:
        print("[!] Timeout: Server did not respond.")
        return None
    except Exception as e:
        print(f"[!] Error: {e}")
        return None


def main():
    dns_server = sys.argv[1]  # Google Public DNS
    domain = "example.com"  # Domain to query
    qtype = 1  # Query Type: A record
    for i in range(0,0x10000):
      response = send_dns_query_tcp(dns_server, domain, qtype)

    if response:
        print(f"[+] Raw DNS Response: {response.hex()}")


if __name__ == "__main__":
    main()
