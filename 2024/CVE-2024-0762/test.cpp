#include <iostream>
#include <cstring>
#include <cassert>

constexpr size_t bufSz = 256;
constexpr size_t ovSz = bufSz + 64;

void hexPr(const char* lbl, const char* buf, size_t num) {
   std::cout << lbl << ":\n";
   for (size_t i = 0; i < num; ++i) {
      printf("%02X ", (unsigned char)buf[i]);
      if ((i + 1) % 16 == 0) std::cout << "\n";
   }
   std::cout << "\n";
}

void layPr(const char* st, uint64_t ret) {
   std::cout << st << ": [buf:" << bufSz << "][ret:" << std::hex << ret << "]\n";
}

// Vulnerable function: Copies inpSz bytes into buf, which is only bufSz in size.
// This overflows buf if inpSz > bufSz and can overwrite adjacent variables (like ret).
void vuln(char* buf, size_t inpSz, uint64_t* ret) {
   char* data = new char[inpSz]; 
   memset(data, 0xAA, inpSz);  // Fill with 0xAA
   memcpy(buf, data, inpSz);   // Potential overflow here!
   *ret = 0xDEADBEEF; // Set ret value after overflow
   delete[] data;
}

// Safe function: Asserts and enforces no overflow.
void safe(char* buf, size_t inpSz, size_t sz, uint64_t* ret) {
   assert(inpSz <= sz); // Ensure no overflow
   size_t safeSz = inpSz > sz ? sz : inpSz;
   char* data = new char[safeSz];
   memset(data, 0xBB, safeSz); // Fill with 0xBB
   memcpy(buf, data, safeSz);  // No overflow
   *ret = 0xCAFEBABE;
   delete[] data;
}

int main() {
   char buf[bufSz] = {0};
   uint64_t ret = 0xCAFEBABE;
   size_t inpSz = ovSz;

   layPr("Start", ret);
   hexPr("Pre", buf, bufSz);

   std::cout << "Vuln\n";
   std::cout << "ret before vuln: 0x" << std::hex << ret << "\n";
   vuln(buf, inpSz, &ret);
   hexPr("Post", buf, ovSz);
   layPr("PostVuln", ret); // This may show ret overwritten by overflow

   memset(buf, 0, bufSz);
   ret = 0xCAFEBABE;

   std::cout << "\nSafe\n";
   std::cout << "ret before safe: 0x" << std::hex << ret << "\n";
   safe(buf, inpSz, bufSz, &ret);
   hexPr("PostSafe", buf, bufSz);
   layPr("PostSafe", ret);

   std::cout << "\nCheck gdb\n";
   return 0;
}
