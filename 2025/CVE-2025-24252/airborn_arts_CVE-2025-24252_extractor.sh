#!/usr/bin/env bash

# Script to find traces of "Airborne" vulnerabilities in iOS logs (.logarchive)
# Saves the results of 'log show' commands to separate files.
# Author: Anton Shustikov ceo@cakecats.com (CakesCats Project)

# --- Configuration ---
# Timezone for interpreting --start/--end and for displaying timestamps in logs
# Etc/GMT-7 corresponds to UTC+7 (sign is inverted for Etc/GMT)
# You can change this to your target timezone for log analysis.
# Examples: "UTC", "America/New_York", "Europe/London", "Asia/Tokyo"
# To use the system's local timezone for --start/--end interpretation, leave TZ_SETTING empty or comment it out.
TZ_SETTING="Etc/GMT-7" # Example: UTC+7 for interpreting --start/--end arguments
# Timezone for the --timezone option in 'log show' for output display.
# This should ideally match TZ_SETTING or be a named equivalent.
# Examples: "UTC", "America/New_York", "Europe/London", "Asia/Tokyo", "Asia/Bangkok" (for UTC+7)
TIMEZONE_DISPLAY="Asia/Bangkok" # Example: Display logs in UTC+7

# Verbosity flags for 'log show'. Remove --debug for less voluminous output.
LOG_SHOW_VERBOSE_FLAGS="--info --debug"
# LOG_SHOW_VERBOSE_FLAGS="--info" # A less verbose option

# --- Helper Functions ---
print_usage() {
    echo "Usage: $0 /path/to/iphone_logs.logarchive [time_range_parameters]"
    echo ""
    echo "Time_range_parameters are standard options for 'log show', for example:"
    echo "  --last 7d"
    echo "  --last 24h"
    echo "  --start \"YYYY-MM-DD HH:MM:SS\" --end \"YYYY-MM-DD HH:MM:SS\""
    echo ""
    echo "If time range parameters are not specified, '--last 7d' is used by default."
    echo "Results will be saved to a folder named 'airborne_traces_YYYYMMDD_HHMMSS' in the current directory."
    echo ""
    echo "Examples:"
    echo "  $0 ./MyIphoneLogs.logarchive"
    echo "  $0 ./MyIphoneLogs.logarchive --last 2d"
    echo "  $0 ./MyIphoneLogs.logarchive --start \"2025-04-10 00:00:00\" --end \"2025-04-12 23:59:59\""
}

print_step() {
    echo ""
    echo "================================================================================"
    echo "STEP: $1"
    echo "================================================================================"
}

print_info() {
    echo "[INFO] $1"
}

print_error() {
    echo "[ERROR] $1" >&2
}

# --- Argument Parsing and Setup ---
if [ -z "$1" ]; then
    print_error "Error: Path to .logarchive file not specified."
    print_usage
    exit 1
fi

LOG_ARCHIVE_PATH="$1"
# Check if the log archive path is an absolute path, if not, make it absolute
if [[ "$LOG_ARCHIVE_PATH" != /* ]]; then
  LOG_ARCHIVE_PATH="$(pwd)/$LOG_ARCHIVE_PATH"
fi

shift # Remove the first argument (archive path), the rest will be time parameters

# Use -d to check for a directory, as .logarchive is a bundle (directory)
if [ ! -d "$LOG_ARCHIVE_PATH" ]; then
    print_error "Error: Log archive (directory) '$LOG_ARCHIVE_PATH' not found or is not a directory."
    print_error "Please ensure the path is correct and the .logarchive bundle exists."
    exit 1
fi

TIME_RANGE_ARGS=("$@") # Use remaining arguments for time

if [ ${#TIME_RANGE_ARGS[@]} -eq 0 ]; then
    TIME_RANGE_ARGS=("--last" "7d") # Default if time arguments are not provided
    print_info "Time range not specified, using default: ${TIME_RANGE_ARGS[*]}"
else
    print_info "Using specified time range: ${TIME_RANGE_ARGS[*]}"
fi

# Create a directory for results
OUTPUT_DIR_BASENAME="airborne_traces_$(date +%Y%m%d_%H%M%S)"
# Try to create output directory in the same location as the script if possible, else current dir
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
OUTPUT_DIR="$SCRIPT_DIR/$OUTPUT_DIR_BASENAME"

mkdir -p "$OUTPUT_DIR"
if [ $? -ne 0 ]; then
    print_error "Failed to create results directory: $OUTPUT_DIR"
    # Fallback to current directory
    OUTPUT_DIR="$(pwd)/$OUTPUT_DIR_BASENAME"
    print_info "Attempting to create results directory in current working directory: $OUTPUT_DIR"
    mkdir -p "$OUTPUT_DIR"
    if [ $? -ne 0 ]; then
        print_error "Failed to create results directory in current working directory either: $OUTPUT_DIR"
        exit 1
    fi
fi
print_info "Results will be saved to: $OUTPUT_DIR"

# --- Main Logic ---

# Function to execute log show queries
# $1: Predicate for log show
# $2: Output filename base (without extension)
# $3: Description of the query
run_log_query() {
    local predicate="$1"
    local output_filename_base="$2"
    local description="$3"
    local output_filepath="$OUTPUT_DIR/${output_filename_base}.txt"

    print_step "$description"
    print_info "Query is executing. This may take some time..."
    
    local cmd_prefix=""
    if [ -n "$TZ_SETTING" ]; then
        cmd_prefix="TZ=$TZ_SETTING "
    fi

    # Construct the command string for log show
    # Using an intermediate variable for the command helps in debugging if needed
    # Note: LOG_SHOW_VERBOSE_FLAGS should not be quoted if it contains multiple space-separated flags
    local full_command_string="${cmd_prefix}log show \\
        --timezone \"$TIMEZONE_DISPLAY\" \\
        --archive \"$LOG_ARCHIVE_PATH\" \\
        ${TIME_RANGE_ARGS[*]} \\
        --predicate \"$predicate\" \\
        $LOG_SHOW_VERBOSE_FLAGS \\
        --loss --signpost --source \\
        > \"$output_filepath\""
    
    # For actual execution, it's better to call directly to preserve argument separation
    if [ -n "$TZ_SETTING" ]; then
        TZ="$TZ_SETTING" log show \
            --timezone "$TIMEZONE_DISPLAY" \
            --archive "$LOG_ARCHIVE_PATH" \
            "${TIME_RANGE_ARGS[@]}" \
            --predicate "$predicate" \
            $LOG_SHOW_VERBOSE_FLAGS \
            --loss --signpost --source \
            > "$output_filepath"
    else
        log show \
            --timezone "$TIMEZONE_DISPLAY" \
            --archive "$LOG_ARCHIVE_PATH" \
            "${TIME_RANGE_ARGS[@]}" \
            --predicate "$predicate" \
            $LOG_SHOW_VERBOSE_FLAGS \
            --loss --signpost --source \
            > "$output_filepath"
    fi
    
    local exit_status=$?
    if [ $exit_status -eq 0 ]; then
        if [ -s "$output_filepath" ]; then # Check if file is not empty
             print_info "Results saved to: $output_filepath"
        else
             print_info "Query executed, but the result is empty (no matches found): $output_filepath"
        fi
    else
        print_error "Query failed for '$description' (exit code: $exit_status)."
        print_error "Approximate command that failed (for debugging):"
        # Reconstruct the command string carefully for display
        local display_cmd_args=""
        for arg in "${TIME_RANGE_ARGS[@]}"; do
            if [[ "$arg" == *" "* ]]; then
                display_cmd_args+=" \"$arg\""
            else
                display_cmd_args+=" $arg"
            fi
        done
        print_error "${cmd_prefix}log show --timezone \"$TIMEZONE_DISPLAY\" --archive \"$LOG_ARCHIVE_PATH\"$display_cmd_args --predicate '$predicate' $LOG_SHOW_VERBOSE_FLAGS --loss --signpost --source > \"$output_filepath\""
        print_error "Check console output from 'log show' above if any, or if the output file contains error messages."
    fi
}

# List of queries (predicate, filename base, description)

if [ -n "$TZ_SETTING" ]; then
    print_info "Log analysis started. Timezone for command interpretation: TZ=$TZ_SETTING, for output display: $TIMEZONE_DISPLAY"
else
    print_info "Log analysis started. Using system local timezone for command interpretation, for output display: $TIMEZONE_DISPLAY"
fi


run_log_query \
    '(processImagePath CONTAINS "mediaserverd" OR processImagePath CONTAINS "AirPlayXPCHelper" OR processImagePath CONTAINS "rapportd" OR processImagePath CONTAINS "mDNSResponder" OR processImagePath CONTAINS "WirelessRadioManagerd" OR processImagePath CONTAINS "wifid") AND (eventType == "fault" OR messageType == "error")' \
    "01_critical_process_errors" \
    "Faults and errors for critical processes (mediaserverd, AirPlayXPCHelper, rapportd, mDNSResponder, WirelessRadioManagerd, wifid)"

run_log_query \
    '(processImagePath CONTAINS "mediaserverd" OR processImagePath CONTAINS "AirPlayXPCHelper" OR processImagePath CONTAINS "rapportd" OR processImagePath CONTAINS "mDNSResponder") AND (eventMessage CONTAINS[c] "terminated unexpectedly" OR eventMessage CONTAINS[c] "exception" OR eventMessage CONTAINS[c] "panic" OR eventMessage CONTAINS[c] "failed to start")' \
    "02_process_termination_exceptions" \
    "Unexpected termination or exceptions in processes (mediaserverd, AirPlayXPCHelper, rapportd, mDNSResponder)"

run_log_query \
    '(subsystem == "com.apple.kernel" AND category == "panic") OR (process == "kernel" AND eventMessage CONTAINS[c] "panic")' \
    "03_kernel_panics" \
    "Kernel panics"

run_log_query \
    'subsystem CONTAINS[c] "AirPlay" AND (messageType == "error" OR eventType == "fault")' \
    "04_airplay_subsystem_errors" \
    "Errors and faults in the AirPlay subsystem"

run_log_query \
    '(processImagePath CONTAINS "mDNSResponder" OR subsystem == "com.apple.mDNSResponder") AND (messageType == "error" OR eventType == "fault" OR eventMessage CONTAINS[c] "malformed" OR eventMessage CONTAINS[c] "fail")' \
    "05_mdns_errors" \
    "Errors and faults in mDNSResponder (Bonjour), including 'malformed' and 'fail'"

run_log_query \
    '(subsystem CONTAINS[c] "AirPlay" OR subsystem CONTAINS[c] "rapport" OR processImagePath CONTAINS "AirPlay" OR processImagePath CONTAINS "rapportd") AND (eventMessage CONTAINS[c] "pair" OR eventMessage CONTAINS[c] "auth" OR eventMessage CONTAINS[c] "connect" OR eventMessage CONTAINS[c] "ACL") AND (eventMessage CONTAINS[c] "fail" OR eventMessage CONTAINS[c] "error" OR eventMessage CONTAINS[c] "denied" OR eventMessage CONTAINS[c] "timeout" OR eventMessage CONTAINS[c] "bypass")' \
    "06_airplay_pairing_auth_failures" \
    "Issues with pairing, authentication, connection, or ACL in AirPlay/rapportd"

run_log_query \
    '(processImagePath CONTAINS "mediaserverd" OR processImagePath CONTAINS "rapportd" OR processImagePath CONTAINS "AirPlayXPCHelper") AND (eventMessage CONTAINS[c] "connection failed" OR eventMessage CONTAINS[c] "connection reset" OR eventMessage CONTAINS[c] "host unreachable" OR eventMessage CONTAINS[c] "timeout" OR eventMessage CONTAINS[c] "cannot connect")' \
    "07_network_connection_errors" \
    "Network connection errors from mediaserverd, rapportd, AirPlayXPCHelper processes"

run_log_query \
    'processImagePath CONTAINS "networkd" AND messageType == "error"' \
    "08_networkd_errors" \
    "Errors in the system networkd service"

run_log_query \
    '(eventMessage CONTAINS[c] "sandbox" AND (eventMessage CONTAINS[c] "violation" OR eventMessage CONTAINS[c] "denial")) OR (processImagePath CONTAINS "kernel" AND eventMessage CONTAINS[c] "Sandbox" AND messageType == "error")' \
    "09_sandbox_violations" \
    "Messages related to sandbox violations"

run_log_query \
    'processImagePath CONTAINS "profiled" OR processImagePath CONTAINS "mdmd" OR eventMessage CONTAINS[c] "profile install" OR eventMessage CONTAINS[c] "configuration profile"' \
    "10_profile_activity" \
    "Activity related to configuration profiles (installation, modification)"

print_step "Log analysis finished"
echo "All results saved in directory: $OUTPUT_DIR"
echo "It is recommended to carefully review the created files for anomalies."
echo "If files are empty, it means no matches were found for that query in the specified period."

exit 0
