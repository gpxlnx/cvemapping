<# 
.SYNOPSIS
  NTLM/SMB Hardening Toolkit (Audit | Harden | Revert) – Safe/Defensive Use Only

.DESCRIPTION
  - Audits NTLM/SMB hardening posture
  - Optionally enforces recommended settings (Mode Harden) or reverts to prior values (Mode Revert)
  - Supports allowlisting of trusted SMB ranges
  - Hunts recent NTLM events and Explorer-initiated SMB connections
  - Performs benign TCP:445 reachability tests to sample hosts
  - Exports results to JSON/CSV

.PARAMETER Mode
  Audit | Harden | Revert  (default: Audit)

.PARAMETER AllowlistCIDRs
  Comma-separated CIDR ranges considered trusted for SMB/NTLM (e.g., "10.0.0.0/8,172.16.0.0/12")

.PARAMETER HoursBack
  How far back to hunt events (default: 12)

.PARAMETER SampleHosts
  Comma-separated list of hosts/IPs to test TCP:445 reachability (benign) (e.g., "10.0.0.10,filesrv.corp")

.PARAMETER ExportJson / ExportCsv
  Paths to export results

.PARAMETER WhatIf
  Simulate changes when Mode Harden/Revert

.NOTES
  Safe for blue-team validation; no exploit or forced authentication.
#>

[CmdletBinding(SupportsShouldProcess=$true)]
param(
  [ValidateSet('Audit','Harden','Revert')]
  [string]$Mode = 'Audit',
  [string]$AllowlistCIDRs = '10.0.0.0/8,172.16.0.0/12,192.168.0.0/16',
  [int]$HoursBack = 12,
  [string]$SampleHosts = '',
  [string]$ExportJson = '',
  [string]$ExportCsv  = ''
)

# -------------------- Helpers --------------------
function Get-RegValue {
  param([string]$Path,[string]$Name,[ValidateSet('String','DWord','QWord','MultiString','Binary')][string]$Type='DWord')
  try {
    $item = Get-ItemProperty -Path $Path -ErrorAction Stop
    return $item.$Name
  } catch { return $null }
}

function Set-RegValue {
  param([string]$Path,[string]$Name,[object]$Value,[ValidateSet('String','DWord','QWord','MultiString','Binary')][string]$Type='DWord')
  if (-not (Test-Path $Path)) { New-Item -Path $Path -Force | Out-Null }
  if ($PSCmdlet.ShouldProcess("$Path\$Name","Set to $Value ($Type)")) {
    New-ItemProperty -Path $Path -Name $Name -Value $Value -PropertyType $Type -Force | Out-Null
  }
}

function Save-CurrentSetting {
  param([hashtable]$bag,[string]$Key,[string]$Path,[string]$Name,[string]$Type='DWord')
  if (-not $bag.ContainsKey($Key)) {
    $bag[$Key] = @{
      Path  = $Path
      Name  = $Name
      Type  = $Type
      Value = Get-RegValue -Path $Path -Name $Name -Type $Type
    }
  }
}

function New-Result {
  param($Check,$Current,$Target,$Pass,$Fix)
  [pscustomobject]@{
    Check   = $Check
    Current = $Current
    Target  = $Target
    Pass    = [bool]$Pass
    Fix     = $Fix
  }
}

function Test-CIDRContains {
  param([string]$CIDR,[string]$IP)
  try {
    $parts = $CIDR.Split('/')
    $net   = [System.Net.IPAddress]::Parse($parts[0]).GetAddressBytes()
    $mask  = [int]$parts[1]
    $ipb   = [System.Net.IPAddress]::Parse($IP).GetAddressBytes()
    if ($net.Length -ne $ipb.Length) { return $false }
    $bits = 0
    for ($i=0; $i -lt $net.Length; $i++) {
      $take = [Math]::Min(8, [Math]::Max(0, $mask - 8*$i))
      $maskByte = if ($take -le 0) { 0 } else { 0xFF -shl (8-$take) -band 0xFF }
      if (($net[$i] -band $maskByte) -ne ($ipb[$i] -band $maskByte)) { return $false }
      $bits += $take
      if ($bits -ge $mask) { break }
    }
    return $true
  } catch { return $false }
}

function Test-IPInAllowlist {
  param([string[]]$CIDRs,[string]$IP)
  foreach ($c in $CIDRs) { if (Test-CIDRContains -CIDR $c.Trim() -IP $IP) { return $true } }
  return $false
}

$Desired = @{
  # 1) Restrict outgoing NTLM (2 = Deny all; 1 = Allow to remote server only, 0 = Allow all)
  'NTLM.RestrictSending' = @{
    Path='HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0'; Name='RestrictSendingNTLMTraffic'; Type='DWord'; Target=2
    Fix='Set "Network security: Restrict NTLM: Outgoing NTLM traffic to remote servers" to Deny all'
  }
  # 1b) LmCompatibilityLevel (send NTLMv2 only / refuse LM & NTLM)
  'NTLM.LmCompat' = @{
    Path='HKLM:\SYSTEM\CurrentControlSet\Control\Lsa'; Name='LmCompatibilityLevel'; Type='DWord'; Target=5
    Fix='Set LmCompatibilityLevel=5 (send NTLMv2 only; refuse LM & NTLM)'
  }
  # 1c) NtlmMinClientSec – require 128-bit & NTLMv2 session security
  'NTLM.MinClientSec' = @{
    Path='HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0'; Name='NtlmMinClientSec'; Type='DWord'; Target=0x20080000
    Fix='Require 128-bit encryption and NTLMv2 session security'
  }
  # 2) SMB client signing required
  'SMB.Client.RequireSign' = @{
    Path='HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters'; Name='RequireSecuritySignature'; Type='DWord'; Target=1
    Fix='Enable "Microsoft network client: Digitally sign communications (always)"'
  }
  # 2b) SMB server signing required
  'SMB.Server.RequireSign' = @{
    Path='HKLM:\System\CurrentControlSet\Services\LanManServer\Parameters'; Name='RequireSecuritySignature'; Type='DWord'; Target=1
    Fix='Enable "Microsoft network server: Digitally sign communications (always)"'
  }
  # 3) Disable insecure guest
  'SMB.Client.Guest' = @{
    Path='HKLM:\System\CurrentControlSet\Services\LanManWorkstation\Parameters'; Name='AllowInsecureGuestAuth'; Type='DWord'; Target=0
    Fix='Set AllowInsecureGuestAuth=0'
  }
  # 4) Hardened UNC paths NETLOGON/SYSVOL
  # (implemented separately since values are under named entries)
  # 5) WebClient disabled
  'WebClient.Start' = @{
    Path='HKLM:\SYSTEM\CurrentControlSet\Services\WebClient'; Name='Start'; Type='DWord'; Target=4
    Fix='Disable WebClient/WebDAV if not required (Start=4)'
  }
  # 6) SMBv1 disabled (client/server)
  'SMBv1.Server' = @{
    Path='HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters'; Name='SMB1'; Type='DWord'; Target=0
    Fix='Disable SMBv1 server'
  }
  'SMBv1.Client' = @{
    Path='HKLM:\SYSTEM\CurrentControlSet\Services\mrxsmb10'; Name='Start'; Type='DWord'; Target=4
    Fix='Disable SMBv1 client driver (Start=4)'
  }
}

$Backup = @{}  # for Revert
$Results = New-Object System.Collections.Generic.List[object]

# -------------------- Audit core keys --------------------
foreach ($k in $Desired.Keys) {
  $d = $Desired[$k]
  Save-CurrentSetting -bag $Backup -Key $k -Path $d.Path -Name $d.Name -Type $d.Type
  $cur = Get-RegValue -Path $d.Path -Name $d.Name -Type $d.Type
  $pass = ($cur -ne $null -and [int64]$cur -eq [int64]$d.Target)
  $Results.Add( (New-Result -Check $k -Current $cur -Target $d.Target -Pass $pass -Fix $d.Fix) )
}

# -------------------- Hardened UNC Paths --------------------
$hardenPath = 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\NetworkProvider\HardenedPaths'
$netlogonKey = '\\*\NETLOGON'
$sysvolKey   = '\\*\SYSVOL'
try {
  $curNet  = Get-RegValue -Path $hardenPath -Name $netlogonKey -Type 'String'
  $curSys  = Get-RegValue -Path $hardenPath -Name $sysvolKey   -Type 'String'
} catch { $curNet=$null; $curSys=$null }
$targetVal = 'RequireMutualAuthentication=1,RequireIntegrity=1'
$passUNC = ($curNet -eq $targetVal) -and ($curSys -eq $targetVal)
$Results.Add( (New-Result -Check 'UNC.HardenedPaths' -Current @{"\\*\NETLOGON"=$curNet;"\\*\SYSVOL"=$curSys} -Target @{"\\*\NETLOGON"=$targetVal;"\\*\SYSVOL"=$targetVal} -Pass $passUNC -Fix 'Enable Hardened UNC Paths for NETLOGON/SYSVOL with RequireMutualAuthentication=1,RequireIntegrity=1') )
# backup
Save-CurrentSetting -bag $Backup -Key 'UNC.Netlogon' -Path $hardenPath -Name $netlogonKey -Type 'String'
Save-CurrentSetting -bag $Backup -Key 'UNC.Sysvol'   -Path $hardenPath -Name $sysvolKey   -Type 'String'

# -------------------- Firewall: outbound 445/139 blocks --------------------
$portFilters = Get-NetFirewallPortFilter -Direction Outbound -Protocol TCP -ErrorAction SilentlyContinue
$blockRules = @()
if ($portFilters) {
  foreach ($pf in $portFilters) {
    $rule = Get-NetFirewallRule -AssociatedNetFirewallPortFilter $pf -ErrorAction SilentlyContinue
    if ($pf.RemotePort -in 445,139 -and $rule.Action -eq 'Block' -and $rule.Enabled -eq 'True') { $blockRules += $rule }
  }
}
$Results.Add( (New-Result -Check 'FW.Outbound.SMB.Block' -Current ($blockRules.DisplayName -join ', ') -Target 'Block TCP 445/139 to untrusted' -Pass ($blockRules.Count -gt 0) -Fix 'Create outbound block rules for 445/139; allow only approved servers/ranges') )

# -------------------- Optional Hardening / Revert --------------------
if ($Mode -in 'Harden','Revert') {
  if ($Mode -eq 'Harden') {
    foreach ($k in $Desired.Keys) {
      $d=$Desired[$k]; Set-RegValue -Path $d.Path -Name $d.Name -Value $d.Target -Type $d.Type
    }
    Set-RegValue -Path $hardenPath -Name $netlogonKey -Value $targetVal -Type 'String'
    Set-RegValue -Path $hardenPath -Name $sysvolKey   -Value $targetVal -Type 'String'
    # Minimal outbound blocks (idempotent): create disabled Allowlist permit rules, then a catch-all block
    $allowCidrs = $AllowlistCIDRs.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
    $ruleNameAllow = 'Allow SMB to Trusted Ranges'
    $ruleNameBlock = 'Block SMB to Untrusted'
    if ($PSCmdlet.ShouldProcess('Firewall','Ensure SMB allow/block rules')) {
      # Remove existing with same names (safe re-create)
      Get-NetFirewallRule -DisplayName $ruleNameAllow -ErrorAction SilentlyContinue | Remove-NetFirewallRule -Confirm:$false
      Get-NetFirewallRule -DisplayName $ruleNameBlock -ErrorAction SilentlyContinue | Remove-NetFirewallRule -Confirm:$false
      foreach ($cidr in $allowCidrs) {
        New-NetFirewallRule -DisplayName $ruleNameAllow -Direction Outbound -Action Allow -Enabled True -Protocol TCP -RemoteAddress $cidr -RemotePort 445,139 -Profile Any | Out-Null
      }
      New-NetFirewallRule -DisplayName $ruleNameBlock -Direction Outbound -Action Block -Enabled True -Protocol TCP -RemoteAddress Any -RemotePort 445,139 -Profile Any | Out-Null
    }
    Write-Host "[Harden] Applied registry, UNC, and firewall rules." -ForegroundColor Green
  } else {
    # Revert: restore saved values if available in registry backup file (created below)
    $backupFile = "$PSScriptRoot\ntlm_smb_backup.json"
    if (Test-Path $backupFile) {
      $bk = Get-Content $backupFile -Raw | ConvertFrom-Json
      foreach ($b in $bk) {
        if ($b.Path -and $b.Name) {
          if ($b.Value -eq $null) {
            if ($PSCmdlet.ShouldProcess("$($b.Path)\$($b.Name)",'Remove')) {
              Remove-ItemProperty -Path $b.Path -Name $b.Name -ErrorAction SilentlyContinue
            }
          } else {
            if ($PSCmdlet.ShouldProcess("$($b.Path)\$($b.Name)",'Restore')) {
              New-Item -Path $b.Path -Force | Out-Null
              New-ItemProperty -Path $b.Path -Name $b.Name -Value $b.Value -PropertyType $b.Type -Force | Out-Null
            }
          }
        }
      }
      Write-Host "[Revert] Registry keys restored from backup." -ForegroundColor Yellow
      # Remove our firewall rules
      Get-NetFirewallRule -DisplayName 'Allow SMB to Trusted Ranges' -ErrorAction SilentlyContinue | Remove-NetFirewallRule -Confirm:$false
      Get-NetFirewallRule -DisplayName 'Block SMB to Untrusted' -ErrorAction SilentlyContinue | Remove-NetFirewallRule -Confirm:$false
    } else {
      Write-Warning "No backup file found at $backupFile. Nothing to revert."
    }
  }
}

# Save backup (first run of any mode)
$backupOut = @()
foreach ($entry in $Backup.Keys) { $backupOut += $Backup[$entry] }
$backupPath = "$PSScriptRoot\ntlm_smb_backup.json"
$backupOut | ConvertTo-Json -Depth 5 | Out-File -Encoding UTF8 $backupPath

# -------------------- Event Hunting --------------------
$since = (Get-Date).AddHours(-1 * [math]::Abs($HoursBack))
$allowCidrsList = $AllowlistCIDRs.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }

#  (A) NTLM Operational log (Microsoft-Windows-NTLM/Operational) if enabled
$NTLMLog = 'Microsoft-Windows-NTLM/Operational'
try {
  $ntlmEnabled = (wevtutil get-log $NTLMLog) -match 'enabled: true'
} catch { $ntlmEnabled = $false }

$ntlmEvents = @()
if ($ntlmEnabled) {
  $ntlmEvents = Get-WinEvent -LogName $NTLMLog -ErrorAction SilentlyContinue | Where-Object { $_.TimeCreated -ge $since }
}

#  (B) Security Log 4624 (Logon) filtering NTLM
$secFilter = @{LogName='Security'; StartTime=$since; Id=4624}
$sec4624 = Get-WinEvent -FilterHashtable $secFilter -ErrorAction SilentlyContinue | ForEach-Object {
  $msg = $_ | Format-List -Property * | Out-String
  if ($msg -match 'Authentication Package:\s+NTLM') { $_ }
}

#  (C) Sysmon EID 3 Explorer.exe -> 445/139 (if Sysmon installed)
$sysmon = Get-Service -Name Sysmon64 -ErrorAction SilentlyContinue
$sysmonEvents = @()
if ($sysmon -and $sysmon.Status -eq 'Running') {
  try {
    $sysmonEvents = Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; Id=3; StartTime=$since} -ErrorAction SilentlyContinue |
      Where-Object {
        $_.Message -match 'Image:\s+C:\\\\Windows\\\\explorer\.exe' -and
        ($_.Message -match 'DestinationPort:\s+445' -or $_.Message -match 'DestinationPort:\s+139')
      }
  } catch {}
}

# Reduce to suspicious (non-allowlisted) where possible
function Extract-IP { param($text) if ($text -match 'SourceAddress:\s+([0-9\.]+)') { $matches[1] } elseif ($text -match 'DestinationIp:\s+([0-9\.]+)') { $matches[1] } elseif ($text -match 'Source Network Address:\s+([0-9\.]+)') { $matches[1] } else { $null } }

$suspicious = @()

foreach ($e in $sysmonEvents) {
  $ip = Extract-IP -text $e.Message
  if ($ip -and -not (Test-IPInAllowlist -CIDRs $allowCidrsList -IP $ip)) {
    $suspicious += [pscustomobject]@{ Source='Sysmon3'; Time=$e.TimeCreated; RemoteIP=$ip; Detail=$e.Message.Substring(0,[Math]::Min(400,$e.Message.Length)) }
  }
}

foreach ($e in $sec4624) {
  $msg = $e | Format-List * | Out-String
  if ($msg -match 'Source Network Address:\s+([0-9\.]+)') {
    $ip = $matches[1]
    if ($ip -and -not (Test-IPInAllowlist -CIDRs $allowCidrsList -IP $ip)) {
      $suspicious += [pscustomobject]@{ Source='Sec4624'; Time=$e.TimeCreated; RemoteIP=$ip; Detail=$msg.Substring(0,[Math]::Min(400,$msg.Length)) }
    }
  }
}

foreach ($e in $ntlmEvents) {
  $msg = $e | Format-List * | Out-String
  $ip = Extract-IP -text $msg
  if ($ip -and -not (Test-IPInAllowlist -CIDRs $allowCidrsList -IP $ip)) {
    $suspicious += [pscustomobject]@{ Source='NTLM-Operational'; Time=$e.TimeCreated; RemoteIP=$ip; Detail=$msg.Substring(0,[Math]::Min(400,$msg.Length)) }
  }
}

$Results.Add( (New-Result -Check 'Events.SuspiciousNTLMorSMB' -Current $suspicious.Count -Target '0 outside allowlist' -Pass ($suspicious.Count -eq 0) -Fix 'Investigate Explorer-initiated SMB or NTLM logons to non-trusted IPs; tighten egress/NTLM restrictions') )

# -------------------- Benign Connectivity Tests (optional) --------------------
$reach = @()
if ($SampleHosts) {
  $hosts = $SampleHosts.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
  foreach ($h in $hosts) {
    $t = Test-NetConnection -ComputerName $h -Port 445 -InformationLevel Quiet
    $reach += [pscustomobject]@{ Host=$h; Port445Reachable=$t; Trusted=( (Resolve-DnsName -Name $h -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty IPAddress) | ForEach-Object { Test-IPInAllowlist -CIDRs $allowCidrsList -IP $_ } ) }
  }
  $bad = $reach | Where-Object { $_.Port445Reachable -and (-not $_.Trusted) }
  $Results.Add( (New-Result -Check 'Connectivity.445' -Current ($reach | ConvertTo-Json -Compress) -Target 'Only reachable within allowlist' -Pass ($bad.Count -eq 0) -Fix 'Block outbound 445/139 to non-allowlisted hosts') )
}

# -------------------- Output --------------------
$sorted = $Results | Sort-Object { if ($_.Pass) {1} else {0} }, Check
$sorted | Format-Table -AutoSize

if ($suspicious.Count -gt 0) {
  "`n--- Suspicious (non-allowlisted) NTLM/SMB indicators (last $HoursBack h) ---" | Write-Host
  $suspicious | Sort-Object Time | Format-Table Time,Source,RemoteIP -AutoSize
}

if ($reach.Count -gt 0) {
  "`n--- Benign reachability to TCP:445 (sample) ---" | Write-Host
  $reach | Format-Table -AutoSize
}

if ($ExportJson) { $Results | ConvertTo-Json -Depth 6 | Out-File -Encoding UTF8 $ExportJson }
if ($ExportCsv)  { $Results | Export-Csv -NoTypeInformation -Path $ExportCsv -Encoding UTF8 }

if (($Results | Where-Object { -not $_.Pass }).Count -gt 0) { exit 2 } else { exit 0 }
