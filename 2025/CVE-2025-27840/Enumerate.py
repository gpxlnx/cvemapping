import bluetooth
import serial
import time
import binascii
from threading import Thread

class BluetoothEnumerator:
    def __init__(self):
        self.device = None
        self.running = True

    def find_serial_port(self):
        # This is a basic implementation - you might need to adjust based on your ESP32
        import serial.tools.list_ports
        ports = serial.tools.list_ports.comports()
        for port in ports:
            if "USB" in port.description or "Serial" in port.description:
                return port.device
        return None

    def receiver_thread(self):
        while self.running:
            try:
                if self.device and self.device.in_waiting > 0:
                    data = self.device.read(1024)  # Read available bytes
                    if data:
                        print(f"Received Packet ({len(data)}): {binascii.hexlify(data).decode('utf-8')}")
            except Exception as ex:
                print(f"Receiver error: {ex}")
                time.sleep(1)  # Wait before retrying

    def enumerate_vendor_specific_commands(self):
        # OGF for vendor-specific commands is 0x3F
        # OCF can range from 0x00 to 0x3FF (10 bits)
        for ocf in range(0x400):  # 0 to 0x3FF
            try:
                # Construct HCI command: [0x01 (Command Packet), OCF (low byte), 0xFC (OGF 0x3F), 0x00 (no parameters)]
                command = bytes([0x01, ocf & 0xFF, 0xFC, 0x00])
                command_string = f"0xFC{ocf & 0xFF:02X}"

                print(f"Sending command {command_string}...")
                self.device.write(command)
                time.sleep(0.1)  # Brief wait for response
            except Exception as ex:
                print(f"Command 0xFC{ocf & 0xFF:02X} failed: {ex}")

    def run(self):
        try:
            # Step 1: Find and initialize serial port (assuming ESP32 over USB)
            print("Initializing USB Bluetooth device...")
            port = self.find_serial_port()
            if not port:
                print("No USB Bluetooth devices found. Ensure your ESP32 is connected and in HCI mode.")
                return

            # Step 2: Open the device
            self.device = serial.Serial(port, baudrate=115200, timeout=1)
            print(f"Device found and opened on {port}")

            # Step 3: Start receiver thread
            print("Starting receiver thread...")
            receiver = Thread(target=self.receiver_thread, daemon=True)
            receiver.start()

            # Step 4: Reset the device
            print("Resetting device...")
            self.device.write(bytes([0x01, 0x03, 0x0C, 0x00]))  # CMD_RESET
            time.sleep(1)  # Wait for reset

            # Step 5: Enumerate vendor-specific commands
            print("Starting enumeration of vendor-specific commands (OGF 0x3F)...")
            self.enumerate_vendor_specific_commands()

            # Step 6: Cleanup
            print("Enumeration complete. Closing device...")
            self.running = False
            self.device.close()

        except Exception as ex:
            print(f"Error: {ex}")
        finally:
            print("Press Enter to exit...")
            input()

if __name__ == "__main__":
    enumerator = BluetoothEnumerator()
    enumerator.run()
