/*
Vulnerable function based on the heap-based buffer overflow vulnerablity
of the scan_ps() function in cups v2.4.6

See CVE-2023-4504 for more details: https://takeonme.org/cves/cve-2023-4504/
Exploit originally discovered By AHA (Austin Hackerâ€™s Anonymous)
By members zenofex3 and WanderingGlitch.
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HEAP_BUF_SIZE 7  // Total size including space for null terminator

int main() {
    // Modified input: '(', '\', '\0', 'X', '\0'
    // Simulates malformed escape that writes a null, but parser keeps going to 'X'
    char input_buf[8] = {'(', '\\', '\0', 'X', '\0'};

    // Allocate heap buffer
    char *heap_buf = malloc(HEAP_BUF_SIZE);
    if (!heap_buf) {
        return 1;
    }

    // Initialize heap with 'A' for visibility
    memset(heap_buf, 0x41, HEAP_BUF_SIZE);

    // Setup pointers
    char *valptr = heap_buf;
    char *valend = heap_buf + HEAP_BUF_SIZE - 1;  // Leave room for null terminator
    const char *cur = input_buf;
    int parens = 1;

    // Ensure input starts with '('
    if (*cur != '(') {
        free(heap_buf);
        return 1;
    }

    cur++;  // Skip initial '('

    // Begin parsing loop
    while (*cur) {
        if (*cur == ')' && parens == 1) {
            break;
        }

        if (*cur == '(') {
            parens++;
        } else if (*cur == ')') {
            parens--;
        }

        if (valptr >= valend) {
            break;
        }

        if (*cur == '\\') {
            cur++;  // Move past backslash
            *valptr++ = *cur;  // Copy next character (even if it's '\0')
        } else {
            *valptr++ = *cur;
        }

        cur++;  // Move to next character
    }

    *valptr = '\0';  // Null-terminate heap buffer

    free(heap_buf);  // Clean up
    return 0;
}
